## OOD

[1. Что такое ООД? Какие задачи выполняет ООД?](#1-Что-такое-ООД-Какие-задачи-выполняет-ООД)

[2. Расскажите о принципах KISS, DRY, YAGNI?](#2-Расскажите-о-принципах-kiss-dry-yagni)

[3. Что такое SOLID?](#3-Что-такое-solid)

[4. Для чего используется JavaDoc?](#4-Для-чего-используется-javadoc)

[5. Как писать JavaDoc? Опишите основные теги @param, @return, @throws.](#5-Как-писать-javadoc-Опишите-основные-теги-param-return-throws)

[6. Что такое Java code convention?](#6-Что-такое-java-code-convention)

[7. Расскажите про принципы составления Java класса.](#7-Расскажите-про-принципы-составления-java-класса)

[8. Что такое SRP?](#8-Что-такое-srp)

[9. Расскажите о нарушениях принципа SRP.](#9-Расскажите-о-нарушениях-принципа-srp)

[10. Каковы последствия нарушения SRP?](#10-Каковы-последствия-нарушения-srp)

[11. Что такое OCP?](#11-Что-такое-ocp)

[12. Расскажите о нарушениях принципа OCP.](#12-Расскажите-о-нарушениях-принципа-ocp)

[13. Каковы последствия нарушения OCP?](#13-Каковы-последствия-нарушения-ocp)

[14. Что такое LSP?](#14-Что-такое-lsp)

[15. Расскажите о нарушениях принципа LSP.](#15-Расскажите-о-нарушениях-принципа-lsp)

[16 Каковы последствия нарушения LSP?](#16-Каковы-последствия-нарушения-lsp)

[17. Что такое ISP?](#17-Что-такое-isp)

[18. Расскажите о нарушениях принципа ISP.](#18-Расскажите-о-нарушениях-принципа-isp)

[19. Каковы последствия нарушения ISP?](#19-Каковы-последствия-нарушения-isp)

[20. Что такое DIP?](#20-Что-такое-dip)

[21. Расскажите о нарушениях принципа DIP.](#21-Расскажите-о-нарушениях-принципа-dip)

[22. Каковы последствия нарушения DIP?](#22-Каковы-последствия-нарушения-dip)

[23 Расскажите, что такое автоматизированное тестирование.](#23-Расскажите-что-такое-автоматизированное-тестирование)

[24. Как в Java осуществляется автоматизированное тестирование?](#24-Как-в-java-осуществляется-автоматизированное-тестирование)

[25. Что такое JUnit? Как использовать ее для тестирования?](#25-Что-такое-junit-Как-использовать-её-для-тестирования)

[26. Что такое функциональное тестирование и чем отличается оно от модульного?](#26-Что-такое-функциональное-тестирование-и-чем-отличается-оно-от-модульного)

[27. Расскажите про принцип TDD.](#27-Расскажите-про-принцип-tdd)

[28. Расскажите про принцип BDD.](#28-Расскажите-про-принцип-bdd)

[29. Что такое тестирование черным, белым, серым ящиком?](#29-Что-такое-тестирование-черным-белым-серым-ящиком)

[30. Опишите типы тестов: модульное, интеграционное, функциональное, приемочное?](#30-Опишите-типы-тестов-модульное-интеграционное-функциональное-приемочное)

## 1. Что такое ООД? Какие задачи выполняет ООД?

**Объектно-ориентированный дизайн (ООД)** — это методика проектирования, точка, в которой во время работы над продуктом 
сходятся все члены команды: дизайнеры, проектировщики, разработчики, SEO-специалисты и копирайтеры. В этом случае под 
дизайном понимается не столько внешний вид системы, сколько то, как она работает.

ООД помогает команде решить несколько важных задач.

**Определиться, с чего начать**

Вопрос «С чего начать?» возникает даже у самых опытных. Допустим, вам нужно разработать мобильное приложение по доставке
котиков. Что вы сделаете в первую очередь? Можно начать рисовать экраны или продумывать структуру, а можно проектировать 
сущности.

Какие сущности есть в таком приложении? Наверняка там будут «пользователь», «заказ» и «котик». У «пользователя» есть имя 
и фамилия, а заказ можно сделать из двух мест: с экрана товара или с экрана со списком ранее оформленных заказов. Значит
позже нужно подумать, как отразить это в интерфейсе.

ООД дает базис, от него можно оттолкнуться, чтобы собрать конструктор из методов, которые подходят именно для этого проекта.

**Сэкономить**

Проектирование — самый дешевый процесс в создании системы, на этом этапе принято развлекаться, генерировать идеи и смело 
отметать то, что не подошло.

Однако у проектирования есть очень дорогой и сложный подпроцесс — прототипирование. Зачастую в него вовлечена вся команда 
и эксперты со стороны клиента, прототипирование делается долго, а в процессе генерируется слишком много отвлеченных идей.

Не хочется чтобы наш дизайнер неделю проектировал, например, функцию отложенной оплаты, которая никогда не будет 
использоваться. ООД помогает от этого избавиться.

**Создать MVP**

В работе со стартапами ООД помогает разобраться, что является MVP (минимально ценностным продуктом) проекта и в первую 
очередь сделать только то, что действительно нужно.

MVP — это продукт, который стоит максимально дешево, но уже может приносить пользу конечным пользователям.

Пример очень бюджетного MVP — стартап по продаже обуви Zappos, который невероятно взлетел, привлек много инвестиций и 
превратился в суперсервис. Но в самом начале у его основателя Ника Свинмерна не было ничего, кроме совсем простого сайта.
Он размещал там фотографии обуви из местных магазинов, чтобы понять, есть ли на нее спрос. Когда кто-то делал заказ, 
Ник покупал эту пару и привозил клиенту. Свинмерн не вкладывался в инфраструктуру и оборудование, но смог создать у 
клиентов иллюзию полноценного сервиса и с минимальными затратами проверил, востребован ли его продукт.

**Исключить хаотичные скачки**

Спроектировать все возможные состояния самых сложных страниц, а потом понять, что сайт вообще не нужен — очень обидно. 
Хочется, чтобы таких ситуаций было меньше, и чтобы команда равномерно двигалась по уровню декомпозиции от большого к малому.

Чтобы не делать лишнюю работу, сначала проектируют объекты и только потом — способы взаимодействия с ними. Пока вы не 
решили, какие объекты вам нужны и не составили список, не нужно думать о том, что и как с ними делать.

Мыслить таким образом тяжело: обычно мозг сам раскручивает клубок идей и не может остановиться. Если нужно сделать 
рейтинг, следом обязательно приходит идея добавить отзывы и реферальную программу. Хочется сразу идти и делать, а 
обсуждать и анализировать необходимость этого не хочется совсем. В такие моменты нужно тормозить себя или клиента и 
двигаться только по шагам.

[к оглавлению](#OOD)

## 2. Расскажите о принципах KISS, DRY, YAGNI?

**KISS** - **K**eep **I**t **S**imple, **S**tupid / *Будь проще*.

Принцип значит следущее - не придумывайте к задаче более сложного решения, чем ей требуется. Иногда самое разумное решение
оказывается и самым простым. Написание производительного, эффективного и простого кода - это прекрасно.

---

**DRY** - **D**on't **R**epeat **Y**ourself / *Не повторяйтесь*.

Дублирование кода - пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код
сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

---

**YAGNI** - **Y**ou **A**ren't **G**onna **N**eed **I**t / *Вам это не понадобится*

Если пишите код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже. Этот
принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние
методы. Даже если раньше они были полезны - теперь они не нужны.

[к оглавлению](#OOD)

## 3. Что такое SOLID?

**SOLID** - это акроним пяти основных принципов дизайна классов в объектно-ориентированном проектировании. Главная цель
этих принципов - повысить гибкость вашей архитектуры, уменьшить связанность между её компонентами и облегчить повторное
использование кода.

Вот что входит в принципы SOLID:
1. **S**ingle Responsibility Principle (Принцип единственной ответственности)
2. **O**pen Closed Principle (Принцип открытости/закрытости)
3. **L**iskov`s Substitution Principle (Принцип подстановки Лисков)
4. **I**nterface Segregation Principle (Принцип разделения интерфейса)
5. **D**ependency Inversion Principle (Принцип инверсии зависимостей)

P.S.: Но, как и всё в этой жизни, соблюдение этих принципов имеет свою цену. Здесь это в основном выражается в 
усложнении кода программы. В реальной жизни, пожалуй, нет такого кода, в котором бы соблюдались все эти принципы сразу. 
Поэтому необходимо помнить о балансе и не воспринимать всё изложенное как догму.

[к оглавлению](#OOD)

## 4. Для чего используется JavaDoc?

**JavaDoc** - это генератор документации в HTML-формате из комментариев исходного кода Java. Для создания элементов, 
которые позволят программисту анализировать структуру приложения, JavaDoc предоставляет API. При этом комментарий должен 
находиться перед документируемым элементом.

Многие IDE также используют Javadoc для генерации контекстных описаний API.

[к оглавлению](#OOD)

## 5. Как писать JavaDoc? Опишите основные теги @param, @return, @throws.

Утилита JavaDoc позволяет вставлять HTML тэги и использовать специальные ярлыки (дескрипторы) документирования. НТМL 
тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой. Дескрипторы JavaDoc, 
начинающиеся со знака @, называются автономными и должны помещаться с начала строки комментария (лидирующий символ * 
игнорируется). Дескрипторы, начинающиеся с фигурной скобки, например {@code}, называются встроенными и могут применяться
внутри описания.

Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и 
методов. В каждом случае комментарий должен находиться перед документируемым элементом.

Документирование класса, метода или переменной начинается с комбинации символов /** , после которого следует тело 
комментариев; заканчивается комбинацией символов */. В тело комментариев можно вставлять различные дескрипторы. Каждый 
дескриптор, начинающийся с символа '@' должен стоять первым в строке. Несколько дескрипторов одного и того же типа 
необходимо группировать вместе. Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого 
описания.

Описание основных дескрипторов:
1. Применяются только для **классов или интерфейсов**:
    + `@author` - указывается имя автора;
    + `@version` - указывается версия нашего класса. Не более одного дескриптора на класс.
2. Применяются только для **методов**:
    + `@param` - приводится описание входного параметра описываемого метода
    + `@return` - описывается возвращаемое значение документируемого метода
    + `@exception имя_класса_исключения` - приводится описание исключения, которое может бросить описываемый метод.
3. Применяются для **классов, интерфейсов, полей и методов**:
    + `@since` - указывается с какой версии доступен документируемый элемент
    + `@see` - тут можно указать ссылку на другое место в документации
    + `@deprecated` - описываются устаревшие блоки кода
    + `{@link reference}` - можно указать ссылку на другой класс, метод и прочее

```java
/** 
 * Класс продукции со свойствами <b>maker</b> и <b>price</b>.
 * @autor Киса Воробьянинов
 * @version 2.1
*/
class Product {
    /**
     * Поле производитель 
     */
    private String maker;
     
    /** 
     * Поле цена 
     */ 
    public double price;
    
    /** 
     * Конструктор - создание нового объекта
     * @see Product#Product(String, double)
     */
    Product() {
        setMaker("");
        price=0;
    }
    
    /** 
     * Конструктор - создание нового объекта с определенными значениями
     * @param maker - производитель
     * @param price - цена
     * @see Product#Product()
     */
    Product (String maker, double price) {
        this.setMaker(maker);
        this.price=price;
    }
    
    /**
     * Функция получения значения поля {@link Product#maker}
     * @return возвращает название производителя
     */
    public String getMaker() {
        return maker;
    }
    
    /**
     * Процедура определения производителя {@link Product#maker}
     * @param maker - производитель
     */
    public void setMaker(String maker) {
        this.maker = maker;
    }
}
```

[к оглавлению](#OOD)

## 6. Что такое Java code convention?

**Java Code Convention** - Документ Oracle по правилам оформления кода.

Почти в каждой крупной организации или группе разработчиков есть свой стандарт оформления кода. Один из стандартов,
предложенный Sun для программирования на Java - **"Java Code Convention"**, следуя которому, получается весьма 
компактный, но в то же время прекрасно читаемый код. **Java Code Convention** во многом применим и для других языков.

Соглашения по оформлению кода важны для программистов по ряду причин:
+ 80% от стоимости программного обеспечения приходится на его обслуживание.
+ Вряд ли какое-либо программное обеспечение все время поддерживается первоначальным разработчиком.
+ Соглашения по оформлению кода делают исходный код программ более удобочитаемым, позволяя инженерам быстрее и 
  тщательнее понимать новый код.
+ Если вы предоставляете исходный код как продукт, вы должны убедится, что он хорошо оформлен и упакован как любой другой
  продукт который вы создаете

[к оглавлению](#OOD)

## 7. Расскажите про принципы составления Java класса.

Смотреть вопросы:

[2. Расскажите о принципах KISS, DRY, YAGNI?](#2-Расскажите-о-принципах-kiss-dry-yagni)

[3. Что такое SOLID?](#3-Что-такое-solid)

[к оглавлению](#OOD)

## 8. Что такое SRP?

**SRP (Single Responsibility Principle)** - у класса должен быть только один мотив для изменения.

Стремитесь к тому, чтобы каждый класс отвечал только за одну часть функциональности программы, причем она должна быть 
полностью инкапсулирована в этот класс.

Принцип единственной ответственности предназначен для борьбы со сложностью. Когда в вашем приложении всего 200 строк 
кода, то дизайн как таковой вообще не нужен. Достаточно аккуратно написать 5-7 методов, и всё будет хорошо. Проблемы 
возникают, когда система растёт и увеличивается в масштабах. Когда класс разрастается, он просто перестаёт помещаться в
голове. Навигация затрудняется, на глаза попадаются ненужные детали, связанные с другим аспектом, в результате 
вы начинаете терять контроль над кодом.

Если класс делает слишком много вещей сразу, вам приходится изменять его каждый раз, когда одна из этих вещей 
изменяется. При этом есть риск сломать остальные части класса, которые вы даже не планировали трогать.

Хорошо иметь возможность сосредоточиться на сложных аспектах системы по отдельности. Но если вам становится сложно это 
делать, применяйте принцип единственной ответственности, разделяя ваши классы на части.

[к оглавлению](#OOD)

## 9. Расскажите о нарушениях принципа SRP.

Пример:

Класс `Employee` имеет сразу несколько причин для изменения. Первая связана с основной задачей класса - управлением 
данными сотрудника. Но есть и вторая: изменения, связанные с форматированием отчёта для печати, будут затрагивать класс
сотрудников.

![ ](images/OOD/srp_1.png)

*ДО: класс сотрудника содержит разнородные поведения.*

Проблему можно решить, выделив операцию печати в отдельный класс.

![ ](images/OOD/srp_2.png)

*ПОСЛЕ: лишнее поведение переехало в собственный класс.*

[к оглавлению](#OOD)

## 10. Каковы последствия нарушения SRP?

Что является причиной изменения логики работы класса?
Изменение отношений между классами, введение новых требований или отмена старых.

Если изменения в модуле могут запрашивать несколько ролей, то и меняться он будет часто.
А это ведет ***к хрупкости дизайна и ошибкам в неожиданных местах при изменениях кода***.

[к оглавлению](#OOD)

## 11. Что такое OCP?

**OCP (Open/Closed Principle)** - расширяйте классы, но не изменяйте их первоначальный код.

Стремитесь к тому, чтобы классы были открыты для расширения, но закрыты для изменения. Главная идея этого принципа в 
том, чтобы не ломать существующий код при внесении изменений в программу.

Класс можно назвать открытым, если он доступен для расширения. Например, у вас есть возможность расширить набор его 
операций или добавить к нему новые поля, создав собственный подкласс.

В то же время, класс можно назвать закрытым (а лучше сказать, *законченным*), если он готов для использования другими
классами. Это означает, что интерфейс класса уже окончательно определён и не будет изменяться в будущем.

Если класс уже был написан, одобрен, протестирован, возможно, внесён в библиотеку и включён в проект, после этого 
пытаться модифицировать его содержимое нежелательно. Вместо этого вы можете создать подкласс и расширить в нём базовое
поведение, не изменяя код родительского класса напрямую.

Но не стоит следовать этому принципу буквально для каждого изменения. Если вам нужно исправить ошибку в исходном классе,
просто возьмите и сделайте это. Нет смысла решать проблему родителя в дочернем классе.

[к оглавлению](#OOD)

## 12. Расскажите о нарушениях принципа OCP.

Пример:

Класс заказов имеет метод расчёта стоимости доставки, причём способы доставки «зашиты» непосредственно в сам
метод. Если вам нужно будет добавить новый способ доставки, то придётся трогать весь класс `Order`.

![ ](images/OOD/ocp_1.png)

*ДО: код класса заказа нужно будет изменять при добавлении нового способа доставки.*

Проблему можно решить, если применить паттерн *Стратегия*. Для этого нужно выделить способы доставки в собственные 
классы с общим интерфейсом. 

![ ](images/OOD/ocp_2.png)

*ПОСЛЕ: новые способы доставки можно добавить, не трогая класс заказов.*

Теперь при добавлении нового способа доставки нужно будет реализовать новый класс интерфейса доставки, не трогая класс 
заказов. Объект способа доставки в класс заказа будет подавать клиентский код, который раньше устанавливал способ 
доставки простой строкой.

Бонус этого решения в том, что расчёт времени и даты доставки тоже можно поместить в новые классы, повинуясь принципу 
единственной ответственности.

[к оглавлению](#OOD)

## 13. Каковы последствия нарушения OCP?

При изменении требований придется каждый раз изменять существующий код, что влечет за собой также изменение тестов.

[к оглавлению](#OOD)

## 14. Что такое LSP?

**LSP (Liskov Substitution Principle)** - подклассы должны дополнять, а не замещать поведение базового класса.

Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового 
класса, не ломая при этом функциональности клиентского кода.

Принцип подстановки - это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с остальным кодом
программы, который до этого успешно работал, используя объекты базового класса. Это особенно важно при разработке 
библиотек и фреймворков, когда ваши классы используются другими людьми, и вы не можете повлиять на чужой клиентский код,
даже если бы хотели.

В отличие от других принципов, которые определены очень свободно и имеют массу трактовок, принцип подстановки имеет ряд
формальных требований к подклассам, а точнее, к переопределённым в них методам.

+ **Типы параметров метода подкласса должны совпадать или быть более абстрактными, чем типы параметров базового 
  метода.** Довольно запутанно? Рассмотрим, как это работает на примере.
  + Базовый класс содержит метод `feed(Cat c`, который умеет кормить домашних котов. Клиентский код это знает и всегда
   передаёт в метод кота.
  + **Хорошо:** Вы создали подкласс и переопределили метод кормёжки так, чтобы накормить любое животное: 
    `feed(Animal c)`. Если подставить этот подкласс в клиентский код, то ничего страшного не произойдёт. Клиентский код
    подаст в метод кота, но метод умеет кормить всех животных, поэтому накормит и кота.
  + **Плохо:** Вы создали другой подкласс, в котором метод умеет кормить только бенгальскую породу котов (подклссс 
    котов): `feed(BengalCat c)`. Что будет с клиентскоим кодом? Он всё так же подаст в метод обычного кота. Но метод 
    умеет кормить только бенгалов, поэтому не сможет обработать сломав клиентский код.
    

+ **Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового 
  метода.** Здесь всё то же, что и в предыдущем пункте, но наоборот.
  + Базовый метод: `buyCat(): Cat`. Клиентский код ожидает на выходе любого домашнего кота.
  + **Хорошо:** Метод подкласса: `buyCat(): BengalCat`. Клиентский код получит бенгальского кота, который является
    домашним котом, поэтому всё будет хорошо.
  + **Плохо:** Метод подкласса: `buyCat(): Animal`. Клиентский код сломается, так как это непонятное животное (возможно,
    крокодил) не поместится в ящике-переноске для кота.


+ **Метод не должен выбрасывать исключения, которые не свойственны базовому методу.** Типы исключений в переопределённом
  методе должны совпадать или быть подтипами исключений, которые выбрасывает базовый метод. Блоки `try-catch` в
  клиентском коде нацелены на конкретные типы исключений, выбрасываемые базовыми методом. Поэтому неожиданное
  исключение, выброшенное подклассом, может проскочить сквозь обработчики клиентского кода и обрушить программу.

*В большинстве совеременных языков программирования, особенно строго типизированных (Java, C# и другие), перечисленные
ограничения встроены прямо в компилятор. Поэтому вы просто не сможете собрать программу, нарушив их.*

+ **Метод не должен ужесточать пред-условия.** Например, базовый метод работает с параметром типа `int`. Если подкласс 
  требует, чтобы значение этого параметра к тому же было больше нуля, то это ужесточает предусловия. Клиентский код, 
  который до этого отлично работал, подавая в метод негативные числа, теперь сломается при работе с объектом подкласса.
  
+ **Метод не должен ослаблять пост-условия.** Например, базовый метод требует, чтобы по завершению метода все 
  подключения к базе данных были закрыты, а подкласс оставляет эти подключения открытыми, чтобы потом повторно 
  использовать. Но клиентский код базового класса ничего об этом не знает. Он может завершить программу сразу после 
  вызова метода, оставив запущенные процессы-призраки в системе.
  
+ **Инварианты класса должны остаться без изменений.** Инвариант - это набор условий, при которых объект имеет смысл. 
  Например, инвариант кота - это наличие четырёх лап, хвоста, способность мурчать и прочее. Инвариант может быть описан 
  не только явным контрактом или проверками в методе класса, но и косвенно, например, юнит-тестами или клиентским кодом.
  
  Этот пункт проще всего нарушить при наследовании, так как вы можете попросту не подозревать о каком-то из условий 
  инварианта сложного класса. Идеальным в этом отношении был бы подкласс, который только вводит новые методы и поля, не 
  прикасаясь к полям базового класса.
  
+ **Подкласс не должен изменять значения приватных полей базового класса.** Этот пункт звучит странно, но в некоторых 
  языках доступ к приватным полям можно получить через механизм рефлексии.

[к оглавлению](#OOD)

## 15. Расскажите о нарушениях принципа LSP.

Пример неудачной иерархии классов документов.

![ ](images/OOD/lsp_1.png)

*ДО: подкласс «обнуляет» работу базового метода.*

Метод сохранения в подклассе `ReadOnlyDocuments` выбросит исключение, если кто-то попытается вызвать его метод 
сохранения. Базовый метод не имеет такого ограничения. Из-за этого клиентский код вынужден проверять тип документа при
сохранении всех документов.

При этом нарушается ещё и принцип открытости/закрытости, так как клиентский код начинает зависеть от конкретного класса,
который нельзя заменить на другой, не внося изменений в клиентский код.

![ ](images/OOD/lsp_2.png)

*ПОСЛЕ: подкласс расширяет базовый класс новым поведением.*

Проблему можно решить, перепроектировав иерархию классов. Базовый класс сможет только открывать документы, но не 
сохранять их. Подкласс, который теперь будет называться `WritableDocument`, расширит поведение родителя, позволив 
сохранять документ.

[к оглавлению](#OOD)

## 16. Каковы последствия нарушения LSP?

Неожиданное поведение классов. Ошибки в программе при замене на подклассы.

[к оглавлению](#OOD)

## 17. Что такое ISP?

**ISP (Interface Segregation Principle)** - Клиенты не должны зависеть от методов, которые они не используют.

Стремитесь к тому, чтобы интерфейсы были достаточно узкими, чтобы классам не приходилось реализовывать избыточное 
поведение.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и
специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге при
изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

Наследование позволяет классу иметь только один суперкласс, но не ограничивает количество интерфейсов, которые он может
реализовать. Большинство объектных языков программирования позволяют классам реализовывать сразу несколько интерфейсов, 
поэтому нет нужды заталкивать в ваш интерфейс больше поведений, чем он того требует. Вы всегда можете присвоить классу
сразу несколько интерфейсов поменьше.

[к оглавлению](#OOD)

## 18. Расскажите о нарушениях принципа ISP.

Пример:

Представьте библиотеку для работы с облачными провайдерами. В первой версии она поддерживала только Amazon, имеющий 
полный набор облачных услуг. Исходя из них и проектировался интерфейс будущих классов.

Но позже стало ясно, что получившийся интерфейс облачного провайдера слишком широк, так как есть другие провайдеры, 
реализующие только часть из всех возможных сервисов.

![ ](images/OOD/isp_1.png)

*ДО: не все клиенты могут реализовать операции интерфейса.*

Чтобы не плодить классы с пустой реализацией, раздутый интерфейс можно разбить на части. Классы, которые были способны 
реализовать все операции старого интерфейса, могут реализовать сразу несколько новых частичных интерфейсов.

![ ](images/OOD/isp_2.png)

*ПОСЛЕ: раздутый интерфейс разбит на части.*

[к оглавлению](#OOD)

## 19. Каковы последствия нарушения ISP?

Дублирование кода - мы вынуждены будем переопределять неиспользуемые методы в классах, реализующих "большой" интерфейс.

Кроме того, с точки зрения архитектуры проекта, зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, 
могут стать причиной неожиданных проблем.

[к оглавлению](#OOD)

## 20. Что такое DIP?

**DIP (Dependency Inversion Principle)** - классы верхних уровней не должны зависеть от классов нижних уровней. Оба 
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Обычно при проектировании программ можно выделить два уровня классов.

+ **Классы нижнего уровня** реализуют базовые операции вроде работы с диском, передачи данных по сети, подключения к 
  базе данных и прочее.
  
+ **Классы высокого уровня** содержат сложную бизнес-логику программы, которая опирается на классы низкого уровня для 
  осуществления более простых операций.
  
Зачастую вы сперва проектируете классы нижнего уровня, а только потом берётесь за верхний уровень. При таком подходе 
классы бизнес-логики становятся зависимыми от более примитивных низкоуровневых классов. Каждое изменение в 
низкоуровневом классе может затронуть классы бизнес-логики, которые его используют.

Принцип инверсии зависимостей предлагает изменить направление, в котором происходит проектирование.

1. Для начала вам нужно описать интерфейс низкоуровневых операций, которые нужны классу бизнес-логики.
2. Это позволит убрать зависимость класса бизнес-логики от конкретного низкоуровневого класса, заменив её «мягкой» 
   зависимостью от интерфейса.
3. Низкоуровневый класс, в свою очередь, станет зависимым от интерфейса, определенного бизнес-логикой.

Принцип инверсии зависимостей часто идёт в ногу с принципом открытости/закрытости: вы сможете расширять низкоуровневые 
классы и использовать их вместе с классами бизнес-логики, не изменяя код последних.

[к оглавлению](#OOD)

## 21. Расскажите о нарушениях принципа DIP.

В этом примере высокоуровневый класс формирования бюджетных отчётов напрямую использует класс базы данных для загрузки и
сохранения своей информации.

![ ](images/OOD/dip_1.png)

*ДО: высокоуровневый класс зависит от низкоуровневого.*

Проблему можно исправить, создав высокоуровневый интерфейс для загрузки/сохранения данных и привязав к нему класс 
отчетов. Низкоуровневые классы должны реализовать этот интерфейс, чтобы их объекты можно было использовать внутри 
объекта отчётов.

![ ](images/OOD/dip_2.png)

*ПОСЛЕ: низкоуровневые классы зависят от высокоуровневой абстракции.*

Таким образом, меняется направление зависимости. Если раньше высокий уровень зависел от низкого, то сейчас всё наоборот -
низкоуровневые классы зависят от высокоуровневого интерфейса.

[к оглавлению](#OOD)

## 22. Каковы последствия нарушения DIP?

Каждое изменение абстрактного интерфейса вызывает изменение его конкретной реализации. Изменение конкретной реализации, 
напротив, не всегда сопровождается изменениями и даже обычно не требует изменений в соответствующих интерфейсах. Т.е. 
интерфейсы менее изменчивы, чем реализации.

***Вместо замены реализации, придется изменять сам класс.***

Если в приложении абстракции не отделены от деталей, то изменение логики в низкоуровневых реализациях
может неожиданно привести к поломке высокоуровневых модулей. Тестировать такую систему будет очень сложно. Даже если 
получится написать модульные тесты, то любое изменение в системе приведет к тому, что эти тесты придется переписывать.

***В результате получим жесткую, хрупкую, неподвижную систему, которую сложно тестировать.***

1. Жесткость - тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.
2. Хрупкость - когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.
3. Неподвижность - очень сложно повторно использовать код в другом приложении, т.к. модули сильно связаны между собой.

[к оглавлению](#OOD)

## 23. Расскажите, что такое автоматизированное тестирование.

**Автоматизированное тестирование** – это процесс написание тестов в виде повторно запускаемого блока кода. Тест – это 
проверка заведомо нужного поведения программы. В качестве противопоставления автоматизированному тестированию существует
ручное тестирование. Оно предполагает, что тест выполняется не компьютером, а человеком, он сам делает проверки и 
решает, что верно, а что нет.

Все тесты базируются на принципе **AAA** – **A**rrange **A**ct **A**ssert. **Arrange** – указание входных и ожидаемых 
данных программы. **Act** – выполнение программы путем передачи входных и получение выходных данных. **Assert** – 
сравнение выходных и ожидаемых данных.

![ ](images/OOD/AAA.png)

[к оглавлению](#OOD)

## 24. Как в Java осуществляется автоматизированное тестирование?

С помощью библиотек для автоматического тестирования (например):

+ **JUnit** - это опенсорсный фреймворк регрессионного тестирования, в основном используемый опытными разработчиками ПО 
  для выполнения юнит-тестирования, ускорения программирования и повышения качества кода в Java. Основная его цель - 
  позволить Java-разработчикам писать скрипты и реализовывать повторяющиеся тест-кейсы. Это один из наиболее часто 
  используемых фреймворков модульного тестирования Java.
  
+ **Serenity** - ранее известный как Thucydides, Serenity является одним из самых широко используемых открытых BDD-
  фреймворков тестирования Java. Он поможет в написании более четких, структурированных и настраиваемых критериев 
  приемки.
  
+ **Gauge** - это бесплатная open-source среда тестовой автоматизации Java, которая снижает нагрузку с приемочного 
  тестирования и сокращает использование кода. Это один из наиболее часто используемых фреймворков для тестирования 
  мобильных веб-сайтов.

[к оглавлению](#OOD)

## 25. Что такое JUnit? Как использовать ее для тестирования?

JUnit — это фреймворк автоматического тестирования отдельных модулей кода, например, методов или классов. Тесты это 
отдельный класс.

Юнит-тесты должны быть небольшими. В идеальном случае — одно утверждение (assert) на тест.
Так модульный тест будет соответствовать SRP, а также быстрее выполняться.

В юнит-тестах стоит использовать шаблон "Arrange, Act and Assert (AAA)", т.е. четко определить:
+ Arrange - предусловия (инициализация тестовых данных, предварительные установки);
+ Act - действие (вызов тестируемого метода);
+ Assert - постусловия (что должно быть в результате выполнения действия).

Подобное оформление повышает читаемость кода и облегчает его использование в качестве документации
к тестируемой функциональности.

```java
import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.core.Is.is;

public class TemplateTest {

    @Test
    public void whenUniqueKeysThenTheyAreReplaced() {
       
        //arrange
        Template template = new SimpleGenerator();
        String data = "I am ${name}, Who are ${subject}?";
        Map<String, String> map = new HashMap<>();
        map.put("name", "Petr");
        map.put("subject", "you");
        String expected = "I am Petr, Who are you?";

        //act
        String result = template.generate(data, map);

        //action
        Assert.assertThat(result, is(expected));
    }
}
```

После объявления класса TemplateTest мы создаем тест-методы.

Методы должны иметь отличие только в имени, остальной каркас всегда остается одинаковым. Аннотация @Test позволяет 
запустить каждый метод по отдельности.

Для улучшения читаемости кода в связке c JUnit используется библиотека matcher-ов Hamcrest.
Matcher – это выражение, тестирующее на совпадение с определенным условием.

Плюсы использования JUnit:
+ Открытый исходный код, тестовые наборы/комплекты, аннотации, простая интеграция (Spring, CI и т.д.)
+ При рефакторинге кода, тесты JUnit помогут нам проследить, чтобы логика нашей программы не поломалась.
+ JUnit сработает еще лучше в связке с Maven. При сборке проекта Maven обязательно проведет все тесты и потом соберет 
  готовый проект. Если тесты будут провалены, проект не будет собран, но мы будем знать причины, и так будет легче 
  разобраться где именно поломка.

[к оглавлению](#OOD)

## 26. Что такое функциональное тестирование и чем отличается оно от модульного?

Обычно используют два вида автоматических тестов:

**Модульное тестирование (unit testing)** - это тестирование отдельных частей продукта. Unit — наименьшая тестируемая 
часть ПО, обычно метод или класс.

Юнит-тесты проверяют выполнение конкретного набора задач методом или классом. Юнит тестирование по определению является 
тестированием белого ящика.

**Функциональное тестирование (functional testing) —** это тестирование некоего функционала продукта, при этом продукт 
воспринимается как единый «чёрный ящик».

Функциональные тесты проверяют работу системы на соответствие требованиям, указанным в спецификации продукта. Внешнее 
поведение системы (логика работы продукта) проверяется независимо от внутренней реализации.

**Отличия:**
+ Даже успешное прохождение всех юнит-тестов не гарантирует правильной работы продукта: ведь одна и та же функция
  может быть использована в различных частях системы, в то время как юнит-тест писался для неё с оглядкой лишь
  на один вариант использования.

+ Функциональные тесты полностью определяют (по крайней мере должны) работоспособность продукта. И прежде всего нужны 
  заказчику/руководителю разработки. Юнит-тестирование прежде всего нужно самим разработчикам, для быстрого нахождения 
  ошибок или проверки последствий рефакторинга.

[к оглавлению](#OOD)

## 27. Расскажите про принцип TDD.

**TDD (Test Driven Development)** - это методология разработки программного обеспечения, которая основывается на 
повторении коротких циклов разработки. 

Методика разработки через тестирование заключается в организации автоматического тестирования разрабатываемых приложений
путем написания модульных, интеграционных и функциональных тестов, определяющих требования к коду непосредственно перед 
написанием этого самого кода. Сначала пишется тест, который проверяет корректность работы еще ненаписанного программного 
кода. Этот тест, разумеется, не проходит. После этого разработчик пишет код, который выполняет действия, требуемые для 
прохождения теста. После того, как тест успешно пройден, по необходимости осуществляется рефакторинг (доработка и 
переработка) написанного кода, причём в этом случае рефакторинг осуществляется уже под контролем прохождения тестов, что 
проще и надёжнее.

**Цикл разработки по TDD**

+ Добавить тест для новой (еще не реализованной) функциональности или для воспроизведения существующего бага
+ Запустить все тесты и убедиться, что новый тест не проходит
+ Написать код, который обеспечит прохождение теста
+ Запустить тесты и убедиться, что они все прошли успешно: прохождение нового теста подтверждает реализацию нового 
  функционала или исправление существующей ошибки, а прохождение остальных позволяет удостовериться, что ранее 
  реализованный функционал работает по-прежнему корректно.
+ Заняться рефакторингом и оптимизацией — улучшение сопровождаемости и быстродействия целесообразно осуществлять уже 
  после того, как получилось добиться проверяемой работоспособности
+ Перезапустить тесты и убедиться, что они все ещё проходят успешно
+ Повторить цикл

Эта методология позволяет добиться создания пригодного для автоматического тестирования приложения и очень хорошего 
покрытия кода тестами, так как ТЗ переводится на язык автоматических тестов, то есть всё, что программа должна делать, 
проверяется. Также TDD часто упрощает программную реализацию: так как исключается избыточность — если компонент проходит 
тест, то он считается готовым. Если же существующие тесты проходят, но работает компонент не так, как ожидается, то это 
значит, что тесты пока не отражают всех требований и это повод добавить новые тесты.

Архитектура программных продуктов, разрабатываемых таким образом, обычно лучше. Стабильность работы приложения, 
разработанного через тестирование, также выше за счёт того, что все основные функциональные возможности программы покрыты
тестами и их работоспособность постоянно проверяется. Сопровождаемость проектов, где тестируется всё или практически 
всё, очень высока — разработчики могут не бояться вносить изменения в код, если что-то пойдёт не так, то об этом сообщат 
результаты автоматического тестирования.

[к оглавлению](#OOD)

## 28. Расскажите про принцип BDD.

**BDD (Behavior Driven Development)** - Разработка на основе поведения.

BDD является расширением TDD-подхода. В тоже время они предназначены для разных целей.

+ TDD подходит для юнит-тестирования. BDD - для интеграционного.
+ TDD: тесты сразу реализуются в коде, для BDD чаще всего описываются шаги на языке, понятном всем, а не только 
  разработчикам.
+ TDD: юнит тесты пишут разработчики. BDD требует объединения усилий разных членов команды.
+ TDD проверяет работу функций (методов), BDD - пользовательские сценарии.

**В чем преимущество BDD?**

+ Тесты читаемые не только для программистов.
+ Их легко изменять. Они часто пишутся почти на чистом английском.
+ Тесты не зависят от целевого языка программирования. Перенос на другой язык сильно упрощается.

В данном случае тесты это и описание и непосредственно реализация.

[к оглавлению](#OOD)

## 29. Что такое тестирование черным, белым, серым ящиком?

**Black Box**

**Summary: Мы не знаем, как устроена тестируемая система.**

Тестирование методом «черного ящика», также известное как тестирование, основанное на спецификации или тестирование 
поведения – техника тестирования, основанная на работе исключительно с внешними интерфейсами тестируемой системы.

**тестирование черного ящика – это:**

+ тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента 
  или системы.
+ тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа 
  функциональной или нефункциональной спецификации компонента или системы без знания ее внутреннего устройства.

Почему именно «черный ящик»? Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого 
он не видит. Целью этой техники является поиск ошибок в таких категориях:

+ неправильно реализованные или недостающие функции;
+ ошибки интерфейса;
+ ошибки в структурах данных или организации доступа к внешним базам данных;
+ ошибки поведения или недостаточная производительность системы;

Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. Нужно концентрироваться на том, 
что программа делает, а не на том, как она это делает.

**Преимущества:**

+ тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и противоречия в 
  спецификации;
+ тестировщику нет необходимости знать языки программирования и углубляться в особенности реализации программы;
+ тестирование может производиться специалистами, независимыми от отдела разработки, что помогает избежать предвзятого 
  отношения;
+ можно начинать писать тест-кейсы, как только готова спецификация.

**Недостатки:**

+ тестируется только очень ограниченное количество путей выполнения программы;
+ без четкой спецификации (а это скорее реальность на многих проектах) достаточно трудно составить эффективные 
  тест-кейсы;
+ некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне модульного 
  тестирования;

---

**White Box**

**Summary: Нам известны все детали реализации тестируемой программы.**

Тестирование методом белого ящика (также: прозрачного, открытого, стеклянного ящика; основанное на коде или структурное 
тестирование) – метод тестирования программного обеспечения, который предполагает, что внутренняя 
структура/устройство/реализация системы известны тестировщику. Мы выбираем входные значения, основываясь на знании кода,
который будет их обрабатывать. Точно так же мы знаем, каким должен быть результат этой обработки. Знание всех 
особенностей тестируемой программы и ее реализации – обязательны для этой техники. Тестирование белого ящика – 
углубление во внутренне устройство системы, за пределы ее внешних интерфейсов.

**тестирование белого ящика – это:**

+ тестирование, основанное на анализе внутренней структуры компонента или системы.
+ тест-дизайн, основанный на технике белого ящика – процедура написания или выбора тест-кейсов на основе анализа 
  внутреннего устройства системы или компонента.

Почему «белый ящик»? Тестируемая программа для тестировщика – прозрачный ящик, содержимое которого он прекрасно видит.

**Преимущества:**

+ тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского интерфейса;
+ можно провести более тщательное тестирование, с покрытием большого количества путей выполнения программы.

**Недостатки:**

+ для выполнения тестирования белого ящика необходимо большое количество специальных знаний
+ при использовании автоматизации тестирования на этом уровне, поддержка тестовых скриптов может оказаться достаточно 
  накладной, если программа часто изменяется.
  
----

**Grey Box**

**Summary: Нам известны только некоторые особенности реализации тестируемой системы.**

Тестирование методом серого ящика – метод тестирования программного обеспечения, который предполагает, комбинацию White 
Box и Black Box подходов. То есть, внутреннее устройство программы нам известно лишь частично. Предполагается, например,
доступ к внутренней структуре и алгоритмам работы ПО для написания максимально эффективных тест-кейсов, но само 
тестирование проводится с помощью техники черного ящика, то есть, с позиции пользователя.

Эту технику тестирования также называют методом полупрозрачного ящика: что-то мы видим, а что-то – нет.

[к оглавлению](#OOD)

## 30. Опишите типы тестов: модульное, интеграционное, функциональное, приемочное?

**Компонентный уровень**

Чаще всего называют юнит тестированием. Реже называют модульным тестированием. На этом уровне тестируют атомарные части 
кода. Это могут быть классы, функции или методы классов.

Юнит тесты находят ошибки на фундаментальных уровнях, их легче разрабатывать и поддерживать. Важное преимущество
модульных тестов в том, что они быстрые и при изменении кода позволяют быстро провести регресс (убедиться, что новый 
код не сломал старые части кода).

Тест на компонентном уровне:
1. Всегда автоматизируют.
2. Модульных тестов всегда больше, чем тестов с других уровней.
3. Юнит тесты выполняются быстрее всех и требуют меньше ресурсов. 
4. Практически всегда компонентные тесты не зависят от других модулей (на то они и юнит тесты) и UI системы.

В 99% разработкой модульных тестов занимается разработчик, при нахождении ошибки на этом уровне не создается баг-репортов.
Разработчик находит баг, правит, запускает и проверяет (абстрактно говоря это разработка через тестирование) и так по
новой, пока тест не будет пройден успешно.

На модульном уровне разработчик (или автотестер) использует метод белого ящика. Он знает что принимает и отдает 
минимальная единица кода, и как она работает.

**Интеграционный уровень**

Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также 
интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в
английских статьях называют service test или API test.

В случае с интеграционными тестами редко когда требуется наличие UI, чтобы его проверить. Компоненты ПО или системы
взаимодействуют с тестируемым модулем с помощью интерфейсов. Тут начинается участие тестирования. Это проверки API,
работы сервисов (проверка логов на сервере, записи в БД) и т.п.

Отдельно стоит отметить, что в интеграционном тестировании, выполняются как функциональные (проверка по ТЗ), так и 
нефункциональные проверки (нагрузка на связку компонент). На этом уровне используется либо серый, либо черный ящик.

В интеграционном тестировании есть 3 основных способа тестирования (представь, что каждый модуль может состоять еще из 
более мелких частей):

+ Снизу вверх (Bottom Up Integration): все мелкие части модуля собираются в один модуль и тестируются. Далее собираются
  следующие мелкие модули в один большой и тестируется с предыдущим и т.д. Например, функция публикации фото в соц. 
  профиле состоит из 2 модулей: загрузчик и публикатор. Загрузчик, в свою очередь, состоит из модуля компрессии и 
  отправки на сервер. Публикатор состоит из верификатора (проверяет подлинность) и управления доступом к фотографии. В 
  интеграционном тестировании соберем модули загрузчика и проверим, потом соберем модули публикатора, проверим и 
  протестируем взаимодействие загрузчика и публикатор.
+ Сверху вниз (Top Down Integration): сначала проверяем работу крупных модулей, спускаясь ниже добавляем модули уровнем 
  ниже. На этапе проверки уровней выше данные, необходимые от уровней ниже, симулируются. Например, проверяем работу 
  загрузчика и публикатора. Руками (создаем функцию-заглушку) передаем от загрузчика публикатору фото, которое якобы 
  было обработано компрессором.
+ Большой взрыв ("Big Bang" Integration): собираем все реализованные модули всех уровней, интегрируем в систему и
  тестируем. Если что-то не работает или недоработали, то фиксим или дорабатываем.

**Системный уровень**

О системном уровне говорили в интеграционном. Тут отметить только то, что:
1. Системный уровень проверят взаимодействие тестируемого ПО с системой по функциональным и нефункциональным требованиям.
2. Важно тестировать на максимально приближенном окружении, которое будет у конечного пользователя.

Тест-кейсы на этом уровне подготавливаются:
1. По требованиям.
2. По возможным способам использования ПО.

На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации
данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая
или неверная функциональность, неудобство использования и т.д.

На этом уровне используют черный ящик. Интеграционный уровень позволяет верифицировать требования (проверить
соответствие ПО прописанным требованиям).

**Приемочное тестирование**

Также часто называют E2E тестами (End-2-End) или сквозными. На этом уровне происходит валидация требований (проверка
работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне).

Проверка требований производится на наборе приемочных тестов. Они разрабатываются на основе требований и возможных 
способах использования ПО.

Отмечу, что приемочные тесты проводят, когда (1) продукт достиг необходимо уровня качества и (2) заказчик ПО ознакомлен 
с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).

Приемку проводит либо внутреннее тестирование (необязательно тестировщики) или внешнее тестирование (сам заказчик и
необязательно тестировщик).

Важно помнить, что E2E тесты автоматизируются сложнее, дольше, стоят дороже, сложнее поддерживаются и трудно выполняются
при регрессе. Значит таких тестов должно быть меньше.

[к оглавлению](#OOD)