## Web

[1. Что такое сервлет?](#1-Что-такое-сервлет)

[2. Какова структура веб-проекта?](#2-Какова-структура-веб-проекта)

[3. Что такое контейнер сервлетов?](#3-Что-такое-контейнер-сервлетов)

[4. Каковы задачи, функциональность контейнера сервлетов?](#4-Каковы-задачи-функциональность-контейнера-сервлетов)

[5. Что вы знаете о сервлет фильтрах?](#5-Что-вы-знаете-о-сервлетах-фильтрах)

[6. Зачем нужны слушатели в сервлетах?](#6-Зачем-нужны-слушатели-в-сервлетах)

[7. Когда вы будете использовать фильтры, а когда слушатели?](#7-Когда-вы-будете-использовать-фильтры-а-когда-слушатели)

[8. Как обработать исключения, выброшенные другим сервлетом в приложении?](#8-Как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)

[9. Что такое дескриптор развертывания?](#9-Что-такое-дескриптор-развертывания)

[10. Как реализовать запуск сервлета с запуском приложения?](#10-Как-реализовать-запуск-сервлета-с-запуском-приложения)

[11. Что представляет собой объект ServletConfig?](#11-Что-представляет-собой-объект-servletconfig)

[12. Что представляет собой объект ServletContext?](#12-Что-представляет-собой-объект-servletcontext)

[13. В чем отличия ServletContext и ServletConfig?](#13-В-чем-отличия-servletcontext-и-servletconfig)

[14. Что такое Request Dispatcher?](#14-Что-такое-request-dispatcher)

[15. Как можно создать блокировку (deadlock) в сервлете?](#15-Как-можно-создать-блокировку-deadlock-в-сервлете)

[16. Как получить адрес сервлета на сервере?](#16-Как-получить-адрес-сервлета-на-сервере)

[17. Как получить информацию о сервере из сервлета?](#17-Как-получить-информацию-о-сервере-из-сервлета)

[18. Как получить ip адрес клиента на сервере?](#18-Как-получить-ip-адрес-клиента-на-сервере)

[19. Что вы знаете о классах обертках (wrapper) для сервлетов?](#19-Что-вы-знаете-о-классах-обертках-wrapper-для-сервлетов)

[20. Каков жизненный цикл сервлета и когда какие методы вызываются?](#20-Каков-жизненный-цикл-сервлета-и-когда-какие-методы-вызываются)

[21. Какие методы необходимо определить при создании сервлетов?](#21-Какие-методы-необходимо-определить-при-создании-сервлетов)

[22. В каком случае вы будете переопределять метод service()?](#22-В-каком-случае-вы-будете-переопределять-метод-service)

[23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?](#23-Есть-ли-смысл-определить-конструктор-для-сервлета-как-лучше-инициализировать-данные)

[24. В чем отличия GenericServlet и HttpServlet?](#24-В-чем-отличия-genericservlet-и-httpservlet)

[25. Как вызвать из сервлета другой сервлет этого же и другого приложения?](#25-Как-вызвать-из-сервлета-другой-сервлет-этого-же-и-другого-приложения)

[26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?](#26-Что-вы-знаете-и-в-чем-отличия-методов-forward-и-sendredirect)

[27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?](#27-Стоит-ли-волноваться-о-многопоточной-безопасности-работая-с-сервлетами)

[28. В чем отличие между веб сервером и сервером приложений?](#28-В-чем-отличие-между-веб-сервером-и-сервером-приложений)

[29. Какой метод HTTP не является неизменяемым?](#29-Какой-метод-http-не-является-неизменяемым)

[30. Почему HttpServlet класс объявлен как абстрактный?](#30-Почему-httpservlet-класс-объявлен-как-абстрактный)

[31. В чем разница между методами GET и POST?](#31-В-чем-разница-между-методами-get-и-post)

[32. Что такое MIME-тип?](#32-Что-такое-mime-тип)

[33. Назовите преимущества Servlet над CGI?](#33-Назовите-преимущества-servlet-над-cgi)

[34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?](#34-Каковы-наиболее-распространенные-задачи-выполняются-в-servlet-контейнере)

[35. В чем разница между PrintWriter и ServletOutputStream?](#35-В-чем-разница-между-printwriter-и-servletoutputstream)

[36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?](#36-Можем-ли-мы-получить-printwriter-и-servletoutputstream-одновременно-в-сервлете)

[37. Расскажите о интерфейсе SingleThreadModel.](#37-Расскажите-о-интерфейсе-singlethreadmodel)

[38. Какие существуют атрибуты у сервлетов и какая сфера их применения?](#38-Какие-существуют-атрибуты-у-сервлетов-и-какая-сфера-их-применения)

[39. Почему необходимо переопределить только init() метод без аргументов?](#39-Почему-необходимо-переопределять-только-init-метод-без-аргументов)

[40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?](#40-Что-означает-url-encoding-Зачем-нужны-методы-javaneturlencoderencode-и-decode)

[41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?](#41-Зачем-нужны-и-чем-отличаются-методы-encodeurl-и-encoderedirecturl)

[42. Какие различные методы управления сессией в сервлетах вы знаете?](#42-Какие-различные-методы-управления-сессией-в-сервлетах-вы-знаете)

[43. Что означает URL Rewriting?](#43-Что-означает-url-rewriting)

[44. Как применяются Cookies в сервлетах?](#44-Как-применяются-cookies-в-сервлетах)

[45. Как уведомить объект в сессии, что сессия недействительна или закончилась?](#45-Как-уведомить-объект-в-сессии-что-сессия-недействительна-или-закончилась)

[46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?](#46-Какой-существует-эффективный-способ-удостовериться-что-все-сервлеты-доступны-только-для-пользователя-с-валидной-сессией)

[47. Как мы можем обеспечить transport layer security для нашего веб приложения?](#47-Как-мы-можем-обеспечить-transport-layer-security-для-нашего-веб-приложения)

[48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?](#48-Как-организовать-подключение-к-базе-данных-и-обеспечить-логирование-log4j-в-сервлете)

[49. Какие важные особенности существуют в Servlet 3?](#49-Какие-важные-особенности-существуют-в-servlet-3)

[50. Каковы различные способы аутентификации сервлета?](#50-Каковы-различные-способы-аутентификации-сервлета)

[51. Написать сервлет, реализующий загрузку файла на сервер.](#51-Написать-сервлет-реализующий-загрузку-файла-на-сервер)

## 1. Что такое сервлет?

**Сервлет** является интерфейсом, реализация которого расширяет функциональные возможности сервера. Сервлет 
взаимодействует с клиентами посредством принципа запрос-ответ. Хотя сервлеты могут обслуживать любые запросы, они обычно 
используются для расширения веб-серверов.

Большинство необходимых для создания сервлетов классов и интерфейсов содержатся в пакетах `javax.servlet` и 
`javax.servlet.http`.

Основные методы сервлета:

+ `public void init(ServletConfig config) throws ServletException` запускается сразу после загрузки сервлета в память;
+ `public ServletConfig getServletConfig()` возвращает ссылку на объект, который предоставляет доступ к информации о конфигурации сервлета;
+ `public String getServletInfo()` возвращает строку, содержащую информацию о сервлете, например: автор и версия сервлета;
+ `public void service(ServletRequest request, ServletResponse response) throws ServletException, java.io.IOException` вызывается для обработки каждого запроса;
+ `public void destroy()` выполняется перед выгрузкой сервлета из памяти.

Текущая спецификация - Servlet 3.1 описана в JSR-340 и принята в 2013 году.

[к оглавлению](#web)

## 2. Какова структура веб-проекта?

`src/main/java` Исходники приложения/библиотеки

`src/main/resources` Ресурсные файлы приложения/библиотеки

`src/main/filters` Файлы сервлетных фильтров

`src/main/webapp` Исходники веб-приложения

`src/test/java` Исходники тестов

`src/test/resources` Ресурсные файлы тестов

`src/test/filters` Тесты сервлетных фильтров

`src/it` Интеграционные тесты

`src/assembly` Описание сборки

`src/site` Сайт

`LICENSE.txt` Лицензия проекта

`NOTICE.txt` Замечания и определения библиотек зависимостей.

`README.txt` Описание проекта

[к оглавлению](#web)

## 3. Что такое контейнер сервлетов?

**Контейнер сервлетов** — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и 
обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. 

Наиболее известные реализации контейнеров сервлетов:

+ Apache Tomcat
+ Jetty
+ JBoss
+ WildFly
+ GlassFish
+ IBM WebSphere
+ Oracle Weblogic

[к оглавлению](#web)

## 4. Каковы задачи, функциональность контейнера сервлетов?

Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого 
веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений.

Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной 
среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

[к оглавлению](#web)

## 5. Что вы знаете о сервлет фильтрах?

**Сервлетный фильтр** - это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание 
HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. Сервлетный фильтр занимается предварительной 
обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут:

+ перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
+ определить содержание запроса прежде, чем сервлет будет инициирован;
+ модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
+ модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
+ перехватывать инициацию сервлета после обращения к сервлету.

Сервлетный фильтр может быть конфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. Основой 
для формирования фильтров служит интерфейс `javax.servlet.Filter`, который реализует три метода:

+ `void init(FilterConfig config) throws ServletException`;
+ `void destroy()`;
+ `void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException`;

Метод `init()` вызывается прежде, чем фильтр начинает работать, и настраивает конфигурационный объект фильтра. Метод 
`doFilter()` выполняет непосредственно работу фильтра. Таким образом, сервер вызывает `init()` один раз, чтобы запустить 
фильтр в работу, а затем вызывает `doFilter()` столько раз, сколько запросов будет сделано непосредственно к данному 
фильтру. После того, как фильтр заканчивает свою работу, вызывается метод `destroy()`.

Интерфейс `FilterConfig` содержит метод для получения имени фильтра, его параметров инициации и контекста активного в 
данный момент сервлета. С помощью своего метода `doFilter()` каждый фильтр получает текущий запрос `request` и ответ 
`response`, а также `FilterChain`, содержащий список фильтров, предназначенных для обработки. В `doFilter()` фильтр может 
делать с запросом и ответом всё, что ему захочется - собирать данные или упаковывать объекты для придания им нового 
поведения. Затем фильтр вызывает `chain.doFilter()`, чтобы передать управление следующему фильтру. После возвращения 
этого вызова фильтр может по окончании работы своего метода `doFilter()` выполнить дополнительную работу над полученным 
ответом. К примеру, сохранить регистрационную информацию об этом ответе.

После того, как класс-фильтр откомпилирован, его необходимо установить в контейнер и *«приписать»* (map) к одному или 
нескольким сервлетам. Объявление и подключение фильтра отмечается в дескрипторе развёртывания `web.xml` внутри элементов 
`<filter>` и `<filter-mapping>`. Для подключение фильтра к сервлету необходимо использовать вложенные элементы 
`<filter-name>` и `<servlet-name>`.

> Объявление класс-фильтра `FilterConnect` с именем `FilterName`:

```xml
  <filter>
        <filter-name>FilterName</filter-name>
        <filter-class>FilterConnect</filter-class>
        <init-param>
                <!--- фильтр имеет параметр инициализации `active`, которому присваивается значение `true`. -->
                <param-name>active</param-name>
                <param-value>true</param-true>
        </init-param>
  </filter>
```

> Подключение фильтра `FilterName` к сервлету `ServletName`:

```xml
  <filter-mapping>
        <filter-name>FilterName</filter-name>
        <servlet-name>ServletName</servlet-name>
  </filter-mapping>
```

Для связи фильтра со страницами HTML или группой сервлетов необходимо использовать тег `<url-pattern>`:

> Подключение фильтра FilterName ко всем вызовам .html страниц

```xml
  <filter-mapping>
          <filter-name>FilterName</filter-name>
          <url-pattern>*.html</url-pattern>
  </filter-mapping>
```

Порядок, в котором контейнер строит цепочку фильтров для запроса определяется следующими правилами:

+ цепочка, определяемая `<url-pattern>`, выстраивается в том порядке, в котором встречаются соответствующие описания фильтров в `web.xml`;
+ последовательность сервлетов, определенных с помощью `<servlet-name>`, также выполняется в той последовательности, в какой эти элементы встречаются в дескрипторе развёртывания `web.xml`.

[к оглавлению](#web)

## 6. Зачем нужны слушатели в сервлетах?

**Listener (слушатель)** работает как триггер, выполняя определённые действия при наступлении какого-либо события в 
жизненном цикле сервлета.

Слушатели, разделённые по области видимости (scope):

+ *Request*:
  + `ServletRequestListener` используется для того, чтобы поймать момент создания и уничтожения запроса;
  + `ServletRequestAttributeListener` используется для прослушивания событий, происходящих с атрибутами запроса.
+ *Context*:
  + `ServletContextListener` позволяет поймать момент, когда контекст инициализируется либо уничтожается;
  + `ServletContextAttributeListener` используется для прослушивания событий, происходящих с атрибутами в контексте.
+ *Session*:
  + `HttpSessionListener` позволяет поймать момент создания и уничтожения сессии;
  + `HttpSessionAttributeListener` используется при прослушивании событий происходящих с атрибутами в сессии;
  + `HttpSessionActivationListener` используется в случае, если происходит миграция сессии между различными JVM в распределённых приложениях;
  + `HttpSessionBindingListener` так же используется для прослушивания событий, происходящих с атрибутами в сессии. Разница между `HttpSessionAttributeListener` и `HttpSessionBindingListener` слушателями: первый декларируется в `web.xml`; экземпляр класса создается контейнером автоматически в единственном числе и применяется ко всем сессиям; второй: экземпляр класса должен быть создан и закреплён за определённой сессией «вручную», количество экземпляров также регулируется самостоятельно.

Подключение слушателей:
```xml
<web-app>
    ...
    <listener>
        <listener-class>xyz.company.ExampleListener</listener-class>
    </listener>
    ...
</web-app>
```

`HttpSessionBindingListener` подключается в качестве атрибута непосредственно в сессию, т.е., чтобы его подключить необходимо:

+ создать экземпляр класса, реализующего этот интерфейс;
+ положить созданный экземпляр в сессию при помощи `setAttribute(String, Object)`.

[к оглавлению](#web)

## 7. Когда вы будете использовать фильтры, а когда слушатели?

Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные (например: для аутентификации, 
преобразования формата, компрессии, шифрования и т.д.), в случае, когда необходимо реагировать на события - лучше 
применять слушателей.

[к оглавлению](#web)

## 8. Как обработать исключения, выброшенные другим сервлетом в приложении?

Когда приложение выбрасывет исключение контейнер сервлетов обрабатывает его и создаёт ответ в формате HTML. Это
аналогично тому, что происходит при кодах ошибок вроде 404, 403 и т.д.

В дополнении к этому существует возможность написания собственных сервлетов для обработки исключений и ошибок с 
указанием их в дескрипторе развертывания:

```xml
<error-page>
    <error-code>404</error-code>
    <location>/AppExceptionHandler</location>
</error-page>

<error-page>
    <exception-type>javax.servlet.ServletException</exception-type>
    <location>/AppExceptionHandler</location>
</error-page>
```

Основная задача таких сервлетов - обработать ошибку/исключение и сформировать понятный ответ пользователю. Например, 
предоставить ссылку на главную страницу или же описание ошибки.

[к оглавлению](#web)

## 9. Что такое дескриптор развертывания?

Дескриптор развертывания — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. В 
спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, модуль или 
приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.

Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, 
параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развертывания 
используется язык XML.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4">

    <display-name>Display name.</display-name>
    <description>Description text.</description>

    <servlet>
        <servlet-name>ExampleServlet</servlet-name>
        <servlet-class>xyz.company.ExampleServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
        <init-param>
            <param-name>configuration</param-name>
            <param-value>default</param-value>
        </init-param>       
    </servlet>

    <servlet-mapping>
        <servlet-name>ExampleServlet</servlet-name>
        <url-pattern>/example</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>ExampleJSP</servlet-name>
        <jsp-file>/sample/Example.jsp</jsp-file>
    </servlet>

    <context-param>
        <param-name>myParam</param-name>
        <param-value>the value</param-value>
    </context-param>
</web-app>
```

Для веб-приложений дескриптор развертывания должен называться `web.xml` и находиться в директории `WEB-INF`, в корне 
веб-приложения. Этот файл является стандартным дескриптором развертывания, определенным в спецификации. Также есть и 
другие типы дескрипторов, такие, как файл дескриптора развертывания `sun-web.xml`, содержащий специфичные для *Sun 
GlassFish Enterprise Server* данные для развертывания именно для этого сервера приложений или файл `application.xml` в 
директории `META-INF` для приложений *J2EE*.

[к оглавлению](#web)

## 10. Как реализовать запуск сервлета с запуском приложения?

Контейнер сервлетов обычно загружает сервлет по первому запросу клиента.

Если необходимо загрузить сервлет прямо на старте приложения (например если загрузка сервлета происходит длительное время)
следует использовать элемент `<load-on-startup>` в дескрипторе или аннотацию `@loadOnStartup` в коде сервлета,
что будет указывать на необходимость загрузки сервлета при запуске.

Значение должно быть целочисленное `int`. Если значение отрицательное, то сервлет будет загружен при запросе клиента.
В противном случае (0 и далее) - загрузится на старте приложения.
Чем число меньше, тем раньше в очереди на загрузку окажется сервлет.

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
```

[к оглавлению](#web)

## 11. Что представляет собой объект ServletConfig?

Интерфейс `javax.servlet.ServletConfig` используется для передачи сервлету конфигурационной информации.
Каждый сервлет имеет свой собственный экземпляр объекта `ServletConfig`, создаваемый контейнером сервлетов.

Для установки параметров конфигурации используются параметры `init-param` в `web.xml`:

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </init-param>
</servlet>
```

или аннотации `@WebInitParam`:

```java
@WebServlet(
    urlPatterns = "/example",
    initParams = {
        @WebInitParam(name = "exampleParameter", value = "parameterValue")
    }
)
public class ExampleServlet extends HttpServlet {
    //...
}
```

Для получения `ServletConfig` сервлета используется метод `getServletConfig()`.

[к оглавлению](#web)

## 12. Что представляет собой объект ServletContext?

Уникальный (в рамках веб-приложения) объект `ServletContext` реализует интерфейс `javax.servlet.ServletContext` и
предоставляет сервлетам доступ к параметрам этого веб-приложения. Для предоставления доступа используется элемент
`<context-param>` в `web.xml`:

```xml
<web-app>
    ...
    <context-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </context-param>
    ...
</web-app>
```

Объект `ServletContext` можно получить с помощью метода `getServletContext()` у интерфейса `ServletConfig`.
Контейнеры сервлетов так же могут предоставлять контекстные объекты, уникальные для группы сервлетов.
Каждая из групп будет связана со своим набором URL-путей хоста. В спецификации Servlet 3 `ServletContext` был расширен
и теперь предоставляет возможности программного добавления слушателей и фильтров в приложение.

Так же у этого интерфейса имеется множество полезных методов таких как `getServerInfo()`, `getMimeType()`,
`getResourceAsStream()` и т.д.

[к оглавлению](#web)

## 13. В чем отличия ServletContext и ServletConfig?

+ `ServletConfig` уникален для сервлета, а `ServletContext` - для приложения;
+ `ServletConfig` используется для предоставления параметров инициализации конкретному сервлету,
  а `ServletContext` для предоставления параметров инициализации для всех сервлетов приложения;
+ для `ServletConfig` возможности модифицировать атрибуты отсутствуют, атрибуты в объекте `ServletContext` можно изменять.

[к оглавлению](#web)

## 14. Что такое Request Dispatcher?

Интерфейс `RequestDispatcher` используется для передачи запроса другому ресурсу, при этом существует возможность
добавления данных полученных из этого ресурса к собственному ответу сервлета.
Так же этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте.

В интерфейса реализовано два метода:

+ `void forward(ServletRequest var1, ServletResponse var2)` — передает запрос из сервлета к другому
  ресурсу (сервлету, JSP или HTML файлу) на сервере.
+ `void include(ServletRequest var1, ServletResponse var2)` — включает контент ресурса (сервлет, JSP или HTML страница)
  в ответ.

Доступ к интерфейсу можно получить с помощью метода
интерфейса `ServletContext` - `RequestDispatcher getRequestDispatcher(String path)`,
где путь начинающийся с `/`, интерпретируется относительно текущего корневого пути контекста.

[к оглавлению](#web)

## 15. Как можно создать блокировку (deadlock) в сервлете?

Дедлок можно получить реализовав зацикленный вызов метода, например, вызвав метод `doPost()` в методе `doGet()`
и метод `doGet()` в методе `doPost()`.

[к оглавлению](#web)

## 16. Как получить адрес сервлета на сервере?

Реальный путь к расположению сервлета на сервере можно получить из объекта `ServletContext`:

`getServletContext().getRealPath(request.getServletPath())`.

[к оглавлению](#web)

## 17. Как получить информацию о сервере из сервлета?

Информацию о сервере можно получить из объекта `ServletContext` с помощью метода `getServerInfo()`:

`getServletContext().getServerInfo()`.

[к оглавлению](#web)

## 18. Как получить ip адрес клиента на сервере?

`request.getRemoteAddr()` используется для получения в сервлете IP адреса клиента на сервере.

[к оглавлению](#web)

## 19. Что вы знаете о классах обертках (wrapper) для сервлетов?

Собственные обработчики `ServletRequest` и `ServletResponse` можно реализовать добавив новые или переопределив
существующие методы у классов-обёрток `ServletRequestWrapper` (`HttpServletRequestWrapper`) и
`ServletResponseWrapper` (`HttpServletRequestWrapper`).

Данные классы-обертки помогают разработчикам реализовывать собственные реализации типов `request` и `response` сервлета.
Можно расширить эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов.
Эти классы не используются в стандартном программировании сервлетов.

[к оглавлению](#web)

## 20. Каков жизненный цикл сервлета и когда какие методы вызываются?

Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

+ **Загрузка класса сервлета** — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в
  память и вызов его конструктора без параметров.
+ **Инициализация класса сервлета** — после того как класс загружен контейнер инициализирует объект `ServletConfig` для этого
  сервлета и внедряет его через `init()` метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
+ **Обработка запросов** — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет
  контейнер порождает новый поток и вызывает метод `service()` путем передачи ссылки на объект ответы и запроса.
+ **Удаление из Service** - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов
  уничтожает классы сервлетов путем вызова `destroy()` метода.

Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения
(в отличии от объекта классов, которые уничтожаются сборщиком мусора после того как они уже не используются) и весь
жизненный цикл сервлета можно описать как последовательность вызова методов:

+ `public void init(ServletConfig config)` – используется контейнером для инициализации сервлета. Вызывается один раз за время жизни сервлета;
+ `public void service(ServletRequest request, ServletResponse response)` – вызывается для каждого запроса. Метод не может быть вызван раньше выполнения `init()` метода;
+ `public void destroy()` – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

[к оглавлению](#web)

## 21. Какие методы необходимо определить при создании сервлетов?

Чтобы создать сервлет, необходимо описать его в дескрипторе развёртывания:

>Пример 1

```xml
<servlet-mapping> 
  <servlet-name>MyOwnDefaultServlet</servlet-name>
  <url-pattern>/myservlet/*</url-pattern>
</servlet-mapping>
 
<servlet>
  <servlet-name>HelloWorld2</servlet-name> 
  <servlet-class>examples.servlets.HelloWorld2</servlet-class>
   <init-param>
    <param-name>greeting</param-name> 
    <param-value>Welcome</param-value> 
  </init-param>
   <init-param>
    <param-name>person</param-name> 
    <param-value>WebLogic Developer</param-value> 
  </init-param>
</servlet>
```

>Пример 2

```xml
<servlet-mapping>
    <servlet-name>ExampleServlet</servlet-name>
    <url-pattern>/example</url-pattern>
</servlet-mapping>

<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>config</param-name>
        <param-value>default</param-value>
    </init-param>       
</servlet>
```

Затем создать класс сервлета `examples.servlets.HelloWorld2` или для примера 2 `xyz.company.ExampleServlet`путём 
наследования от `HttpServlet` и реализовать логику его работы в методе `service()` или методах `doGet()`/`doPost()` 
(или первый или вторые).

[к оглавлению](#web)

## 22. В каком случае вы будете переопределять метод service()?

Метод `service()` переопределяется, когда необходимо, чтобы сервлет обрабатывал все запросы (и `GET`, и `POST`) в одном методе.

Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода `service()`,
который в зависимости от поступившего запроса вызывает или метод `doGet()` или метод `doPost()`.

[к оглавлению](#web)

## 23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?

Такая возможность есть, но считается бессмысленной.
Инициализировать данные лучше не в конструкторе, а переопределив метод `init()`,
в котором имеется возможность доступа к параметрам инициализации сервлета через использование объекта `ServletConfig`.

[к оглавлению](#web)

## 24. В чем отличия GenericServlet и HttpServlet?

Абстрактный класс `GenericServlet` — независимая от используемого протокола реализация интерфейса `Servlet`,
а абстрактный класс `HttpServlet` в свою очередь расширяет `GenericServlet` для протокола HTTP.

Следует отметить, что `HttpServlet extends GenericServlet`.

[к оглавлению](#web)

## 25. Как вызвать из сервлета другой сервлет этого же и другого приложения?

Для вызова сервлета из того же приложения необходимо использовать механизм внутренней коммуникации сервлетов
(_inter-servlet communication mechanisms_) через вызовы методов `RequestDispatcher` - `forward()` и `include()`
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете:

+ `forward()` - передаёт выполнение запроса в другой сервлет;
+ `include()` - предоставляет возможность включить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет принадлежащий другому приложению, то использовать `RequestDispatcher` уже не получится,
т.к. он определен только для текущего приложения. Для подобных целей необходимо использовать
метод `ServletResponse` - `sendRedirect()` которому предоставляется полный URL из другого сервлета.
Для передачи данных между сервлетами можно использовать `cookies`.
(т.е. можно использовать `cookies` как часть ответа сервлета, а потом использовать их в нашем сервлете)

[к оглавлению](#web)

## 26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?

+ `RequestDispatcher forward()` используется для проброски того же самого запроса к другому ресурсу,
  в то время как `ServletResponse sendRedirect()` это двухшаговый метод.
  Во втором методе веб приложение возвращает ответ клиенту с `status code 302 (redirect)` с ссылкой для отправки запроса.
  Запрос посылает полностью новый запрос.
+ `forward()` обрабатывается внутри контейнера, а `sendRedirect()` обрабатывается браузером.
+ Необходимо использовать `forward()` для организации доступа внутри одного и того же приложения,
  т.к. он быстрее `sendRedirect()`, которому требуется дополнительная сетевая работа.
+ В методе `forward()` браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним.
  В `sendRedirect()` методе URL адрес изменяется на пробрасываемый ресурс.
+ В методе `forward()` нельзя использовать для внедрения сервлета в другой контекст.
  Для этого можно использовать только `sendRedirect()`.

| __`forward()`__ | __`sendRedirect()`__ |
| --- | --- |
| Выполняется на стороне сервера | Выполняется на стороне клиента |
| Запрос перенаправляется на другой ресурс в пределах того же сервера | Клиенту возвращается ответ `302 (redirect)` и запрос перенаправляется на другой сервер |
| Не зависит от протокола клиентского запроса клиента, так как обеспечивается контейнером сервлетов | Может использоваться только с клиентами HTTP |
| Нельзя применять для внедрения сервлета в другой контекст | Разрешается применять для внедрения сервлета в другой контекст |
| Клиент не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним | URL адрес изменяется на адрес нового ресурса |
| Выполняется быстрее метода `sendRedirect()` | Медленнее `forward()` т.к. требует создания нового запроса |
| Определён в интерфейсе `RequestDispatcher` | Определён в интерфейсе `HttpServletResponse` |

[к оглавлению](#web)

## 27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?

Методы `init()` и `destroy()` вызываются один раз за жизненный цикл сервлета — поэтому по поводу них беспокоиться не стоит.

Методы `doGet()`, `doPost()`, `service()` вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность,
то здесь задумываться о потокобезопасной работе обязательно.

При этом правила использования многопоточности остаются теми же:
+ локальные переменные этих методов будут созданы отдельно для каждой нити.
+ при использовании глобальных разделяемых ресурсов необходимо использовать синхронизацию или другие приёмы
  многопоточного программирования.

[к оглавлению](#web)

## 28. В чем отличие между веб сервером и сервером приложений?

**Веб сервер** необходим для обработки `HTTP request` от браузера клиента и ответа клиенту с помощью `HTTP response`.
Веб сервер понимает язык HTTP и запускается по HTTP протоколу.

Примером веб сервера может служить реализация от Apache - Tomcat.

**Сервер приложений** — это веб сервер с дополнительными возможностями,
которые помогают разрабатывать корпоративные приложения.

Например, поддержка JavaBeans, JMS Messaging, Transaction Management и др.

[к оглавлению](#web)

## 29. Какой метод HTTP не является неизменяемым?

+ HTTP метод называется неизменяемым, если он на один и тот же запрос всегда возвращает одинаковый результат.
  HTTP методы `GET`, `PUT`, `DELETE`, `HEAD` и `OPTIONS` являются неизменяемыми, поэтому необходимо реализовывать
  приложение так, чтобы эти методы возвращали одинаковый результат постоянно.

  Эти методы должны быть идемпотентными («idempotence») в том смысле, что повторное (более одного раза) выполнение
  запросов с помощью этих методов будет иметь тот же эффект, что и однократное выполнение.

+ К изменяемым методам относится метод `POST`, который и используется для реализации чего-либо, что изменяется при каждом запросе.

К примеру, для доступа к статической HTML странице используется метод `GET`, т.к. он всегда возвращает одинаковый результат.
При необходимости сохранять какую-либо информацию, например в базе данных, нужно использовать `POST` метод.
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся
запросах от клиента для этих методов.

[к оглавлению](#web)

## 30. Почему HttpServlet класс объявлен как абстрактный?

Класс `HTTPServlet` объявлен как абстрактный, т.к. он предоставляет лишь общую реализацию сервлета для HTTP протокола.
Реализация ключевых методов `doGet()` и `doPost()`, содержащих основную бизнес-логику перекладывается на разработчика
и по умолчанию возвращает `HTTP 405 Method Not Implemented error`.

[к оглавлению](#web)

## 31. В чем разница между методами GET и POST?

+ `GET` передает данные серверу используя URL, тогда как `POST` передает данные, используя тело HTTP запроса.
  Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных,
  которые можно отослать через `GET`. `POST` может отправлять гораздо большие объемы данных.
  Лимит устанавливается `web-server` и составляет обычно около 2 Mb.
+ Данные `GET` метода передаются в открытом виде, `POST` данные передаются в теле запроса и скрыты от пользователя.
  Поэтому передача данных методом `POST` более безопасна, чем методом `GET`, т.к. секретные данные (например пароль)
  не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда.
  Иногда это преимущество становится недостатоком - вы не сможете послать данные за кого-то другого.
+ `GET`метод является неизменяемым, тогда как `POST` — изменяемый.
+ `GET` метод является HTTP методом по умолчанию, а `POST` метод необходимо указывать явно, чтобы отправить запрос.
+ `GET` метод используется гиперссылками на странице.

[к оглавлению](#web)

## 32. Что такое MIME-тип?

**MIME** (англ. Multipurpose Internet Mail Extensions — многоцелевые расширения интернет-почты) - это стандарт,
описывающий передачу различных типов данных по электронной почте, а также, в общем случае,
спецификация для кодирования информации и форматирования сообщений таким образом, чтобы их можно было пересылать по Интернету.

`Content-Type response header` это и есть MIME тип.

Сервер посылает MIME тип клиенту для того, чтобы он понял какой тип данных пересылается.
Это помогает верно отобразить полученные данные на клиенте.

Наиболее часто используемые MIME типы: text/html, text/xml, application/xml и многие др.
В `ServletContext` существует метод `getMimeType()` для получения корректного MIME типа файла
и дальнейшего использования этой информации для указания типа контента в ответе.

[к оглавлению](#web)

## 33. Назовите преимущества Servlet над CGI?

Технология сервлетов была создана для преодоления недостатков Common Gateway Interface (общий интерфейс шлюза).
Можно выделить следующие преимущества сервлетов над CGI:

+ **Быстродействие.** Сервлеты предоставляют лучшую производительность в условиях обработки запросов,
  лучшее использование памяти за счет использования преимущества многопоточности
  (на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).
+ **Переносимость на различные платформы.** Сервлеты, платформа и система являются независимыми.
  Т.е. веб приложение написанное с использованием сервлетов может быть запущено в любом контейнере сервлетов,
  реализующим стандарт и в любой операционной системе.
+ **Надежность.** Использование сервлетов повышает надежность программы,
  т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти),
  безопасности и сборщике мусора.
+ Сервлеты относительно легки в изучении и поддержке, поэтому разработчику необходимо заботиться только о бизнес логике приложения,
  а не внутренней реализации веб технологий.

[к оглавлению](#web)

## 34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?

+ **Поддержка обмена данными**. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом.
  Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента,
  а так же разбирать запрос и генерировать ответ.
  Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.
+ **Управление жизненным циклом сервлетов и ресурсов**. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета.
  Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.
+ **Поддержка многопоточности**. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки.
  Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.
+ **Поддержка JSP**. JSP классы не похожи на стандартные классы джавы, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.
+ **Различные задачи**. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.

[к оглавлению](#web)

## 35. В чем разница между PrintWriter и ServletOutputStream?

`PrintWriter` — это класс для работы с символьным потоком, а `ServletOutputStream` — класс для работы байтовым потоком.

`PrintWriter` используется для записи информации на основе символов, вроде массива символов или строки в ответ,
в то время как `ServletOutputStream` используется для записи в ответ массива байтов.

Для получения экземпляра `ServletOutputStream` используется метод `ServletResponse` `getOutputStream()`,
а для `PrintWriter` — метод `ServletResponse` `getWriter()`.

[к оглавлению](#web)

## 36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?

Мы не можем создать объекты этих классов в одном сервлете.
При попытке одновременного вызова `getWriter()` и `getOutputStream()` будет выброшено
исключение `java.lang.IllegalStateException` с сообщением, что уже был вызван другой метод.

[к оглавлению](#web)

## 37. Расскажите о интерфейсе SingleThreadModel.

Интерфейс `SingleThreadModel` является маркерным - в нем не объявлен ни один метод, однако, если сервлет реализует
этот интерфейс, то метод `service()` этого сервлета гарантированно не будет одновременно выполняться в двух потоках.
Контейнер сервлетов либо синхронизирует обращения к единственному экземпляру, либо обеспечивает поддержку пула
экземпляров и перенаправление запроса свободному сервлету.
Другими словами, контейнер гарантирует отсутствие конфликтов при одновременном обращении к переменным или методам
экземпляра сервлета.

Однако интерфейс `SingleThreadModel` не решает всех проблем потокобезопасности.
Т.к. существуют также и другие разделяемые ресурсы (например, атрибуты сессии или статические переменные),
которые даже при использовании этого интерфейса, остаются всё так же доступны обработчикам запросов в других потоках.

Т.е. пользы от использования этого интерфейса немного и в спецификации Servlet 2.4 он был объявлен `deprecated`.

[к оглавлению](#web)

## 38. Какие существуют атрибуты у сервлетов и какая сфера их применения?

Атрибуты сервлетов используются для внутренней коммуникации сервлетов.

В веб-приложении существует возможность работы с атрибутами используя методы `setAttribute()`, `getAttribute()`,
`removeAttribute()`, `getAttributeNames()`, которые предоставлены интерфейсами `ServletRequest`, `HttpSession` и
`ServletContext` (для областей видимости _request scope_, _session scope_, _context scope_ соответственно).

[к оглавлению](#web)

## 39. Почему необходимо переопределить только init() метод без аргументов?

Метод `init()` переопределяется, если необходимо инициализировать какие-то данные до того как сервлет начнет
обрабатывать запросы.

При переопределении метода `init(ServletConfig config)`, первым должен быть вызван метод `super(config)`, который
обеспечит вызов метода `init(ServletConfig config)` суперкласса.

`GenericServlet` предоставляет другой метод `init()` без параметров, который будет вызываться в конце метода `init(ServletConfig config)`.

Необходимо использовать переопределенный метод `init()` без параметров для инициализации данных во избежание
каких-либо проблем, например ошибки, когда вызов `super()` не указан в переопределенном `init(ServletConfig config)`.

[к оглавлению](#web)

## 40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?

__URL Encoding__ — процесс преобразования данных в форму CGI (Common Gateway Interface), не содержащую пробелов и
нестандартных символов, которые заменяются в процессе кодирования на специальные escape-символы.

В Java для кодирования строки используется метод `java.net.URLEncoder.encode(String str, String unicode)`.
Обратная операция декодирования возможна через использование метода `java.net.URLDecoder.decode(String str, String unicode)`.

Примеры работы метода:

> `Hello мир!` преобразовывается в `Hello%20%D0%BC%D0%B8%D1%80!`

> `Java for study .ru` преобразовается в `Java%20for%20study%20.ru`

[к оглавлению](#web)

## 41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?

`HttpServletResponse.encodeURL()` предоставляет способ преобразования URL в HTML гиперссылку с преобразованием
спецсимволов и пробелов, а так же добавления _session id_ к URL.
Такое поведение аналогично `java.net.URLEncoder.encode()`, но с добавлением дополнительного параметра `jsessionid` в конец URL.

Метод `HttpServletResponse.encodeRedirectURL()` преобразует URL для последующего использования в методе `sendRedirect()`.

Таким образом для HTML гиперссылок при _URL rewriting_ необходимо использовать `encodeURL()`,
а для URL при перенаправлении - `encodeRedirectUrl()`.

[к оглавлению](#web)

## 42. Какие различные методы управления сессией в сервлетах вы знаете?

__Сессия__ - это сеанс связи между клиентом и сервером, устанавливаемый на определенное время.
Сеанс устанавливается непосредственно между клиентом и веб-сервером в момент получения первого запроса к веб-приложению.
Каждый клиент устанавливает с сервером свой собственный сеанс, который сохраняется до окончания работы с приложением.

Сессии используются для обеспечения хранения данных во время нескольких запросов Web-страницы или на обработку информации,
введенной в пользовательскую форму в результате нескольких HTTP-соединений (например, клиент совершает несколько покупок
в интернет-магазине; студент отвечает на несколько тестов в системе дистанционного обучения).

Сессия может содержать в себе множество запросов и ответов клиент-сервер.
Т.к. HTTP и веб сервер не запоминают состояния (stateless), то единственным способом поддерживать
сессию является пересылка уникальной информации (session id) в каждом запросе и ответе между клиентом и сервером.

Существует несколько способов управления сессией (обеспечения ее уникального идентификатора) в сервлетах:

+ __User Authentication__ – Предоставление учетных данных самим пользователем в момент аутентификации.
  Переданная таким образом информация в дальнейшем используется для поддержания сеанса.
  Это метод не будет работать, если пользователь вошёл в систему одновременно из нескольких мест.
+ __HTML Hidden Field__ – Присвоение уникального значения скрытому полю HTML страницы,
  в момент когда пользователь начинает сеанс. Этот метод не может быть использован со ссылками, потому что нуждается в
  подтверждении формы со скрытым полем каждый раз во время формирования запроса.
  Кроме того, это не безопасно, т.к. существует возможность простой подмены такого идентификатора.
+ __URL Rewriting__ – Добавление идентификатора сеанса как параметра URL. Достаточно утомительная операция,
  потому что требует постоянного отслеживания этого идентификатора при каждом запросе или ответе.
+ __Cookies__ – Использование небольших фрагментов данных, отправленных web-сервером и хранимых на устройстве пользователя.
  Данный метод не будет работать, если клиент отключает использование cookies.
+ __Session Management API__ – Использование специального API для отслеживания сеанса, построенный на основе
  и на методах описанных выше и который решает частные проблемы перечисленных способов:
  + Чаще всего недостаточно просто отслеживать сессию, необходимо ещё и сохранять какие-либо дополнительные данные о ней,
    которые могут потребоваться при обработке последующих запросов. Осуществление такого поведения требует много дополнительных усилий.
  + Все вышеперечисленные методы не являются универсальными: для каждого из них можно подобрать конкретный сценарий,
    при котором они не будут работать.

[к оглавлению](#web)

## 43. Что означает URL Rewriting?

Для управления сессией в сервлетах мы можем использовать `HTTPSession`, но он работает с _cookies_, а их иногда отключают.
Для этого случая в сервлетах предусмотрена возможность `URL Rewriting`.

__URL Rewriting__ - специальная перезапись (перекодирование) оригинального URL.  
Данный механизм может использоваться для управления сессией в сервлетах, когда _cookies_ отключены, т.е.
этот метод является как бы запасным.

Применяя метод `HttpServletResponse` `encodeURL()` мы можем закодировать URL. Если необходим редирект к другому ресурсу,
то для предоставления информации о сессии применяется метод `encodeRedirectURL()`.

[к оглавлению](#web)

## 44. Как применяются Cookies в сервлетах?

__Сookies («куки»)__ — небольшой фрагмент данных, отправленный web-сервером и хранимый на устройстве пользователя.
Всякий раз при попытке открыть страницу сайта, web-клиент пересылает соответствующие этому сайту cookies web-серверу
в составе HTTP-запроса.

Применяется для сохранения данных на стороне пользователя и на практике обычно используется для:
+ аутентификации пользователя;
+ хранения персональных предпочтений и настроек пользователя;
+ отслеживания состояния сеанса доступа пользователя;
+ ведения разнообразной статистики.

Cookies (куки) используются в клиент-серверном взаимодействии и они не являются чем-то конкретным к Java.
Servlet API предоставляет поддержку cookies через класс `javax.servlet.http.Cookie` `implements Serializable, Cloneable`:

+ Для получения массива cookies из запроса необходимо воспользоваться методом `HttpServletRequest.getCookies()`.
  Методов для добавления cookies в запрос `HttpServletRequest` не предусмотрено.
+ Для добавления cookie в ответ используется `HttpServletResponse.addCookie(Cookie c)`.
  Метода получения cookies в `HttpServletResponse` отсутствует.

[к оглавлению](#web)

## 45. Как уведомить объект в сессии, что сессия недействительна или закончилась?

Чтобы быть уверенным в том, что объект будет оповещён о прекращении сессии, нужно реализовать интерфейс
`javax.servlet.http.HttpSessionBindingListener`.

Два метода этого интерфейса: `valueBound()` и `valueUnbound()` используются для реализации логики при добавлении
объекта в качестве атрибута к сессии и при уничтожении сессии соответственно.

[к оглавлению](#web)

## 46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?

Сервлет фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом.
Поэтому логично использовать соответствующий фильтр для проверки необходимой информации (например валидности сессии) в запросе.

[к оглавлению](#web)

## 47. Как мы можем обеспечить transport layer security для нашего веб приложения?

Для обеспечения _transport layer security_ необходимо настроить поддержку SSL для вашего сервлет контейнера.
Как это сделать описано в мануалах для конкретной реализации сервлет-контейнера.

SSL (англ. Secure Sockets Layer — уровень защищённых сокетов) — семейство криптографических протоколов для установки
шифрованного соединения между двумя сторонами, желающими обмениваться данными.

[к оглавлению](#web)

## 48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?

При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в _servlet context listener_,
а также установить в качестве атрибута контекста для возможности использования другими сервлетами.

Логирование Log4j подключается к сервлету с помощью _property_-файла или XML-конфигурации,
а далее эта информация используется при конфигурировании соответствующего _context listener_.

[к оглавлению](#web)

## 49. Какие важные особенности существуют в Servlet 3?

+ __Servlet Annotations__. До Servlet 3 весь маппинг (конфигурация) содержался в `web.xml`, что приводило к ошибкам и неудобству
  при работе с большим количестве сервлетов. Примеры аннотаций: `@WebServlet`, `@WebInitParam`, `@WebFilter`, `@WebListener`.
+ __Web Fragments__. Одностраничное веб приложение может содержать множество модулей: все модули прописываются
  в `fragment.xml` в папке `META-INF\`. Это позволяет разделять веб приложение на отдельные модули,
  собранные как JAR-файлы в отдельной `lib\` директории.
+ __Динамическое добавление веб компонентов__. Появилась возможность программно добавлять фильтры и слушатели,
  используя `ServletContext` объект. Для этого применяются методы `addServlet()`, `addFilter()`, `addListener()`.
  Это помогает построить динамическую систему, в которой необходимый объект будет вызван только по необходимости.
+ __Асинхронное выполнение__. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток
  без удержания всего сервера занятым.

[к оглавлению](#web)

## 50. Каковы различные способы аутентификации сервлета?

Спецификация сервлетов определяет четыре типа аутентификации (проверки подлинности):

+ __HTTP Basic Authentication__ - `BASIC`. При доступе к закрытым ресурсам появится окно, которое попросит ввести
  данные для аутентификации.
+ __Form Based Login__ - `FORM`. Используется собственная html форма:
+ __HTTP Digest Authentication__ - `DIGEST`. Цифровая аутентификация с шифрованием.
+ __HTTPS Authentication__ - `CLIENT-CERT`. Аутентификация с помощью клиентского сертификата.

```xml
<login-config>
    <auth-method>FORM</auth-method>
    <form-login-config>
        <form-login-page>/login.html</form-login-page>
        <form-error-page>/error.html</form-error-page>
    </form-login-config>
</login-config>
```

[к оглавлению](#web)

## 51. Написать сервлет, реализующий загрузку файла на сервер.

В html есть форма загрузки файла.
```html
<input type="file" name="file">
```

В браузере она отобразится, как кнопка с выбором файла.

На клиентской стороне примерный код:
```html
<form action="<с:url value='/upload'/>" method="post" enctype="multipart/form-data">
    <div class="checkbox">
        <input type="file" name="file">
    </div>
    <button type="submit" class="btn btn-default">Submit</button>
</form>
```

Теперь нужно реализовать UploadServlet.

**web.xml**
```xml
<servlet>
    <servlet-name>UploadServlet</servlet-name>
    <servlet-class>ru.job4j.servlets.UploadServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>UploadServlet</servlet-name>
    <url-pattern>/upload</url-pattern>
</servlet-mapping>
```

Обработка файла на стороне сервера будет происходить через библиотеку apache-upload.
```xml
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>
```

Этот servlet будет обрабатывать загрузку файла на сервер.

```java
package ru.job4j.servlets;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class UploadServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        DiskFileItemFactory factory = new DiskFileItemFactory();
        ServletContext servletContext = this.getServletConfig().getServletContext();
        File repository = (File) servletContext.getAttribute("javax.servlet.context.tempdir");
        factory.setRepository(repository);
        ServletFileUpload upload = new ServletFileUpload(factory);
        try {
            List<FileItem> items = upload.parseRequest(req);
            File folder = new File("c:\\images\\");
            if (!folder.exists()) {
                folder.mkdir();
            }
            for (FileItem item : items) {
                if (!item.isFormField()) {
                    File file = new File(folder + File.separator + item.getName());
                    try (FileOutputStream out = new FileOutputStream(file)) {
                        out.write(item.getInputStream().readAllBytes());
                    }
                }
            }
        } catch (FileUploadException e) {
            e.printStackTrace();
        }
        doGet(req, resp);
    }
}
```

Метод doPost загружает выбранный файл на сервер в папку c:\\images\\

Порядок загрузки файла на сервер:

1. Вначале мы создаем фабрику по которой можем понять, какие данные есть в запросы. Данные могу быть: поля или файлы.
2. Получаем список всех данных в запросе.
```java
List<FileItem> items = upload.parseRequest(req);
```
3. Если элемент не поле, то это файл и из него можно прочитать весь входной поток и записать его в файл или напрямую в базу данных.
```java
File file = new File(folder + File.separator + item.getName());
try (FileOutputStream out = new FileOutputStream(file)) {
    out.write(item.getInputStream().readAllBytes());
}
```
4. После этого мы переходим в метод doGet, где отдаем список всех файлов. В этом списке содержатся только имена.
```java
for (File name : new File("c:\\images\\").listFiles()) {
    images.add(name.getName());
}
req.setAttribute("images", images);
```

[к оглавлению](#web)