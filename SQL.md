## SQL

[1. Что такое «база данных»?](#1-Что-такое-база-данных)

[2. Что такое «система управления базами данных»?](#2-Что-такое-система-управления-базами-данных)

[3. Что такое «реляционная модель данных»?](#3-Что-такое-реляционная-модель-данных)

[4. Что такое нереляционная БД?](#4-Что-такое-нереляционная-БД)

[5. Что такое SQL?](#5-Что-такое-sql)

[6. Что такое DDL, DML, DCL и TCL?](#6-Что-такое-ddl-dml-dcl-и-tcl)

[7. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[8. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[9. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[10. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).](#6-Опишите-как-вставить-удалить-обновить-данные-в-таблицу)

[11. Что такое нормализация БД?](#11-Что-такое-нормализация-БД)

[12. Что такое денормализация БД? Для чего она нужна?](#12-Что-такое-денормализация-БД-Для-чего-она-нужна)

[13. Что такое «индексы»? Для чего их используют? В чём заключаются их преимущества и недостатки?](#13-Что-такое-индексы-Для-чего-их-используют-В-чём-заключаются-их-преимущества-и-недостатки)

[14. Что такое кластерный и некластерный индексы?](#14-Что-такое-кластерный-и-некластерный-индексы)

[15. Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?](#15-Имеет-ли-смысл-индексировать-данные-имеющие-небольшое-количество-возможных-значений)

[16. Когда полное сканирование набора данных выгоднее доступа по индексу?](#16-Когда-полное-сканирование-набора-данных-выгоднее-доступа-по-индексу)

[17. Какие типы соединений (join) таблиц существуют? В чем их разница?](#17-Какие-типы-соединений-join-таблиц-существуют-В-чем-их-разница)

[18. Что такое SQL курсор?](#18-Что-такое-sql-курсор)

[19. Опишите шаги по созданию и использованию курсора.](#19-Опишите-шаги-по-созданию-и-использованию-курсора)

[20. Что такое транзакция?](#20-Что-такое-транзакция)

[21. Назовите основные свойства транзакции.](#21-Назовите-основные-свойства-транзакции)

[22. Какие существуют уровни изолированности транзакций?](#22-Какие-существуют-уровни-изолированности-транзакций)

[23. Какие проблемы могут возникать при параллельном доступе с использованием транзакций?](#23-Какие-проблемы-могут-возникать-при-параллельном-доступе-с-использованием-транзакций)

[24. Что такое триггер? Какие типы триггеров Вы знаете?](#24-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[25. В чем разница между where и having?](#25-В-чем-разница-между-where-и-having)

[26. Что такое подзапрос (sub-query)?](#26-Что-такое-подзапрос-sub-query)

[27. Что такое union?](#27-Что-такое-union)

[28. Что такое group by?](#28-Что-такое-group-by)

[29. Что такое хранимые процедуры?](#29-Что-такое-хранимые-процедуры)

[30. Что такое view(Представление)?](#30-Что-такое-view)

[31. Основные элементы баз данных таблицы процедуры функции констрейнты и тд?](#31-Основные-элементы-баз-данных-таблицы-процедуры-функции-констрейнты-и-тд)

[32. Как вы понимаете null в базах данных?](#32-Как-вы-понимаете-null-в-базах-данных)

[33. Агрегатные функции как они работают с null Не забудьте о group by и having?](#33-Агрегатные-функции-как-они-работают-с-null-Не-забудьте-о-group-by-и-having)

[34 Каким образом лучше добавлять большое количество записей в таблицу?](#34-Каким-образом-лучше-добавлять-большое-количество-записей-в-таблицу)

[35. Что такое первая нормальная форма и процесс нормализации Какие бывают нормальные формы?](#35-Что-такое-первая-нормальная-форма-и-процесс-нормализации-Какие-бывают-нормальные-формы)

[36. В чем смысл индекса СУБД как они устроены как хранятся Как бы вы реализовали тот же функционал?](#36-В-чем-смысл-индекса-СУБД-как-они-устроены-как-хранятся-Как-бы-вы-реализовали-тот-же-функционал)

[37. Что такое JDBC?](#37-Что-такое-jdbc)

[38. Что нужно для работы с той или иной БД?](#38-Что-нужно-для-работы-с-той-или-иной-БД)

[39. Как зарегистрировать драйвер?](#39-Как-зарегестрировать-драйвер)

[40. Как получить Connection?](#40-Как-получить-connection)

[41. Что такое Statement, PrepareStatement? В чем разница между ними?](#41-Что-такое-statement-preparestatement-В-чем-разница-между-ними)

[42. Что такое ResultSet?](#42-Что-такое-resultset)

[43. В чем разница между методами execute, executeUpdate, executeQueury?](#43-В-чем-разница-между-методами-execute-executeupdate-executequeury)

[44. Можно ли использовать возвращаемое значение execute() для проверки, что что-то обновилось?](#44-Можно-ли-использовать-возвращаемое-значение-execute-для-проверки-что-что-то-обновилось)

[45. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?](#45-Как-получить-при-вставке-сгенерированные-ключи-Как-это-сделать-на-чистом-sql)

[46. Как установить NULL значения в JDBC PreparedStatement?](#46-Как-установить-null-значения-в-jdbc-preparedstatement)

[47. Как используются методы setFetchSize и SetMaxRows в Statement?](#47-Как-используются-методы-setfetchsize-и-setmaxrows-в-statement)

[48. Как вызвать Stored Procedures используя JDBC API?](#48-Как-вызвать-stored-procedures-используя-jdbc-api)

[49. Что такое JDBC Batch Processing и каковы его преимущества?](#49-Что-такое-jdbc-batch-processing-и-каковы-его-преимущества)

[50. Что такое JDBC Transaction Management и зачем он нужен?](#50-Что-такое-jdbc-transaction-management-и-зачем-он-нужен)

[51. Как откатить JDBC транзакцию?](#51-Как-откатить-jdbc-транзакцию)

[52. Что такое JDBC Savepoint и как он используется?](#52-Что-такое-jdbc-savepoint-и-как-он-используется)

[53. Расскажите о JDBC DataSource Какие преимущества он дает?](#53-Расскажите-о-jdbc-datasource-Какие-преимущества-он-дает)

[54. Расскажите про Apache DBCP API?](#54-Расскажите-про-apache-dbcp-api)

[55. Какие вы знаете уровни изоляции соединений в JDBC?](#55-Какие-вы-знаете-уровни-изоляции-соединений-в-jdbc)

[56. Что вы знаете о JDBC RowSet Какие существуют различные типы RowSet?](#56-Что-вы-знаете-о-jdbc-rowset-Какие-существуют-различные-типы-rowset)

[57. В чем разница между ResultSet и RowSet?](#57-В-чем-разница-между-resultset-и-rowset)

[58. Приведите пример наиболее распространенных исключений в JDBC?](#58-Приведите-пример-наиболее-распространенных-исключений-в-jdbc)

[59. Расскажите о типах данных CLOB и BLOB в JDBC?](#59-Расскажите-о-типах-данных-clob-и-blob-в-jdbc)

[60. Что вы знаете о грязном чтении dirty read в JDBC Какой уровень изоляции предотвращает этот тип чтения?](#60-Что-вы-знаете-о-грязном-чтении-dirty-read-в-jdbc-Какой-уровень-изоляции-предотвращает-этот-тип-чтения)

[61. Какие есть две фазы commit?](#61-Какие-есть-две-фазы-commit)

[62. Приведите пример различных типов блокировки в JDBC?](#62-Приведите-пример-различных-типов-блокировки-в-jdbc)

[63. Как вставить изображение или необработанные данные в базу данных?](#63-Как-вставить-изображение-или-необработанные-данные-в-базу-данных)

[64. Что вы можете рассказать о фантомном чтении Какой уровень изоляции его предотвращает?](#64-Что-вы-можете-рассказать-о-фантомном-чтении-Какой-уровень-изоляции-его-предотвращает)

[65. Что такое SQL Warning Как возвратить SQL предупреждения в JDBC программе?](#65-Что-такое-sql-warning-Как-возвратить-sql-предупреждения-в-jdbc-программе)

[66. Как запустить Oracle Stored Procedure с объектами базы данных INOUT?](#66-Как-запустить-oracle-stored-procedure-с-объектами-базы-данных-inout)

[67. Приведите пример возникновения javasqlSQLException No suitable driver found?](#67-Приведите-пример-возникновения-javasqlsqlexception-no-suitable-driver-found)

[68. Некоторые Best Practices в JDBC?](#68-Некоторые-best-practices-в-jdbc)

[69. Для чего используется конструкция try-with-resources?](#69-Для-чего-используется-конструкция-try-with-resources)

## 1. Что такое «база данных»?

**База данных** — организованный и адаптированный для обработки вычислительной системой набор информации.

[к оглавлению](#SQL)

## 2. Что такое «система управления базами данных»?

Система управления базами данных (сокращенно **СУБД**) - это программное обеспечение для создания и работы с базами 
данных.

**Главная функция СУБД** - это управление данными (которые могут быть как во внешней, так и в оперативной памяти). СУБД
обязательно поддерживает языки баз данных, а также отвечает за копирование и восстановление информации после каких-либо
сбоев.

[к оглавлению](#SQL)

## 3. Что такое «реляционная модель данных»?

**Реляционная модель данных** — это логическая модель данных и прикладная теория построения реляционных баз данных.

Реляционная модель данных включает в себя следующие компоненты:

+ *Структурный аспект* — данные представляют собой набор отношений.
+ *Аспект целостности* — отношения отвечают определенным условиям целостности: уровня домена (типа данных), уровня 
  отношения и уровня базы данных.
+ *Аспект обработки (манипулирования)* — поддержка операторов манипулирования отношениями (реляционная алгебра, 
  реляционное исчисление).
+ *Нормальная форма* - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности и 
  определённое как совокупность требований, которым должно удовлетворять отношение.

[к оглавлению](#SQL)

## 4. Что такое нереляционная БД?

Базы данных `NoSQL` специально созданы для определенных моделей данных и обладают гибкими схемами, что позволяет 
разрабатывать современные приложения. База данных `NoSQL` получили широкое распространение в связи с простотой 
разработки, функциональностью и производительностью при любых масштабах.

Основные свойства нереляционной БД:

+ **Гибкость.** Как правило, базы данных NoSQL предлагают гибкие схемы, что позволяет осуществлять разработку быстрее и 
  обеспечивает возможность поэтапной реализации. Благодаря использованию гибких моделей данных БД NoSQL хорошо подходят 
  для частично структурированных и неструктурированных данных.
  
+ **Масштабируемость.** Базы данных NoSQL рассчитаны на масштабирование с использованием распределенных кластеров 
  аппаратного обеспечения, а не путем добавления дорогих надежных серверов. Некоторые поставщики облачных услуг проводят
  эти операции в фоновом режиме, обеспечивая полностью управляемый сервис.
  
+ **Высокая производительность.** Базы данных NoSQL оптимизированы для конкретных моделей данных и шаблонов доступа, что
  позволяет достичь более высокой производительности по сравнению с реляционными базами данных.
  
+ **Широкие функциональные возможности.** Базы данных NoSQL предоставляют API и типы данных с широкой функциональностью,
  которые специально разработаны для соответствующих моделей данных.

## 5. Что такое SQL?

**Structured Query Language (SQL)** - язык структурированных запросов, с помощью него пишутся специальные запросы (SQL
инструкции) к базе данных с целью получения этих данных из базы и для манипулирования этими данными.

С точки зрения реализации язык SQL представляет собой набор операторов, которые делятся на определенные группы и у 
каждой группы есть свое назначение. В сокращенном виде эти группы называются DDL, DML, DCL И TCL.

[к оглавлению](#SQL)

## 6. Что такое DDL, DML, DCL и TCL?

**Data Definition Language**  (**DDL**) - это группа операторов определения данных. Другими словами, с помощью 
операторов, входящих в эту группу, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем,
изменяем и удаляем их.

В эту группу входят следующие операторы:
+ CREATE - используется для создания объектов базы данных
+ ALTER - используется для изменения объектов базы данных
+ DROP - используется для удаления объектов базы данных

**Data Manipulation Language** (**DML**) - это группа операторов для манипуляции данными. С помощью этих операторов мы
можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими.

В эту группу входят самые распространенные операторы языка SQL:
+ SELECT - осуществляет выборку данных
+ INSERT - добавляет новые данные
+ UPDATE - изменяет существующие данные
+ DELETE - удаляет данные

**Data Control Language** (**DCL**) - группа операторов определения доступа к данным. Иными словами, это операторы для
управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами 
базы данных.

Сюда входят:
+ GRANT - предоставляет пользователю или группе разрешения на определенные операции с объектом
+ REVOKE - отзывает выданные разрешения
+ DENY - задает запрет, имеющий приоритет над разрешением

**Transaction Control Language** (**TCL**) - группа операторов для управления транзакциями. Транзакция - это команда или
блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения 
фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию,
будут отменены.

Группа операторов TCL предназначена как раз для реализации и управлением транзакцией. Сюда можно отнести:

+ BEGIN TRANSACTION - служит для определения начала транзакции
+ COMMIT TRANSACTION - применяет транзакцию
+ ROLLBACK TRANSACTION - откатывает все изменения, сделанные в контексте текущей транзакции
+ SAVE TRANSACTION - устанавливает промежуточную точку сохранения внутри транзакции

[к оглавлению](#SQL)

## 7. Что такое первичный ключ?

**Первичный ключ (primary key)** - столбец таблицы, имеющий уникальное значение для каждой записи. Первичный ключ 
используется для однозначной идентификации записей.

+ **Первичный ключ не может содержать NULL**. Значение NULL не может быть уникальным, потому что в других записях этот 
  столбец тоже может содержать NULL.
  
+ **Значение первичного ключа должно задаваться при вставке записи**. При вставке в таблицу записи без указания значения
  первичного ключа возникает риск создания записи с первичиным ключом NULL и появления дубликатов, а это нарушает 
  требования первой нормальной формы.
  
+ **Первичный ключ должен быть компактным**. Первичный ключ должен содержать только ту информацию, которая обеспечивает
  его уникальность, и ничего более.
  
+ **Значения первичного ключа должны оставаться неизменными**. Если бы первичный ключ можно было изменять, то ему можно 
  было бы случайно присвоить уже используемое значение. Первичный ключ должен быть уникальным.
  
Таблица может иметь только один первичный ключ, который может состоять из одного или нескольких полей. Когда несколько
полей используются в качестве первичного ключа, их называют составным ключом.

[к оглавлению](#SQL)

## 8. Что такое внешний ключ?

**Внешний ключ (foreign key)** - столбец таблицы, в котором хранятся значения **первичного ключа** другой таблицы.

+ Имя внешнего ключа может отличаться от имени первичного ключа, с которым он связывается.

+ Первичный ключ, используемый внешним ключом, также называется родительским ключом. Таблица, которой принадлежит 
  первичный ключ, называется родительской таблицей.

+ Внешний ключ может использоваться для установления соответствия между записями двух таблиц.

+ Внешний ключ может содержать значения NULL, хотя в первичном ключе они запрещены. 

+ Значения внешнего ключа не обязаны быть уникальными - более того, чаще они уникальными не являются.

[к оглавлению](#SQL)

## 9. Какие виды связей между таблицами существуют и как они организуются?

### 1) «ОДИН-К-ОДНОМУ»
В связях этого типа запись из табицы `A` может быть связана НЕ БОЛЕЕ ЧЕМ С ОДНОЙ записью в таблице `B`. 

Допустим, в таблице `A` хранится ваше имя, а в табилце `B` - информация о доходах и номера социального страхования 
(такая **изоляция** повышает безопасность данных). 
    
Обычно данные, связанные по типу "один-к-одному", разумнее хранить в основной таблице, однако выделение их в отдельную
таблицу иногда приносит некоторые преимущества.

1. Выделение данных может ускорить обработку запросов. Например, если подавляющее большинство запросов извлекает только 
        номер социального страхования и ничего более, лучше обращаться с запросом к меньшей таблице.
   
2. Если столбец может содержать неизвестные на данный момент значения, выделение его в отдельную таблицу позволит 
        избежать хранения NULL в основной таблице.
   
3. Изоляция части данных помогает ограничить доступ к ним. Например, если у вас имеется таблица с записями работников, 
        информацию о доходах лучше хранить отдельно от основной таблицы.
   
4. Большие блоки данных тоже лучше хранить в отдельной таблице.

### 2) «ОДИН-КО-МНОГИМ»
В связях типа "один-ко-многим" запись в таблице `A` может быть связана со МНОГИМИ записями в таблице `B`, но каждая
запись в таблице `B` может быть связана только с ОДНОЙ записью в таблице `A`.

Допустим, каждая запись таблицы `professions` может быть связана со многими записями `employees`, но каждая запись
`employees` всегда связана только с одной записью в таблице `professions`.

### 3) «МНОГИЕ-КО-МНОГИМ»
"Многие-ко-многим": в соединительной таблице хранятся ключи из обеих таблиц. Обычно они состоят из **двух связей 
"один-ко-многим"**, объединенных при помощи **соединительной таблицы**.

Допустим, **ОДИН** человек из таблицы `contacts` связывается со **МНОГИМИ** увлечениями из новой таблицы `interests`. 
Но так как каждое увлечение может принадлежать нескольким людям, такая связь относится к типу **многие-ко-многим**.

[к оглавлению](#SQL)

## 10. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

### 1) Вставка

Для вставки новых записей используется оператор `INSERT INTO`. Написать `INSERT INTO` можно двумя способами:

1. Укажите имена столбцов и значения для вставки:
```postgres-sql
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);
```
2. Если вы добавляете значения для всех столбцов таблицы, то не нужно указывать имена столбцов в запросе SQL. Однако 
   необходимо убедиться, что порядок значений соответствует порядку столбцов в таблице.
```postgres-sql
INSERT INTO table_name
VALUES (value1, value2, value3);
```

Также можно вставить данные в таблицу из выборки. Оператор `INSERT INTO SELECT` требует, чтобы типы данных в исходной и 
целевой таблицах совпадали. Существующие записи в целевой таблице затронуты не будут.

1. Скопирует записи со всеми столбцами из одной таблицы в другую. 
```postgres-sql
INSERT INTO table2
SELECT * FROM table1
WHERE condition;
```

2. Скопирует записи только некоторых столбцов из одной таблицы в другую.
```postgres-sql
INSERT INTO table2 (column1, column2, column3)
SELECT column1, column2, column3
FROM table1
WHERE condition;
```

### 2) Удаление

Для удаления записей используется оператор `DELETE`
```postgres-sql
DELETE FROM table_name WHERE condition;
```

Можно удалить все строки в таблице, не удаляя таблицу:
```postgres-sql
DELETE FROM table_name;
```

### 3) Обновление

Оператор `UPDATE` используется для изменения существующих записей в таблице.
```postgres-sql
UPDATE table_name
SET column1 = value1, column2 = value2
WHERE condition;
```

[к оглавлению](#SQL)

## 11. Что такое нормализация БД?

**Нормализация** - это метод проектирования базы данных, который позволяет привести базу данных к минимальной
избыточности.

Избыточность устраняется, как правило, за счет декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на 
несколько.

### Зачем нормализовать базу данных?

Избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управ
ление данными не гибким и не очень удобным. Нормализация нужна для:

+ Устранения аномалий
+ Повышения производительности
+ Повышения удобства управления данными

**Избыточность данных** - это когда одни и те же данные хранятся в базе в нескольких местах, именно это и приводит к 
аномалиям.

В целом процесс нормализации базы данных выглядит следующим образом: следуя определённым правилам и соблюдая 
определенные требования мы приводим базу данных к определенной нормальной форме.

**Нормальная форма базы данных** - это набор правил и критериев, которым должна отвечать база данных.

Каждая следующая нормальная форма содержит более строгие правила и критерии, тем самым приводя базу данных к 
определенной нормальной форме мы устраняем определенный набор аномалий.

База данных считается нормализованной, если она находится как минимум в третьей нормальной форме.

[к оглавлению](#SQL)

## 12. Что такое денормализация БД? Для чего она нужна?

Обычно под **денормализацией** понимают стратегию, применимую к уже нормализованной базе данных с целью повышения её 
производительности. Смысл этого действия - поместить избыточные данные туда, где они смогут принести максимальную 
пользу. Для этого можно использовать дополнительные поля в уже существующих таблицах, добавлять новые таблицы или даже
создавать новые экземпляры существующих таблиц. Логика в том, чтобы снизить время исполнения определенных запросов через
упрощение доступа к данным или через создание таблиц с результатами отчетов, построенных на основании исходных данных.

Непременное условие процесса денормализации - наличие нормализованной базы.

Когда полезно использовать денормализацию:

1. **Сохранение исторических данных.** Например, могут измениться имя и фамилия клиента или другие данные о его месте 
   жительства и роде занятий.
2. **Повышение производительности запросов.** Пример - ситуация, когда необходимо объединить до 10 таблиц для получения 
   имени клиента и наименования товаров, которые были ему проданы.
3. **Ускорение создания отчетов.** Например, требуется отслеживать клиентские продажи за определенный промежуток по 
   заданной группе или по всем пользователям разом. Решающий эту задачу запрос в "боевой" базе перелопатит её полностью,
   прежде чем подобный отчет будет сформирован.
4. **Предварительные вычисления часто запрашиваемых значений.** Всегда есть потребность держать наиболее часто 
   запрашиваемые значения наготове для регулярных расчетов, а не создавать их заново, генерируя их каждый раз в реальном
   времени.
   
 У денормализации есть своя цена:

+ **Место на диске.** Данные дублируются.
+ **Аномалии данных.** Необходимо понимать, что с определенного момента данные могут быть изменены в нескольких местах 
  одновременно. Соответственно, нужно корректно менять их копии.
+ **Документация**. Каждое применение денормализации следует подробно документировать. 
+ **Замедление других операций**. Вполне возможно, что применение денормализации замедлит процессы вставки, модификации 
  и удаления данных.
+ **Больше кода**. Пункты 2 и 3 потребуют добавления кода.

[к оглавлению](#SQL)

## 13. Что такое «индексы»? Для чего их используют? В чём заключаются их преимущества и недостатки?

**Индекс (index)** — объект базы данных, создаваемый с целью повышения производительности выборки данных.

Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному 
критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс 
формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким 
образом, достигается значительный прирост скорости выборки из этих данных.

Преимущества
+ ускорение поиска и сортировки по определенному полю или набору полей.
+ обеспечение уникальности данных.

Недостатки
+ требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.
+ замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.

Индексы предпочтительней для:
+ Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;
+ Поля, по которому проводится сортировка данных;
+ Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке 
  возрастания индекса и соединение происходит значительно быстрее;
+ Поля, которое объявлено первичным ключом (primary key);
+ Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с 
  нужным значением, все последующие значения будут расположены рядом.
  
Использование индексов нецелесообразно для:
+ Полей, которые редко используются в запросах;
+ Полей, которые содержат всего два или три значения, например: *мужской*, *женский пол* или значения *«да»*, *«нет»*.

[к оглавлению](#SQL)

## 14. Что такое кластерный и некластерный индексы?

Некластерные индексы - данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. 
Такой тип индексов подходит для часто изменяемого набора данных.

При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в 
случае последовательного доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.

[к оглавлению](#SQL)

## 15. Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?

Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ 
удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае 
оптимизация приведет к замедлению выборки.

[к оглавлению](#SQL)

## 16. Когда полное сканирование набора данных выгоднее доступа по индексу?

Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по 
индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при
этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений 
больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее, и оно выбирается 
оптимизатором.

Таким образом, полное сканирование выбирается при слабой селективности предикатов запроса и/или слабой кластеризации 
данных, либо в случае очень маленьких наборов данных.

[к оглавлению](#SQL)

## 17. Какие типы соединений (join) таблиц существуют? В чем их разница?

+ **Перекрестное соединение** `CROSS JOIN` возвращает комбинации каждой записи первой таблицы с каждой записью второй 
   таблицы. Перекрастное соединение является разновидностью внутреннего соединения. В сущности, внутреннее соединение -
   это перекрестное соединение, из результатов которого некоторые записи исключены по критерию запроса.
   
+ **Внутренним соединением** `INNER JOIN` называется перекрестное соединение, из результатов которого часть записей 
   исключается по условию запроса. Внутреннее соединение комбинирует записи из двух таблиц в соответствии с заданным 
   условием.
   1. **Эквивалентное соединение** - внутреннее соединение с проверкой равенства.
   2. **Неэквивалентное соединение** возвращает записи, у которых заданные значения столбцов не равны.
   
+ **Естественные соединения** `NATURAL JOIN` возможны только в том случае, если столбец, по которому выполняется 
   соединение, имеет одинаковые имена в обеих таблицах.
   
+ **Левое внешнее соединение** `LEFT OUTER JOIN` перебирает все записи левой таблицы и ищет для каждой соответствие среди
   записей правой таблицы. Значение NULL в результатах левого внешнего соединения означает, что правая таблица не 
   содержит значений, соответствующих левой таблице.
   
+ **Правое внешнеее соединение** `RIGHT OUTER JOIN` почти полностью аналогично левому внешнему соединению, кроме того, 
   что оно сравнивает правую таблицу с левой. Правое внешнее соединение ищет в левой таблице соответствия для правой 
   таблицы.
   
+ **Полное соединение** `FULL JOIN`. Данный тип внешнего соединения дает разультат левого + правого соединений, т.е. 
   представляет собой комбинацию этих двух соединений. Работает он так: выполняется левое соединение, выполняется правое
   соединение и оба результата этих запросов попадают в результрующую выборку.
   
+ **Самосоединение** `SELF JOIN`. соединение таблицы с этой же таблицей.

[к оглавлению](#SQL)

## 18. Что такое SQL курсор?

Команды манипулирования данными `SELECT`, `UPDATE`, `DELETE` работают сразу с группами строк. Эти группы, вплоть до 
отдельных строк, можно выбрать с помощью опции `WHERE`. А если надо перебрать строки некоторой таблицы последовательно, 
одну за другой? На этот случай в языке SQL существуют курсоры.

**Курсор (current set of record)** – временный набор строк, которые можно перебирать последовательно, с первой до 
последней. Это эффективный способ получать большие наборы строк из функций по частям.

С помощью курсоров можно выполнять следующие задачи:

+ Укажите положение в конкретных строках результирующего набора.
+ Получение одной строки или блока строк на основе текущего расположения результирующего набора.
+ Изменение данных в строках в текущей позиции результирующего набора.
+ Определите различные уровни чувствительности к изменениям данных, внесенным другими пользователями.

[Курсоры в PL/pgSQL](https://postgrespro.ru/docs/postgresql/9.5/plpgsql-cursors)

Ещё разное:

[Что такое курсор?](https://docs.microsoft.com/ru-ru/sql/ado/guide/data/what-is-a-cursor?view=sql-server-2017)

[Основы T-SQL и примеры — функции (UDF), триггеры, процедуры, курсоры, циклы](https://ivan-shamaev.ru/t-sql-fundamentals-and-examples/#i-6)

[Курсоры в MSSQL - перебор выборки в цикле.](https://kbss.ru/blog/mssql/55.html)

[к оглавлению](#SQL)

## 19. Опишите шаги по созданию и использованию курсора.

При работе с курсорами используются следующие команды.

+ **Объявление курсора**:
  `DECLARE имя_курсора CURSOR FOR SELECT текст_запроса`
  Любой курсор создается на основе некоторого оператора `SELECT`.

+ **Открытие курсора**:
  `OPEN имя_курсора`
  Для того чтобы с помощью курсора можно было читать строки, его надо обязательно открыть.

+ **Чтение следующей строки из курсора**:
  `FETCH имя_курсора INTO список_переменных`
  Переменные в списке должны быть в том же количестве и того же типа, что и столбцы курсора.
  Глобальная переменная `@@FETCH_STATUS` принимает ненулевое значение, если строк в курсоре больше нет.
  Если же набор строк еще не исчерпан, то `@@FETCH_STATUS` равна нулю, и оператор `FETCH` перепишет значения полей
  из текущей строки в переменные.

+ **Закрытие курсора**:
  `CLOSE имя_курсора`

+ Для **удаления курсора из памяти** используется команда
  `DEALLOCATE имя_курсора`

Для иллюстрации использования курсора создадим процедуру, которая будет выбирать данные из одной таблицы,
перебирать их в курсоре анализируя, есть ли такие данные во второй таблице и вставлять в третью таблицу,
если данные записи удовлетворяют определённым критериям.
```sql
CREATE PROCEDURE [dbo].[MyProcedure] AS
DECLARE @ID INT
DECLARE @QUA INT
DECLARE @VAL VARCHAR (500)
DECLARE @NAM VARCHAR (500)
/*Объявляем курсор*/
DECLARE @CURSOR CURSOR
/*Заполняем курсор*/
SET @CURSOR  = CURSOR SCROLL
FOR
SELECT INDEX, QUANTITY, VALUE, NAME  
  FROM My_First_Table WHERE  QUANTITY > 1
/*Открываем курсор*/
OPEN @CURSOR
/*Выбираем первую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
/*Выполняем в цикле перебор строк*/
WHILE @@FETCH_STATUS = 0
BEGIN
        IF NOT EXISTS(SELECT VAL FROM My_Second_Table WHERE ID=@ID)
        BEGIN
/*Вставляем параметры в третью таблицу если условие соблюдается*/
                INSERT INTO My_Third_Table (VALUE, NAME) VALUE(@VAL, @NAM)
        END
/*Выбираем следующую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
END
CLOSE @CURSOR
```

Также пример на Pl/PgSQL. Перебор таблицы и вывод данных о ней в консоль:
```postgres-sql
DO
$$
DECLARE l_name VARCHAR;
DECLARE curs CURSOR FOR SELECT name FROM cars;
BEGIN
	FOR l_name IN curs LOOP
		RAISE NOTICE '%', l_name;
	END LOOP;
END
$$ language plpgsql;
```

[к оглавлению](#SQL)

## 20. Что такое транзакция?

**Транзакция** - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в 
изменении данных, хранящихся в базе данных.

При работе с транзакциями в SQL используются три команды.

1. `START TRANSACTION` отслеживает выполнение всех последующих команд SQL вплоть до выполнения `COMMIT` или `ROLLBACK`.
2. `COMMIT` если все команды выполнены успешно и все выглядит хорошо, закрепите изменения командой `COMMIT`.
3. `ROLLBACK` если что-то пошло не так, команда `ROLLBACK` отменяет все изменения, и база данных возвращается к 
   состоянию до ввода команды `START TRANSACTION`.

[к оглавлению](#SQL)

## 21. Назовите основные свойства транзакции.

Чтобы набор команд SQL мог считаться транзакцией, он должен обладать четырьмя свойствами: атомарностью, целостностью,
изолированностью и устойчивостью. В английском языке этот набор свойств часто обозначается сокращением ACID (Atomicity,
Consistency, Isolation, Durability).

**Атомарность (atomicity)** гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо 
выполнены все её подоперации, либо не выполнено ни одной.

**Согласованность (consistency)**. Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои
результаты, сохраняет согласованность базы данных.

**Изолированность (isolation)**. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на 
её результат.

**Долговечность (durability)**. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в 
оборудовании) изменения, сделанные успешно завершенной транзакцией, должны остаться сохраненными после возвращения 
системы в работу.

[к оглавлению](#SQL)

## 22. Какие существуют уровни изолированности транзакций?

В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:

+ **Чтение неподтвержденных данных (грязное чтение) (read uncommitted, dirty read)** — чтение незафиксированных 
  изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими 
  транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным 
  источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.
  
+ **Чтение подтвержденных данных (read committed)** - чтение всех изменений своей транзакции и зафиксированных изменений 
  параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.
  
+ **Повторяемость чтения (repeatable read, snapshot)** - чтение всех изменений своей транзакции, любые изменения, 
  внесённые праллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторямое 
  чтение невозможны, возможны фантомы.
  
+ **Упорядочиваемость (serializable)** - результат параллельного выполнения сериализуемой транзакции с другими
  транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы 
  синхронизации не возникают.

[к оглавлению](#SQL)

## 23. Какие проблемы могут возникать при параллельном доступе с использованием транзакций?

При параллельном выполнении транзакций возможны следующие проблемы:

+ **Потерянное обновление (lost update)** - при одновременном изменении одного блока данных разными транзакциями одно 
  из изменений теряется;
  
+ **Грязное» чтение (dirty read)** — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не 
  подтвердится (откатится);

+ **Неповторяющееся чтение (non-repeatable read)** — при повторном чтении в рамках одной транзакции ранее прочитанные данные
  оказываются изменёнными;
  
+ **Фантомное чтение (phantom reads)** — одна транзакция в ходе своего выполнения несколько раз выбирает множество 
  записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи 
  или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В 
  результате получится, что одни и те же выборки в первой транзакции дают разные множества записей. Предположим, имеется
  две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:
  
| Транзакция 1 | Транзакция 2 |
|--------------|--------------|
| | SELECT SUM(f2) FROM tbl1; |
| INSERT INTO tbl1 (f1,f2) VALUES (15,20); | |
| COMMIT;      | |
| | SELECT SUM(f2) FROM tbl1; |

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка 
новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. Такая 
ситуация называется чтением фантома (фантомным чтением). От неповторяющегося чтения оно отличается тем, что результат 
повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых 
(фантомных) данных.

[к оглавлению](#SQL)

## 24. Что такое триггер? Какие типы триггеров Вы знаете?

**Триггер (trigger)** — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а 
исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной 
таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-
логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как 
выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае 
обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.

Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним 
события) или AFTER (после события). В случае, если триггер вызывается до события, он может внести изменения в 
модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом
случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова BEFORE и AFTER 
влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не 
происходит.

[Обзор механизма работы триггеров в PostgreSQL](https://postgrespro.ru/docs/postgresql/9.5/trigger-definition)

[Обзор механизма работы триггеров событий в PostgreSQL](https://postgrespro.ru/docs/postgresql/9.5/event-trigger-definition)

[Пример использования триггеров](https://habr.com/ru/post/146717/)

[к оглавлению](#SQL)

## 25. В чем разница между where и having?

`WHERE` - это условие, которое уточняет критерий отбора записей. Условие сужает результаты поиска, а команда возвращает 
только те записи, для которых это условие выполняется.

У метода `WHERE` есть одно ограничение - его нельзя использовать с агрегатными функциями. Для этих целей специально 
служит оператор `HAVING`. Применяет он аналогично `WHERE`, только в нем обязательно должна быть агрегатная функция.

[к оглавлению](#SQL)

## 26. Что такое подзапрос (sub-query)?

Подзапрос представляет собой запрос, "упакованный" в другом запросе. Также он может называться "внутренним запросом".

Подзапрос - не что иное, как запрос внутри другого запроса. "Охватывающий" запрос называется внешним, а "вложенный" - 
внутренним запросом, или подзапросом.

Подзапрос, используемый в качестве выражения столбца в команде SELECT, может возвращать только одно значение из одного 
столбца.

Обычно, подзапрос используется в конструкции `WHERE`, когда вы можете получить значение с помощью запроса,
но не знаете конкретного результата.

[Подзапросы в PostgreSQL](https://postgrespro.ru/docs/postgresql/9.5/queries-table-expressions#queries-subqueries)

[Скалярные подзапросы](https://postgrespro.ru/docs/postgresql/9.5/sql-expressions#sql-syntax-scalar-subqueries)

[Выражения подзапросов](https://postgrespro.ru/docs/postgresql/9.5/functions-subquery)

[к оглавлению](#SQL)

## 27. Что такое union?

`UNION` - это так называемые союзы. Союз объеденяет в одну таблицу разультаты двух и более запросов на основании того, 
что указано в запросе `SELECT`. Союзы можно трактовать как "пересекающиеся" значения всех запросов. 

Ограничения союзов:
+ Количество столбцов в командах `SELECT` должно быть одинаковым. Нельзя выбрать два столбца одной командой и ещё один 
  столбец другой.
  
+ Команды `SELECT` должны содержать одинаковые выражения и агрегатные функции.

+ Команды `SELECT` могут следовать в любом порядке; на результаты это не влияет.

+ По умолчанию SQL исключает дубликаты из результатов союзов.

+ Типы данных в столбцах должны совпадать, либо быть совместимыми.

+ Если по какой-то причине необходимо получить список со всеми дубликатами, используйте оператор `UNION ALL`. Он 
  возвращает все совпадения, не только уникальные.

[к оглавлению](#SQL)

## 28. Что такое group by?

Предложение `GROUP BY` используется для определения групп выходных строк, к которым могут применяться агрегатные
функции (`COUNT`, `MIN`, `MAX`, `AVG` и `SUM`).
все столбцы списка `SELECT`, не вошедшие в агрегатные функции, должны быть указаны в предложении `GROUP BY`.

В результате чего все выходные строки запроса разбиваются на группы, характеризуемые одинаковыми комбинациями значений
в этих столбцах. После чего к каждой группе будут применены агрегатные функции. Следует иметь в виду, что для `GROUP BY`
все значения `NULL` трактуются как равные, то есть при группировке по полю, содержащему `NULL`-значения,
все такие строки попадут в одну группу.

[к оглавлению](#SQL)

## 29. Что такое хранимые процедуры?

Объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и хранится на сервере.
Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные
параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными,
результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные
операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления,
то есть в них могут использоваться инструкции управления процессом исполнения.

Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции 
безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется 
синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.

[Хранимые процедуры и временные таблицы. MySQL для начинающих](https://habr.com/ru/post/79340/)

[Хранимые процедуры для Java-программистов](http://javatutor.net/articles/stored-procedures-for-java-programmers)

[к оглавлению](#SQL)

## 30. Что такое view(Представление)?

В сущности, представление - это таблица, существующая только во время использования представления в запросе. 
Представление называется **виртуальной таблицей**, потому что ведет себя как настоящая таблица и с ним можно выполнять
те же операции, что и с обычными таблицами. Виртуальная таблица не хранится в базе данных. Она создается тогда, когда
вы используете представление, а затем уничтожается.

**Почему представления удобны при работе с базами данных:**
1. Возможные изменения структуры базы данных не нарушат работы приложений, зависящих от таблиц.
2. Представления упрощают сложные запросы до простых команд.
3. Представления могут скрывать информацию, которая не нужна пользователю.

Если в представлении используются агрегатные функции, оно не может использоваться для обновления данных. Кроме того, 
если представление содержит условия `GROUP BY`, `DISTINCT`, или `HAVING`, изменение данных также невозможно.

[Представления (VIEW) в MySQL](https://habr.com/ru/post/47031/)

[к оглавлению](#SQL)

## 31. Основные элементы баз данных таблицы процедуры функции констрейнты и тд?

**Поле** — это минимальный элемент базы данных, содержащий один неделимый квант информации.
Каждое поле характеризуется именем и типом хранящихся в нем данных.

**Запись** — это совокупность нескольких разнородных полей, описывающая некоторую сущность предметной области.

**Таблица базы данных** — это набор однородных записей.

**Хранимая процедура** — объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз
и хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня,
у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления
и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам.
В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML).
Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции
управления процессом исполнения.

```sql
CREATE [OR REPLACE] PROCEDURE имя_процедуры
[ (параметр [, параметр, …]) ] IS
            [локальные объявления]
        BEGIN
            исполняемые предложения
        [EXCEPTION
            обработчики исключений]
        END [имя_процедуры];
```

**Функция** – это подпрограмма, которая вычисляет значение.
Существует большое количество встроенных функций (могут разниться для разных БД).

```sql
CREATE [OR REPLACE] FUNCTION имя_функции
[ (параметр [, параметр, …]) ]
RETURN тип_данных IS | AS
            [локальные объявления]
        BEGIN
            исполняемые предложения
        [EXCEPTION
            обработчики исключений]
        END [имя_функции];
```

**Констрейнты (constraints)** — объявление правил (ограничения), которым должны соответствовать данные в таблице.

```sql
CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);
```

Например для задания первичного ключа, можно использовать такую запись:

```sql
CONSTRAINT <имя ограничения> PRIMARY KEY (<список столбцов, являющихся первичным ключом>)
```

Типы констрейнтов:

+ `NOT NULL` — колонка не может содержать `NULL` значений.
+ `UNIQUE` — каждая строка в колонке должна иметь уникальное значение.
+ `PRIMARY KEY` — комбинация `NOT NULL` и `UNIQUE`.
+ `FOREIGN KEY` — обеспечивает ссылочную целостность. Означает, что ссылающиеся данные имеют соответствие в другой таблице.
+ `CHECK` — проверка на определенное выполнение правил.
+ `DEFAULT` — задает значение по умолчанию для колонки.

[к оглавлению](#SQL)

## 32. Как вы понимаете null в базах данных?

Смысл `NULL-значения` — это отсутствие информации или неприменимость данного атрибута в данном кортеже.

`NULL-значение` может означать неприменимость значения к этому столбцу
(например в колонке «скорость полета» для таблицы животные и записи «Слон»)

`NULL-значение` так же может означать отсутствие информации.
Заменять отсутствующие значения, например на `-1`, `‘ ‘` или что-то такое, некорректно.

## 33. Агрегатные функции как они работают с null Не забудьте о group by и having?

Стандартом предусмотрены следующие агрегатные функции:

+ `COUNT(*)` Возвращает количество строк источника записей.
+ `COUNT` Возвращает количество значений в указанном столбце.
+ `SUM` Возвращает сумму значений в указанном столбце.
+ `AVG` Возвращает среднее значение в указанном столбце.
+ `MIN` Возвращает минимальное значение в указанном столбце.
+ `MAX` Возвращает максимальное значение в указанном столбце.

Все эти функции возвращают единственное значение. При этом функции `COUNT`, `MIN` и `MAX` применимы к данным любого типа,
в то время как `SUM` и `AVG` используются только для данных числового типа. Разница между функцией `COUNT(*)`
и `COUNT(имя столбца | выражение)` состоит в том, что вторая (как и остальные агрегатные функции) при подсчете
не учитывает `NULL-значения`.

Предложение `GROUP BY` используется для определения групп выходных строк, к которым могут применяться агрегатные
функции (`COUNT`, `MIN`, `MAX`, `AVG` и `SUM`).

Если предложение `WHERE` определяет предикат для фильтрации строк, то предложение `HAVING` применяется после
группировки для определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций.
Это предложение необходимо для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк
источника записей, определенного в предложении `FROM`, а из групп таких строк.
Поэтому такая проверка не может содержаться в предложении `WHERE`.

[к оглавлению](#SQL)

## 34 Каким образом лучше добавлять большое количество записей в таблицу?

+ Отключить `autocommit`.
+ Выполнить `insert`.
+ Закоммитить вручную.
+ Включить `autocommit`.

[к оглавлению](#SQL)

## 35. Что такое первая нормальная форма и процесс нормализации Какие бывают нормальные формы?

Первая нормальная форма (`1NF`) — базовая нормальная форма отношения в реляционной модели данных.

**Нормальная форма** — свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности,
потенциально приводящей к логически ошибочным результатам выборки или изменения данных.

Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение.

Нормальные формы: первая нормальная форма, вторая нормальная форма, третья нормальная форма,
нормальная форма Бойса — Кодда, четвёртая нормальная форма, пятая нормальная форма.

[к оглавлению](#SQL)

## 36. В чем смысл индекса СУБД как они устроены как хранятся Как бы вы реализовали тот же функционал?

**Индекс (англ. index)** — объект базы данных, создаваемый с целью повышения производительности поиска данных.
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке,
и их поиск по заданному критерию путем последовательного просмотра таблицы строка за строкой может занимать много времени.
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и,
таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов
достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например,
сбалансированного дерева.

Обзор типов индексов Oracle, MySQL, PostgreSQL, MS SQL: http://habrahabr.ru/post/102785/

[к оглавлению](#SQL)

## 37. Что такое JDBC?

**JDBC** (Java DataBase Connectivity) – это API, т.е. набор вспомогательных классов, которое позволяет работать с базами 
данных. Стандартный прикладной интерфейс (API) языка Java для организации взаимодействия между приложением и СУБД. Это 
взаимодействие осуществляется с помощью драйверов JDBC, обеспечивающих реализацию общих интерфейсов для конкретных СУБД 
и конкретных протоколов.

[к оглавлению](#SQL)

## 38. Что нужно для работы с той или иной БД?

Для работы с той или иной базой данных существует понятие драйвера. Драйвер – это то, что позволяет работать с бд 
(поддерживать подключения, выполнять запросы и т.д.). Для каждой БД есть свой драйвер.

[к оглавлению](#SQL)

## 39. Как зарегистрировать драйвер?

Чтобы добавить драйвер в проект необходимо добавить зависимость на этот самый драйвер.

Добавьте зависимость в проект:
```xml
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.16</version>
</dependency>
```

После добавления зависимости на драйвер, нам необходимо его зарегистрировать в системе. Чтобы это сделать необходимо 
прописать строку:

```java
Class.forName("org.postgresql.Driver");
```

[к оглавлению](#SQL)

## 40. Как получить Connection?

Для подключения нам нужны url, логин (имя пользователя) и пароль. Чтобы получить подключение нужно воспользоваться 
классом `DriverManager`, передав ему эти аргументы.

```java
String url = "jdbc:postgresql://localhost:5432/idea_db";
String login = "postgres";
String password = "password";
try (Connection connection = DriverManager.getConnection(url, login, password)) {
```

Если объект типа `Connection` не равен `null`, то это значит, что установлено подключение и теперь можно выполнять 
запросы к базе данных.

[к оглавлению](#SQL)

## 41. Что такое Statement, PrepareStatement? В чем разница между ними?

Для исполнения операций существуют специальные классы: `Statement`, `PrepareStatement`. 

### Statement

`Statement` используется для выполнения SQL запросов к базе данных.
Объект `Statement` можно получить с помощью метода `Connection.getStatement()`.
Вызывая методы `execute()`, `executeQuery()`, `executeUpdate()` и др., можно выполнять различные статичные SQL запросы.

В случае динамически созданных SQL запросов внутри java программы, когда введенные пользователем данные могут быть
не проверенными, можно использовать `SQL injection`.

По умолчанию только один объект `ResultSet` для каждого `Statement` может быть открыт в одно и то же время.
Таким образом, если необходимо работать с несколькими объектами `ResultSet` одновременно, мы должны использовать 
различные объекты `Statement`. Все `execute()` методы в интерфейсе `Statement` закроют текущий открытый объект 
ResultSet` при выполнении.

### PrepareStatement

`PrepareStatement` используется для выполнения прекомпилированных SQL-запросов с или без входных (`IN`) параметров.
Мы можем использовать сеттеры для установки значений в запрос. Т.к. `PreparedStatement` является предкомпилированным,
то он может быть эффективно использован множество раз.

`PreparedStatement` считается лучшим выбором нежели `Statement`,
т.к. он автоматически обрабатывает специальные символы, а так же предотвращает, так называемые, `SQL injection attack`
(когда в запрос можно подставить свой код).

### Преимущества в использовании PreparedStatement над Statement:

+ `PreparedStatement` позволяет предотвратить атаки типа `SQL injection`, т.к. он автоматически экранирует специальные символы.

+ `PreparedStatement` позволяет использовать динамические запросы с внедрением параметров.

+ `PreparedStatement` быстрее `Statement`. Это особенно заметно при частом использовании `PreparedStatement `
  или при использовании для вызова группы запросов.

+ `PreparedStatement` позволяет писать объектно ориентированный код с использованием сеттеров\геттеров.
  А при применении `Statement` необходимо использовать конкатенацию строк для создания запроса.
  Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.


[к оглавлению](#SQL)

## 42. Что такое ResultSet?

`ResultSet` - интерфейс, объект которого создается в результате запроса к базе данных.
Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.

Объект `ResultSet` поддерживает курсор, который указывает на текущую строку данных.
При инициализации курсор устанавливается до первой строки. Для движения по строкам используется метод `next()`.
При наличии строк после текущей позиции, метод `next()` возвращает `true`, что можно использовать для итерации по таблице
полученных результатов.

По умолчанию объект `ResultSet` НЕмодифицируемый и поддерживает курсор, который способен только к движение вперед.
Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного
движения по таблице, а так же возможности обновления:

```sql
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                   ResultSet.CONCUR_UPDATABLE);
```

Объект `ResultSet` автоматически закрывается при закрытии объекта, который его сгенерировал.
Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов.
Для использования геттера `ResultSet` можно использовать имя колонки или индекс, который начинается с `1`.

При создании `Statement` можно задать различные типы получаемого `ResultSet`.

Три типа объектов `ResultSet`:

1. **ResultSet.TYPE_FORWARD_ONLY:** тип по умолчанию. Поддерживает движение курсора только в прямом направлении.
2. **ResultSet.TYPE_SCROLL_INSENSITIVE:** Двунаправленный курсор. Объект не чувствителен к изменениям,
   которые произошли с таблицей после получения результата.
3. **ResultSet.TYPE_SCROLL_SENSITIVE:** Двунаправленный курсор. Объект чувствителен к изменениям, которые
   произошли с базой данных после создания объекта `ResultSet`.

Два типа потокобезопасных объектов `ResultSet`:

+ **ResultSet.CONCUR_READ_ONLY:** Поддерживает только чтение (read only). Применяется по умолчанию.
+ **ResultSet.CONCUR_UPDATABLE:** Поддерживает метод `ResultSet update` для обновления строк в таблице данных.

[к оглавлению](#SQL)

## 43. В чем разница между методами execute, executeUpdate, executeQueury?

Существует несколько способов выполнять SQL-запросы в зависимости от типа этого запроса.
Для этого у интерфейса `Statement` существует три различных метода: `executeQuery()`, `executeUpdate()`, а так же `execute()`.
Рассмотрим их отдельно:

+ Самый базовый метод `executeQuery()` необходим для запросов, результатом которых является один единственный набор значений,
  таких как у запросов `SELECT`. Возвращает `ResultSet`, который не может быть `null` даже если у результата запроса
  не было найдено значений.

+ Метод `execute()` используется, когда операторы SQL возвращают более одного набора данных, более одного счетчика обновлений
  или и то, и другое. Метод возвращает `true`, если результатом является `ResultSet`, как у запроса `SELECT`. Вернет `false`,
  если `ResultSet` отсутствует, например при запросах вида `INSERT`, `UPDATE`. С помощью методов `getResultSet()`
  мы можем получить `ResultSet`, а `getUpdateCount()` — количество обновленных записей.

+ Метод `executeUpdate()` используется для выполнения операторов `INSERT`, `UPDATE` или `DELETE`, а также для операторов
  DDL (Data Definition Language — язык определения данных), например, `CREATE TABLE` и `DROP TABLE`.
  Результатом оператора `INSERT`, `UPDATE`, или `DELETE` является модификация одной или более колонок в нуле или более
  строках таблицы.

  Метод `executeUpdate()` возвращает целое число, показывающее, сколько строк было модифицировано.
  Для выражений типа `CREATE TABLE` и `DROP TABLE`, которые не оперируют над строками, возвращаемое методом `executeUpdate()`
  значение всегда равно нулю.

Все методы выполнения SQL-запросов закрывают предыдущий набор результатов (`ResultSet`) у данного объекта `Statement`.
Это означает, что перед тем как выполнять следующий запрос над тем же объектом `Statement`,
надо завершить обработку результатов предыдущего (`ResultSet`).

[к оглавлению](#SQL)

## 44. Можно ли использовать возвращаемое значение execute() для проверки, что что-то обновилось?

Скорее нет, чем да, так как возвращает `boolean`. Метод возвращает `true`, если результатом является `ResultSet`, как у
запроса `SELECT`. Вернет `false`, если `ResultSet` отсутствует, например при запросах вида `INSERT`, `UPDATE`. С помощью
метода `getUpdateCount()` — можно вернуть количество обновленных записей.

[к оглавлению](#SQL)

## 45. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?

1. На чистом SQL. В SQL есть ключевое слово RETURNING(поля), которое мы можем использовать в запросе. В итоге запрос 
   вставки будет выглядеть так:
   
```postgres-sql
    INSERT INTO cities(name, population) VALUES ('Ufa', 1000000) RETURNING (id);
```

2. С использованием JDBC. Для того чтобы получить id. Нужно при создании PrepareStatement вторым аргументом передать 
   Statement.RETURNING_GENERATED_KEYS. После как обычно выполнить запрос. Наконец, чтобы получить ключ нужно вызвать 
   метод getGeneratedKeys().
   
```java
public City insert(City city) {
    try (PreparedStatement statement =
                 connection.prepareStatement("insert into cities(name, population) values (?, ?)",
                         Statement.RETURN_GENERATED_KEYS)) {
        statement.setString(1, city.getName());
        statement.setInt(2, city.getPopulation());
        statement.execute();
        try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
            if (generatedKeys.next()) {
                city.setId(generatedKeys.getInt(1));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return city;
}
```

[к оглавлению](#SQL)

## 46. Как установить NULL значения в JDBC PreparedStatement?

Используя метод `setNull()` для установки `null` переменной в качестве параметра.
Этот метод принимает индекс и SQL тип в качестве аргументов: `s.setNull(10, java.sql.Types.INTEGER);`.

[к оглавлению](#SQL)

## 47. Как используются методы setFetchSize и SetMaxRows в Statement?

Для ограничения количества строк, которые может вернуть запрос, применяется метод `setMaxRows(int i)`.
Конечно, этот результат можно получить используя SQL запрос (например для MySQL существует команда `LIMIT`).

Для понимания метода `setFetchSize()` необходимо разобраться с работой `Statement` и `ResultSet`.
Когда выполняется запрос к базе данных, результат обрабатывается и сохраняется
в кэше базы данных и возвращается в виде `ResultSet`.
`ResultSet` является курсором, который ссылается на результат в базе данных. Допустим, мы имеем запрос,
который возвращает 100 строк и мы установили `setFetchSize(10)`. Теперь для каждого обращения к базе данных
выделено только 10 строк и понадобится 10 запросов, чтобы получить все данные.
Выбор оптимального количества `fetchSize()` может улучшить производительность
выполнения большого кол-ва обращений к каждой строке и в случае большого количества строк в выходном результате.

Значение `fetchSize` можно указать внутри объекта `Statement`, но оно может быть переопределено
в объекте `ResultSet` с помощью `setFetchSize()`.

[к оглавлению](#SQL)

## 48. Как вызвать Stored Procedures используя JDBC API?

Хранимые процедуры — это группы SQL запросов, которые компилируются в базе данных и могут быть вызваны с помощью JDBC API.
Для вызова хранимых процедур используется объект `CallableStatement`.
Нам необходимо задать параметры выхода `OUT` до выполнения `CallableStatement`.

```sql
CallableStatement stmt = con.prepareCall("{call insertEmployee(?,?,?,?,?,?)}");
stmt.setInt(1, id);
stmt.setString(2, name);
stmt.setString(3, role);
stmt.setString(4, city);
stmt.setString(5, country);
 
//register the OUT parameter before calling the stored procedure
stmt.registerOutParameter(6, java.sql.Types.VARCHAR);
              
stmt.executeUpdate();
```

[к оглавлению](#SQL)

## 49. Что такое JDBC Batch Processing и каковы его преимущества?

Иногда необходимо выполнить сразу группу похожих запросов, например, при загрузке данных из CSV файлов
реляционной базы данных.
Это можно сделать просто используя `Statement` или `PreparedStatement` для пошагового выполнения этих запросов.
В JDBC API существует другой вариант, который предоставляет возможность выполнить группу запросов за один раз.
Выполнение такого рода задачи происходит с помощью JDBC API Batch Processing.

JDBC API поддерживает пакетную обработку с помощью методов `addBatch()` и `executeBatch()` у `Statement`
и `PreparedStatement`. К преимуществам такого подхода относится более быстрая работа,
т.к. кол-во обращений к базе данных можно существенно уменьшить.

[к оглавлению](#SQL)

## 50. Что такое JDBC Transaction Management и зачем он нужен?

По умолчанию, при создании подключения к базе данных будет выбран `auto-commit mode`.
Это означает, что при каждом выполнении запроса он будет подтвержден автоматически по завершению.
Каждый SQL запрос является транзакционным и выполняя какие-либо DML или DDL запросы по их завершению изменения
будут приняты (сохранены) базой данных. Если у нас есть необходимость отказываться от сохранения выполнения
какого-либо запроса (или групп запросов) в случае, если что-то пошло не так,
то мы можем воспользоваться поддержкой транзакций в JDBC API.

С помощью метода `setAutoCommit`(boolean flag) можно отключить автокоммит в конкретном соединении.
Следует отметить, что при отключении `auto-commit` ни одно изменение не будет сохранено в базе данных до вызова
метода `commit()` и за этим необходимо следить. Сервер базы данных будет блокировать необходимую часть базы данных
до подтверждения транзакции, а т.к. это ресурсоёмкая задача, то подтверждать транзакцию
необходимо сразу после выполнения задачи.

[к оглавлению](#SQL)

## 51. Как откатить JDBC транзакцию?

Для этого предусмотрен метод объекта `Connection rollback()`, который откатывает транзакцию.
Будут отменены все изменения в транзакции и отменен `lock` базы данных от этого объекта `Connection`.

[к оглавлению](#SQL)

## 52. Что такое JDBC Savepoint и как он используется?

**JDBC Savepoint** позволяет создавать «чекпоинты» в транзакции с помощью которых мы можем откатить не всю
транзакцию целиком, а только часть до точки сохранения. Любая точка сохранения автоматически освобождается
и становится недоступной после подтверждения транзакции или её роллбека. Откат к точке сохранения делает все
последующие сейвы недоступными и к ним уже нельзя будет вернуться.

[к оглавлению](#SQL)

## 53. Расскажите о JDBC DataSource Какие преимущества он дает?

**JDBC DataSource** является интерфейсом пакета `javax.sql` и является более продвинутым в сравнении с `DriverManager`
для подключения к базе данных. Мы можем использовать `DataSource` для создания подключения к базе данных и реализацию
класса драйвера, которая будет выполнять всю работу по поддержанию соединения.

В дополнение к соединению через `Database`, `DataSource` предоставляет следующие дополнительные возможности:

+ Кэширование `PreparedStatement` для ускорения обработки запросов;
+ Настройки `Connection timeout`;
+ Возможности логирования;
+ Порог максимального размера `ResultSet`;
+ Поддержка `Connection Pooling` в контейнере сервлетов, использующий поддержку JNDI.

[к оглавлению](#SQL)

## 54. Расскажите про Apache DBCP API?

При использование `DataSource` для получения соединения с базой данных возникает проблема тесной связи кода с
драйвером реализации `DataSource`. Кроме того, большинство из кода является шаблонно повторяющимся
(т.н. boilerplate code), за исключением выбора класса реализации источника данных.

**Apache DBCP API** помогает нам избавиться от этих проблем, предоставляя реализацию `DataSource`, который работает
в качестве уровня абстракции между нашей программой и различными драйверами JDBC. Библиотека Apache DBCP API основана
на библиотеке Commons Pool library, поэтому необходимо удостовериться, что все необходимые зависимости правильно
подключены к проекту.

[к оглавлению](#SQL)

## 55. Какие вы знаете уровни изоляции соединений в JDBC?

Уровень изолированности транзакций — значение, определяющее уровень, при котором в транзакции допускаются
несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень
изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций.
С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций,
но снижает точность данных.

Когда мы используем транзакции в JDBC для обеспечения целостности данных, СУБД использует блокировки,
чтобы заблокировать доступ других обращений к данным, участвующим в транзакции.

Такие блокировки необходимы, чтобы предотвратить:
+ грязное чтение (Dirty Read),
+ неповторяющиеся чтение (Non-Repeatable Read),
+ и фантомное чтение (Phantom-Read).

Уровень изоляции транзакции JDBC используемый СУБД для механизма блокировки можно задать с помощью метода
`setTransactionIsolation()`.
Получить информацию о применяемом уровне изоляции поможет метод `Connection getTransactionIsolation()`.

| Isolation Level| Transaction| Dirty Read| Non-Repeatable Read| Phantom Read |
| ---| ---| ---| ---| --- |
| TRANSACTION_NONE| Not Supported| Not Applicable| Not Applicable| Not Applicable |
| TRANSACTION_READ_COMMITTED| Supported| Prevented| Allowed| Allowed |
| TRANSACTION_READ_UNCOMMITTED| Supported| Allowed| Allowed| Allowed |
| TRANSACTION_REPEATABLE_READ| Supported| Prevented| Prevented| Allowed |
| TRANSACTION_SERIALIZABLE| Supported| Prevented| Prevented| Prevented |

[к оглавлению](#SQL)

## 56. Что вы знаете о JDBC RowSet Какие существуют различные типы RowSet?

`JDBC RowSet` содержит табличные данные в более гибком формате по сравнению с `ResultSet`.
Все объекты `RowSet` являются производными из `ResultSet`, так что они имеют все возможности `ResultSet`
с некоторыми дополнительными функциями. `RowSet` интерфейс определяется в пакете `javax.sql`.
Можно выделить следующие дополнительные функции, предоставляемые `RowSet`:

Функции похожие на Java Beans со свойствами и `get\set` методами для работы с ними. `RowSet` использует модель
событий JavaBeans. В результате можно посылать уведомления любого зарегистрированного компонента для таких событий,
как движение курсора, обновления/вставка/удаление из строки и изменять содержимое `RowSet`.
Объекты `RowSet` поддерживают скроллинг по данным (`scrollable`), а так же являются обновляемыми по умолчанию.
Так что, если СУБД не поддерживает скроллинг или обновляемый `ResultSet`, мы можем использовать `RowSet`,
чтобы получить эти функции.

`RowSet` можно разделить на два типа:

+ **Connected RowSet Objects** – эти объекты подключаются к БД и очень похожи на объекты `ResultSet`.
  JDBC API предоставляет только одно подключение объекта `RowSet` — `javax.sql.rowset.JdbcRowSet`
  и это является стандартной реализации класса `com.sun.rowset.JdbcRowSetImpl`.
+ **Disconnected RowSet Objects** – эти объекты `RowSet` не требуют подключения к базе данных.
  Они более легковесные и могут быть сериализованы. Такие объекты хорошо подходят для передачи данных по сети.
  Существуют несколько реализаций такого типа объектов.

Кратко рассмотрим четыре реализации `Disconnected RowSet Objects`:

1. `CachedRowSet` — объекты могут получить соединение и выполнить запрос, считать данные `ResultSet` для заполнения
   данных `RowSet`. Мы можем управлять и обновлять данные на время отключения от БД и записать измененные данные при
   очередном подключении.
2. `WebRowSet` получены из `CachedRowSet` — такие объекты могут читать и записывать XML документы.
3. `JoinRowSet` получены из `WebRowSet` — могут образовывать SQL JOIN без подключения к источнику данных.
4. `FilteredRowSet` получены из `WebRowSet` — поддержка применения критериев фильтрации, поэтому видны только выбранные
   (полученные) данные.

[к оглавлению](#SQL)

## 57. В чем разница между ResultSet и RowSet?

Объекты `RowSet` являются производными от `ResultSet`, поэтому они имеют все возможности `ResultSet` с некоторыми
дополнительными функциями. Одним из существенных преимуществ является возможность работы с данными без соединения
с базой, а так же их легковесность и возможность пересылки данных объектов по сети.

Следует ли использовать `ResultSet` или `RowSet` зависит от ваших требований. `ResultSet`, возможно, подойдет к
длительным подключениям, в то время как `RowSet` будет лучшим выбором для подключений к базам данных с возможностью
дисконекта и обработки полученных данных.

[к оглавлению](#SQL)

## 58. Приведите пример наиболее распространенных исключений в JDBC?

Некоторые из наиболее распространенных исключений JDBC:

+ **java.sql.SQLException** — это базовый класс для исключений JDBC.

+ **java.sql.BatchUpdateException** — возникает при исключительных ситуациях пакетной обработки запросов.
  Может зависеть от типа драйвера JDBC, который может выбросить взамен базовый `SQLException`.

+ **java.sql.SQLWarning** — для предупреждающих сообщений различных SQL операций.

+ **java.sql.DataTruncation** — когда значения данных неожиданно усекаются по причинам, не зависящим от
  превышения `MaxFieldSize`.

[к оглавлению](#SQL)

## 59. Расскажите о типах данных CLOB и BLOB в JDBC?

**Character Large Objects (CLOBs)** — тип данных (внутренний символьный объект), используемый для хранения
больших объектов. При выборе значения любого LOB-типа посредством оператора `SELECT` возвращается указатель,
а не само значение; кроме того, типы `LOB` могут быть и внешними. Этот тип данных является подходящим для хранения
текстовой информации, которая может выходить за пределы обычного типа данных `VARCHAR` (верхний предел 32 Кбайт).

**Внутренний большой двоичный объект (BLOB - Binary Large Object — двоичный большой объект)** — двоичный объект большого
размера, который может содержать переменное количество данных. Этот тип данных может хранить данные объемом
более `VARBINARY` (32K предел). Тип данных, предназначенный, в первую очередь, для хранения изображений, аудио и видео,
а также компилированного программного кода.

[к оглавлению](#SQL)

## 60. Что вы знаете о грязном чтении dirty read в JDBC Какой уровень изоляции предотвращает этот тип чтения?

**«Грязное» чтение (англ. dirty read)** — чтение данных, добавленных или изменённых транзакцией,
которая впоследствии не подтвердится (откатится). Получение недействительного в последствии значения
(после отката транзакции) может приводить к непредвиденным результатам.

| Транзакция 1| Транзакция 2 |
| ---| --- |
| | SELECT f2 FROM tbl1 WHERE f1=1; |
| UPDATE tbl1 SET f2=f2+1 WHERE f1=1; | |
| | SELECT f2 FROM tbl1 WHERE f1=1; |
| ROLLBACK WORK; | |

Dirty Read можно предотвратить, используя следующие уровни изоляции:

+ `TRANSACTION_READ_COMMITTED`
+ `TRANSACTION_REPEATABLE_READ`
+ `TRANSACTION_SERIALIZABLE`

[к оглавлению](#SQL)

## 61. Какие есть две фазы commit?

Когда мы работаем в распределенных системах, где участвуют несколько баз данных, мы должны использовать
протокол с двумя фазами фиксации. 2х-фазовый протокол фиксации является атомарным протоколом для распределенных систем.

На первом этапе, менеджер транзакций передает `commit-request` всем ресурсам транзакции.

Если все ресурсы транзакции ответили Оk, то менеджер транзакций фиксирует изменения транзакций для всех ресурсов.

Если какой-либо из ресурсов транзакций уведомляет об отмене, то менеджер транзакций может откатить все изменения транзакций.

[к оглавлению](#SQL)

## 62. Приведите пример различных типов блокировки в JDBC?

На более широком уровне есть два типа механизма блокировки для предотвращения повреждения данных из-за одновременной
работы с данными несколькими пользователями. По логике реализации различают два вида блокировок.

**Оптимистическая блокировка** — не ограничивает модификацию обрабатываемых данных сторонними сессиями,
однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк
данных (обычно используется наименование `VERSION` и целочисленный тип с инициальным значением 0).
Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось,
то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута
не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута
(например, инкрементом) для сигнализации другим сессиям о том, что данные изменились.

**Пессимистическая блокировка** — накладывается перед предполагаемой модификацией данных на все строки,
которые такая модификация предположительно затрагивает. Всё время действия такой блокировки исключена модификация данных
из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции.
По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.

[к оглавлению](#SQL)

## 63. Как вставить изображение или необработанные данные в базу данных?

Для этого можно использовать тип данных `BLOB`, чтобы вставить картинку или двоичные данные в базу данных.

[к оглавлению](#SQL)

## 64. Что вы можете рассказать о фантомном чтении Какой уровень изоляции его предотвращает?

Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.
Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

| Транзакция 1| Транзакция 2 |
| ---| --- |
| | SELECT SUM(f2) FROM tbl1; |
| INSERT INTO tbl1 (f1,f2) VALUES (15,20); | |
|  COMMIT; | |
| | SELECT SUM(f2) FROM tbl1; |

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка
новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат.
Такая ситуация называется фантомным чтением. От неповторяющегося чтения оно отличается тем, что результат повторного
обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.
Phantom read можно предотвратить только на уровне изоляции — `TRANSACTION_SERIALIZABLE`.

[к оглавлению](#SQL)

## 65. Что такое SQL Warning Как возвратить SQL предупреждения в JDBC программе?

**SQLWarning** - это подкласс `SQLException`, который мы можем получить вызвав метод `getWarnings()` у объектов
`Connection`, `Statement`, `ResultSet`. SQL Предупреждения не останавливает выполнение запроса, но показывает
предупреждающие сообщения для пользователя.

[к оглавлению](#SQL)

## 66. Как запустить Oracle Stored Procedure с объектами базы данных INOUT?

Если хранимая процедура Oracle содержит `IN` / `OUT` параметры как DB объекты, то мы должны создать массив объектов
такого же размера в программе, а затем использовать его для создания Oracle STRUCT объекта. Тогда мы можем установить
этот `STRUCT` объект в объект базы данных, вызвав метод `setSTRUCT()`.

[к оглавлению](#SQL)

## 67. Приведите пример возникновения javasqlSQLException No suitable driver found?

Исключение `java.sql.SQLException: No suitable driver found` может быть вызвано, например, неправильно отформатированной
строкой SQL-адреса. Вы можете получить это исключение в простом Java приложении как через `DriverManager`,
так и используя JNDI DataSource.

Трассировка стека исключений приведена ниже:

```java
org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot create JDBC driver of class 'com.mysql.jdbc.Driver' for connect URL ''jdbc:mysql://localhost:3306/UserDB'
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1452)
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371)
    at org.apache.tomcat.dbcp.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)
 
 
java.sql.SQLException: No suitable driver found for 'jdbc:mysql://localhost:3306/UserDB
    at java.sql.DriverManager.getConnection(DriverManager.java:604)
    at java.sql.DriverManager.getConnection(DriverManager.java:221)
    at com.journaldev.jdbc.DBConnection.getConnection(DBConnection.java:24)
    at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:15)
Exception in thread "main" java.lang.NullPointerException
```

[к оглавлению](#SQL)

## 68. Некоторые Best Practices в JDBC?

Некоторые Best Practices в JDBC:

+ Всегда закрывайте ресурсы базы данных сразу после работы с ними. `Connection`, `Statement`, `ResultSet` и другие
  JDBC объекты имеют метод `close()`, который позволяет закрыть их.

+ Всегда явно закрывайте результирующий набор `ResultSet`, `Statement` и `Connection` в коде, потому что если вы
  используете пул соединений, то соединение может быть возвращено в пул, оставляя открытые `result sets` и
  `statement objects` и будет происходить утечка.

+ Закрывайте ресурсы в конце `finally` блока, чтобы убедиться, что они закрыты даже в случае возникновения исключения.

+ Используйте пакетную обработку (`batch processing`) для повторяющихся запросов.

+ Всегда используйте `PreparedStatement` вместо `Statement`, чтобы избежать SQL Injection и получить преимущества заранее
  прекомпилированного и кэшированного запроса `PreparedStatement`.

+ Если вы извлекаете большие массивы данных в `ResultSet`, то заранее установите оптимальное значение `fetchSize`,
  что поможет получить лучшую производительность.

+ Сервер базы данных может не поддерживать все уровни изоляции, так что проверьте их заранее.

+ Более строгие уровни изоляции могут привести к снижению производительности, поэтому убедитесь, что вы используете
  оптимальный набор уровней изоляции для ваших соединений с базой данных.

+ Если вы создаете подключения к базе данных из веб-приложения, попробуйте использовать ресурсы JDBC DataSource с помощью
  применения контекста JNDI для возможности повторного использования соединений.

+ Попробуйте использовать отключенный (disconnected) `RowSet`, когда вам нужно работать с `ResultSet` в течение
  длительного времени.

[к оглавлению](#SQL)

## 69. Для чего используется конструкция try-with-resources?

Данная конструкция(`try-with-resources`) появилась в java 7,
она позволяет использовать блок `try-catch` не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally` в которой
и происходит закрытие без участия разработчика. Конструкция является так называемым «синтаксическим сахаром»
и создана для облегчения жизни программиста.
Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`.

Общий вид конструкции выглядит следующим образом:

```java
try(тут объявляются ресурсы) {
    ...
    ...
} catch (Exception ex) {
    ...
} finally {
    ...
}
```

**ВНИМАНИЕ**, блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finnaly`.

[к оглавлению](#SQL)
