## Git

[1. Что такое индекс?](#1-Что-такое-индекс)

[2. Как добавить изменения в индекс? (git add .)](#2-Как-добавить-изменения-в-индекс-git-add-)

[3. Как сделать фиксацию изменений? (git commit -m "text")](#3-Как-сделать-фиксацию-изменений-git-commit--m-text)

[4. Как сделать синхронизацию изменений с удаленным репозиторием? (git push origin master)](#4-Как-сделать-синхронизацию-изменений-с-удаленным-репозиторием-git-push-origin-master)

[5. Как синхронизироваться с удаленным репозиторием? (git pull origin master)](#5-Как-синхронизироваться-с-удаленным-репозиторием-git-pull-origin-master)

[6. Как сделать ветку?](#6-Как-сделать-ветку)

[7. Как переключиться между ветками?](#7-Как-переключиться-между-ветками)

[8. Как отменить локальные изменения?](#8-Как-отменить-локальные-изменения)

[9. Расскажи о команде git reset?](#9-Расскажи-о-команде-git-reset)

[10. Расскажите о команде git stash](#10-Расскажите-о-команде-git-stash)

[11. Расскажите о команде git cherry-pick](#11-Расскажите-о-команде-git-cherry-pick)

[12. Расскажите, о команде git rerere. Расскажите, как разрешаются конфликты.](#12-Расскажите-о-команде-git-rerere-Расскажите-как-разрешаются-конфликты)

## 1. Что такое индекс?

Индекс — промежуточное место между вашим прошлым коммитом и следующим. Вы можете добавлять или удалять файлы из индекса. 
Когда вы делаете коммит в него попадают данные из индекса, а не из рабочей области.

Что бы просмотреть индекс, используйте `git status`.

[к оглавлению](#git)

## 2. Как добавить изменения в индекс? (git add .)

Что бы добавить файлы в индекс используйте

`git add [<опции>]`

Полезные параметры команды git add:
+ -f, --force — добавить также игнорируемые файлы
+ -u, --update — обновить отслеживаемые файлы

С помощью git status вы можете посмотреть какие файлы изменились, но если вы также хотите узнать что именно изменилось в 
файлах то воспользуйтесь командой:

`git diff [<options>]`

Таким образом выполнив команду без аргументов вы можете сравнить ваш индекс с рабочей директорией. Если вы уже добавил в 
индекс файлы, то используйте git diff --cached что бы посмотреть различия между последним коммитом (или тем который вы
укажите) и рабочей директории.

[к оглавлению](#git)

## 3. Как сделать фиксацию изменений? (git commit -m "text")

Все файлы для которых вы не выполнили git add после момента редактирования — не войдут в этот коммит. На деле файлы в
нём будут, но только их старая версия (если таковая имеется).

Для того что бы сделать коммит ваших изменений используйте:

`git commit [<опции>]`

Полезные опции команды git commit:

+ -F, --file [file] — Записать сообщение коммита из указанного файла
+ --author [author] — Подменить автора коммита
+ --date [date] — Подменить дату коммита
+ -m, --mesage [message] — Сообщение коммита
+ -a, --all — Закоммитеть все изменения в файлах
+ -i, --include [files...] — Добавить в индекс указанные файлы для следующего коммита
+ -o, --only [files...] — Закоммитеть только указанные файлы
+ --amend — Перезаписать предыдущий коммит

Вы можете определить сообщение для коммита по умолчанию с помощью commit.template. Эта директива в конфигурационном 
файле отвечает за файл содержимое которого будет использоваться для коммита по умолчанию. Пример: 
`git config --global commit.template ~/.gitmessage.txt.`

Вы также можете изменить, удалить, объединить любой коммит.

Как вы уже могли заметить вы можете быстро перезаписать последний коммит с помощью git commit --amend.
Для изменения коммитом в вашей истории используйте

`git rebase -i <commit>`

где commit это верхний коммит в вашей цепочке с которого вы бы хотели что либо изменить.

После выполнения git rebase -i в интерактивном меню выберите что вы хотите сделать.

+ pick <коммит> = использовать коммит
+ reword <коммит> = использовать коммит, но изменить сообщение коммита
+ edit <коммит> = использовать коммит, но остановиться для исправления
+ squash <коммит> = использовать коммит, но объединить с предыдущим коммитом
+ fixup <коммит> = как «squash», но пропустить сообщение коммита
+ exec <команда> = выполнить команду (остаток строки) с помощью командной оболочки
+ break = остановиться здесь (продолжить с помощью «git rebase --continue»)
+ drop <коммит> = удалить коммит
+ label <метка> = дать имя текущему HEAD
+ reset <метка> = сбросить HEAD к указанной метке

[к оглавлению](#git)

## 4. Как сделать синхронизацию изменений с удаленным репозиторием? (git push origin master)

Для отправки данных на сервер используйте

`git push [<rep>] [<br>]`

где rep это название внешнего репозитория, а br локальная ветка которую вы хотите отправить. Также вы можете использовать
такую запись git push origin master:dev. Таким образом вы выгрузите вашу локальную ветку master на origin (но там она 
будет называется dev). Вы не сможете отправить данные во внешний репозитории если у вас нет на это прав. Также вы не 
сможете отправить данные на внешнюю ветку если она опережает вашу (в общем то отправить вы можете используя -f, --forse
в этом случае вы перепишите историю на внешнем репозитории). Вы можете не указывать название ветки если ваша ветка 
отслеживает внешнюю.

Для удаления внешних веток используйте

`git push origin --delete branch_name`

[к оглавлению](#git)

## 5. Как синхронизироваться с удаленным репозиторием? (git pull origin master)

Так как git это распределённая СКВ вы можете работать не только с локальными, но и с внешними репозиториями.

Удалённые репозитории представляют собой версии вашего проекта, сохранённые на внешнем сервере.

Для работы с внешними репозиториями используйте:

`git remote [<options>]`

Если вы клонировали репозитории через http URL, то у вас уже имеется ссылка на внешний. В другом случае вы можете 
добавить её с помощью

`git remote add [<options>] <name> <adres>`

Вы можете тут же извлечь внешние ветки с помощью `-f`, `--fetch` (вы получите имена и состояние веток внешнего репозитория).
Вы можете настроить репозитории только на отправку или получение данных с помощью `--mirror[=(push|fetch)]`. Для
получения меток укажите `--tags`.

Для просмотра подключённых внешних репозиториев используйте git remote без аргументов или git remote -v для просмотра 
адресов на отправку и получение данных от репозитория.

Для отслеживания веток используйте git branch -u <rep/br> где rep это название репозитория, br название внешней ветки, а
branch название локальной ветки. Либо git branch --set-upstream local_br origin/br для того что бы указать какая именно
локальная ветка будет отслеживать внешнюю ветку.

Когда ваша ветка отслеживает внешнюю вы можете узнать какая ветка (локальная или внешняя) отстаёт или опережает и на 
сколько коммитов. К примеру если после коммита вы не выполняли git push то ваша ветка будет опережать внешнюю на 1 
коммит. Вы можете узнать об этом выполнив `git branch -vv`, но прежде выполните `git fetch [remote-name]` (--all для 
получения обновления со всех репозиториев) что бы получить актуальные данные из внешнего репозитория. Для отмены 
отслеживания ветки используйте `git branch --unset-upstream [<local_branch>]`.

Для загрузки данных с внешнего репозитория используйте `git pull [rep] [branch]`. Если ваши ветки отслеживают внешние, то 
можете не указывать их при выполнении `git pull`. По умолчанию вы получите данные со всех отслеживаемых веток.

Для загрузки веток на новую ветку используйте `git checkout -b <new_branch_name> <rep/branch>`.

[к оглавлению](#git)

## 6. Как сделать ветку?

Для создания ветки используйте:

`git branch <branch_name> [<start_commit>]`

Здесь branch_name это название для новой ветки, а start_commit это коммит на который будет указывать ветка (то есть 
последний коммит в ней). По умолчанию ветка будет находиться на последнем коммите родительской ветки.

Опции git branch:

+ `-r | -a [--merged | --no-merged]` — Список отслеживаемых внешних веток -r. Список и отслеживаемых и локальных веток -a. Список слитых веток --merged. Список не слитых веток --no-merged.
+ `-l, -f <имя-ветки> [<точка-начала>]` — Список имён веток -l. Принудительное создание, перемещение или удаление ветки -f. Создание новой ветки <имя ветки>.
+ `-r (-d | -D)` — Выполнить действие на отслеживаемой внешней ветке -r. Удалить слитую ветку -d. Принудительное удаление (даже не слитой ветки) -D.
+ `-m | -M [<Старая ветка>] <Новая ветка>` — Переместить/переименовать ветки и ее журнал ссылок (-m). Переместить/переименовать ветку, даже если целевое имя уже существует -M.
+ `(-с | -С) [<старая-ветка>] <новая-ветка>` — Скопировать ветку и её журнал ссылок -c. Скопировать ветку, даже если целевое имя уже существует -C.
+ `-v`, `-vv` — Список веток с последним коммитом на ветке -v. Список и состояние отслеживаемых веток с последним коммитом на них.

[к оглавлению](#git)

## 7. Как переключиться между ветками?

Для переключения на ветку используйте `git checkout` . Также вы можете создать ветку выполнив `git checkout -b <ветка>`.

[к оглавлению](#git)

## 8. Как отменить локальные изменения?

Что бы удалить файлы из индекса вы можете использовать 2 команды git reset и git restore.

`git-restore` — восстановит файлы рабочего дерева.

`git-reset` — сбрасывает текущий HEAD до указанного состояния.

По сути вы можете добиться одного и того же с помощью обеих команд. Разработчики рекомендуют для сброса индекса
использовать именно `git restore -S`. Вместо `git reset HEAD`.

[к оглавлению](#git)

## 9. Расскажи о команде git reset?

Что бы удалить из индекса некоторые файлы используйте:

`git restore --staged <file>`

таким образом вы восстановите ваш индекс (или точнее удалите конкретные файлы из индекса), будто бы git add после
последнего коммита не выполнялся для них. С помощью этой команды вы можете восстановить и рабочую директорию, что бы она
выглядела так, будто бы после коммита не выполнялось никаких изменений. Вот только эта команда имеет немного странное
поведение — если вы добавили в индекс новую версию вашего файла вы не можете изменить вашу рабочую директорию, пока 
индекс отличается от HEAD. Поэтому вам сначала нужно восстановить ваш индекс и только потом рабочую директорию. К 
сожалению сделать это одной командой не возможно так как при передаче обеих аргументов (git restore -SW) не происходит
ничего. И точно также при передаче -W тоже ничего не произойдет если файл в индексе и HEAD разный. Наверное, это сделали
для защиты что бы вы случайно не изменили вашу рабочую директорию. Но в таком случае почему аргумент -W передаётся по 
умолчанию? В общем мне не понятно зачем было так сделано и для чего вообще была добавлена эта команда. По мне так reset 
справляется с этой задачей намного лучше, да и еще и имеет более богатый функционал так как может перемещать индекс и 
рабочую директорию не только на последний коммит но и на любой другой.

Но собственно разработчики рекомендуют для сброса индекса использовать именно `git restore -S`. Вместо `git reset HEAD`.

[к оглавлению](#git)

## 10. Расскажите о команде git stash

git stash — одна из самых восхитительных и полезных Git-команд. Она регистрирует все изменения, вносимые в отслеживаемый 
файл в вашем рабочем дереве, и скрывает их для последующего использования, а вам показывает чистое дерево, чтобы вы 
могли спокойно работать с другой его частью. Но если вы создали новые файлы и ещё не проиндексировали их, то по 
умолчанию git stash их не тронет, поэтому у вас будет неопрятное рабочее дерево. Соответственно, по умолчанию не 
скрывается и содержимое неотслеживаемых или игнорируемых файлов.

Я сделал несколько удобных алиасов для разных вариантов git stash, в зависимости от того, какие биты вашего рабочего 
дерева нужно скрыть:

+ `git stsh` скрывает только непроиндексированные изменения в отслеживаемых файлах
+ `git stash` скрывает все изменения в отслеживаемых файлах
+ `git staash` скрывает неотслеживаемые и отслеживаемые файлы
+ `git staaash` скрывает игнорируемые, неотслеживаемые и отслеживаемые файлы`

Если сомневаетесь в выборе, то самый длинный алиас (git staaash) всегда сможет восстановить рабочее дерево состояния 
свежего клона вашего репозитория.

[к оглавлению](#git)

## 11. Расскажите о команде git cherry-pick

Команда git cherry-pick создаёт новый коммит с идентичным отличием от <oid>, родитель которого — текущий коммит. Git в 
сущности выполняет такие шаги:

1. Вычисляет разницу между <oid> коммита и его родителя.
2. Применяет различие к текущему HEAD.
3. Создаёт новый коммит, корневое дерево которого соответствует новому рабочему каталогу, а родитель созданного коммита — HEAD.
4. Перемещает ссылку HEAD в этот новый коммит.

После создания нового коммита вывод git log -1 -p HEAD должен совпадать с выводом git log -1 -p <oid>.

Важно понимать, что мы не "перемещали" коммит так, чтобы он был поверх нашего текущего HEAD, мы создали новый коммит, и
его вывод diff совпадает со старым коммитом.

[к оглавлению](#git)

## 12. Расскажите, о команде git rerere. Расскажите, как разрешаются конфликты.

Rerere — «reuse recorded resolution” — “повторное использование сохраненных разрешений конфликтов». Механизм rerere
способен запомнить каким образом вы разрешали некую часть конфликта в прошлом и провести автоматическое исправление
конфликта при возникновении его в следующий раз.

Что бы включить rerere выполните

`git config --global rerere.enabled true`

Также вы можете включить rerere создав каталог .git/rr-cache в нужном репозитории.

Используйте git rerere status для того что бы посмотреть для каких файлов rerere сохранил снимки состояния до начала 
слияния.

Используйте git rerere diff для просмотра текущего состояния конфликта.

Если во время слияния написано: Resolved 'nameFile' using previous resolution. Значит rerere уже устранил конфликт
используя кэш.

Для отмены автоматического устранения конфликта используйте git checkout --conflict=merge таким образом вы отмените авто
устранение конфликта и вернёте файл(ы) в состояние конфликта для ручного устранения.

[к оглавлению](#git)