## IO

[1. Что такое поток ввода-вывода?](#1-Что-такое-поток-вводавывода)

[2. Что такое Java IO?](#2-Что-такое-java-io)

[3. Что такое Java NIO?](#3-Что-такое-java-nio)

[4. Что такое NIO.2?](#4-Что-такое-nio2)

[5. Что такое Scanner?](#5-Что-такое-scanner)

[6. Как работает Scanner внутри?](#6-Как-работает-scanner-внутри)

[7. Какие базовые методы существуют в Scanner?](#7-Какие-базовые-методы-существуют-в-scanner)

[8. Что такое байтовый поток? Как он реализован внутри?](#8-Что-такое-байтовый-поток-Как-он-реализован-внутри)

[9. Что такое символьный поток? Как он реализован внутри?](#9-Что-такое-символьный-поток-Как-он-реализован-внутри)

[10. Что такое буферизированный поток?](#10-Что-такое-буферизированный-поток)

[11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?](#11-Какие-классы-обертки-позволяют-ускорить-чтениезапись-за-счет-использование-буфера)

[12. Как осуществляется ввод и вывод из командной строки?](#12-Как-осуществляется-ввод-и-вывод-из-командной-строки)

[13. Что такое класс Console? Расскажите его АПИ.](#13-Что-такое-класс-console-Расскажите-его-АПИ)

[14. Что такое поток данных? Data stream.](#14-Что-такое-поток-данных-data-stream)

[15. Что такое поток объектов, Object stream.](#15-Что-такое-поток-объектов-object-stream)

[16. Что такое Path? Как он реализуется на разных ОС?](#16-Что-такое-path-как-он-реализуется-на-разных-ОС)

[17. Как получить список файлов?](#17-Как-получить-список-файлов)

[18. Как проверить что файловая сущность является файлом или папкой?](#18-Как-проверить-что-файловая-сущность-является-файлом-или-папкой)

[19. Как удалить файл?](#19-Как-удалить-файл)

[20. Как переместить файл?](#20-Как-переместить-файл)

[21. Как управлять аттрибутами файла?](#21-Как-управлять-аттрибутами-файла)

[22. Как создать файл?](#22-Как-создать-файл)

[23. Как создать директорию?](#23-Как-создать-директорию)

[24. Как записать в файл?](#24-Как-записать-в-файл)

[25. Как прочитать данные из файла?](#25-Как-прочитать-данные-из-файла)

[26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?](#26-Для-чего-нужны-классы-printstream-и-printwriter-В-чем-их-различие)

[27. Что такое потоки байтовых массивов? Как они устроены?](#27-Что-такое-потоки-байтовых-массивов-Как-они-устроены)

[28. Зачем нужен класс RandomAccessFile?](#28-Зачем-нужен-класс-RandomAccessFile)

[29. Данные в каком виде можно считывать байтовыми и символьными потоками?](#29-Данные-в-каком-виде-можно-считывать-байтовыми-и-символьными-потоками)

[30. Что такое сокет?](#30-Что-такое-сокет)

[31. Какие виды сокетов есть в Java? С каким протоколом они работают?](#31-Какие-виды-сокетов-есть-в-java-С-каким-протоколом-они-работают)

[32. Как отправить через сокет сообщение?](#32-Как-отправить-через-сокет-сообщение)

[33. Что такое логирование?](#33-Что-такое-логирование)

[34. Какие уровни логирования вы знаете?](#34-Какие-уровни-логирования-вы-знаете)

[35. Какая библиотека для логгирования используется в курсе? Как ее настроить?](#35-Какая-библиотека-для-логгирования-используется-в-курсе-Как-её-настроить)

[36. Опишите из каких элементов состоит формат JSON?](#36-Опишите-из-каких-элементов-состоит-формат-json)

[37. Как преобразовать POJO в/из json?](#37-Как-преобразовать-pojo-виз-json)

[38. Опишите из каких элементов состоит формат XML?](#38-Опишите-из-каких-элементов-состоит-формат-xml)

[39. Как преобразовать POJO в/из xml?](#39-Как-преобразовать-pojo-виз-xml)

[40. Что такое сериализация / десериализация?](#40-Что-такое-сериализация--десериализация)

[41. Что такое регулярные выражения? Зачем они нужны?](#41-Что-такое-регулярное-выражение-Зачем-они-нужны)

[42. Как создать регулярное выражение в Java?](#42-Как-создать-регулярное-выражение-в-java)

[43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?](#43-Что-такое-метасимволы-Для-чего-они-применяются-в-регулярных-выражениях)

## 1. Что такое поток ввода-вывода?

Объект, из которого можно считать данные, называется **потоком ввода**, а объект, в который можно записывать данные - 
**потоком вывода**. Например, если надо считать содержание файла, то применяется поток ввода, а если надо записать в 
файл - поток вывода.

В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: **InputStream** (представляющий 
потоки ввода) и **OutputStream** (представляющий потоки вывода). Но поскольку работать с байтами не очень удобно, то для
работы с потоками символов были добавлены абстрактные классы **Reader** (для считывания потоков символов) и **Writer** (для
записи потоков символов). Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов.

[к оглавлению](#io)

## 2. Что такое Java IO?

IO API – (Input & Output) в первую очередь это Java API, которые облегчают работу с потоками.
В `java.io` существуют так называемые потоки ввода и вывода (`InputStream` и `OutputStream`).

В основном `java.io` предназначен для чтения и записи данных в ресурс:

1. файл
2. при работе с сетевым подключением
3. `System.err`, `System.in`, `System.out`
4. при работе с буфером

**Классы Java IO API**

**Базовые**

+ `InputStream` /` OutputStream` - абстрактные классы, определяющие байтовый поток ввода/вывода
+ `Reader` / `Writer` - абстрактные классы, определяющие символьный поток ввода/вывода
+ `InputStreamReader` / `OutputStreamWriter` Входной/выходной потоки, транслирующий байты в символы/символы в байты

**Массивы**
+ `ByteArrayInputStream` / `ByteArrayOutputStream` - позволяет использовать буфер в памяти (массив байтов) в качестве 
  источника данных для входного потока / все данные, посылаемые в этот поток, размещаются в предварительно созданном 
  буфере.
+ `CharArrayReader` / `CharArrayWriter` - читает/пишет из символьного массива.

**Files**
+ `FileInputStream` / `FileOutputStream` - Чтение/Запись данных побайтово в файл на диске.
+  `RandomAccessFile` - Чтение/Запись файлов с произвольным доступом. метод `seek()` позволяет переместиться к 
   определенной позиции и изменить хранящееся там значение. При использовании RandomAccessFile необходимо знать 
   структуру файла. Класс `RandomAccessFile` содержит методы для чтения и записи примитивов и строк UTF-8.
  `RandomAccessFile` может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также есть режим "rws", когда файл
  открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.
+ `FileReader` / `FileWriter` - входной/выходной потоки, читающий/записывающий в файл.

**Буферизация**
+ `BufferedInputStream` / `BufferedOutputStream` - буферизируемые байтовые потоки. Нужны для повышения производительности.
+ `BufferedReader` / `BufferedWriter` - буферизируемые символьные потоки. Нужны для повышения производительности.

[к оглавлению](#io)

## 3. Что такое Java NIO?

Пакет `java.nio` был представлен в Java 1.4. В отличие от **java I/O** в **java NIO** введен поток данных, 
ориентированный на буфер и канал, для операций ввода/вывода, что в результате обеспечивает более быстрое выполнение и 
лучшую производительность.

Также **NIO API** предлагает селекторы, которые вводят функциональность прослушивания нескольких каналов для событий
ввода-вывода асинхронным или неблокирующим способом. В NIO наиболее трудоемкие операции ввода-вывода, включая заполнение
и опустошение буферов для операционной системы, которые увеличиваются в скорости.

Основные абстракции API-интерфейсов NIO следующие:

+ Буферы, которые являются контейнерами для данных, набором символов и связанных с ними декодеров и кодеров, которые 
преобразуются между байтами и символами Unicode.
  
+ Каналы различных типов, которые представляют соединения с объектами, способными выполнять операции ввода-вывода

+ Селекторы и клавиши выбора, которые вместе с выбираемыми каналами определяют мультиплексированный неблокирующий 
  механизм ввода/вывода.
  
[к оглавлению](#io)

## 4. Что такое NIO.2?

В Java 7 система ввода-вывода NIO была значительно расширена (данное обновление также называют NIO.2). Были добавлены 
несколько пакетов и классов, направленных на расширение возможностей применения системы ввода-вывода NIO. Отдельно можно 
выделить пакет java.nio.file, его интерфейс Path и классы Paths, Files, которые расширяют возможности манипуляции с 
файлами (файловый ввод-вывод).

[к оглавлению](#io)

## 5. Что такое Scanner?

Исходя из названия класса «Scanner», можно догадаться, что этот класс имеет смысл использовать для «сканирования» 
источника данных. Под сканированием подразумевается нахождение последовательности символов среди данных источника. 
Формально говоря, последовательность символов называется токеном или лексемой, а процесс сканирования лексическим 
анализом.

Класс `Scanner` можно применять для чтения данных, вводимых с консоли, из файла, символьной строки или из другого 
источника, реализующего интерфейс `Readable` или `ReadableByteChannel`. Например, класс `Scanner` можно использовать для
чтения числа с клавиатуры и присвоения его значения переменной.

[к оглавлению](#io)

## 6. Как работает Scanner внутри?

Как только объект типа `Scanner` будет создан, его очень просто использовать для чтения отформатированных вводимых данных.
Объект типа `Scanner` читает лексемы из некоторого базового источника, указываемого при создании этого объекта. С точки 
зрения класса `Scanner` *лексема* - это порция вводимых данных, разграничиваемая рядом разделителей, которыми по 
умолчанию являются пробелы. Лексема читается по совпадению с конкретным *регулярным выражением*, задающим формат данных.
В составе этого класса входит немало предопределенных шаблоном для сопоставления с элементарными типами данных вроде `int`
и `double`, а также символьными строками. 

Токенами (лексемой) могут быть примитивы, строки (в значении с англ. line), символьные выражения, соответствующие регулярному
выражению и т.п.. В общем все, что может быть представлено в виде последовательности символов.

Для выделения последовательности символов необходимо знать шаблон, по которому их нужно выделять. В общем случае, это
регулярное выражение. Однако, регулярные выражения трудно читаемы, если у Вас мало навыков работы с ними. В этом случае
нам на помощь приходит Scanner, который поддерживает большинство шаблонов, например, по поиску примитивов. Тем не менее,
шаблон есть всегда. Если мы его не задаем, он задается внутри Scanner.

[к оглавлению](#io)

## 7. Какие базовые методы существуют в Scanner?

В классе `Scanner` определяются два ряда методов, которые позволяют читать вводимые данные. 

К первому ряду относятся методы типа `hasNextX`. Эти методы определяют, доступен ли указанный тип ввода. Например, в 
результате вызова метода`hasNextInt()` возвращается логическое значение `true` только в том случае, если следующая 
читаемая лексема оказывается целым числом.

Если же требуемые данные доступны, они читаются одним из методом типа `nextX`. Например, чтобы прочитать следующее целое
число, следует вызвать метод `nextInt()`. 

Чтобы определить, где начинаются и оканчиваются лексемы, в классе `Scanner` применяются *разделители*. По умолчанию в 
качестве разделителей выбираются пробельные символы. Но тип разделителей можно изменить, вызвав метод `useDelimiters()`.

Текущий шаблон разделителей можно получить, вызвав метод `delimiter()`.

`findInLine()` - этот метод осуществляет поиск на совпадение с указанным шаблоном в следующей строке текста. Если
совпадение обнаружено, то соответствующая этому шаблону лексема употребляется и возвращается. В противном случае 
возвращается `null`. 

`findWithinHorizon()` - этот метод пытается обнаружить совпадение с указанным шаблоном в последующем `количестве` 
символов. При удачном исходе метода возвращает результат совпадения с заданным *шаблоном*, а иначе - пустое значение 
`null`. Если параметр *количество* принимает нулевое значение, поиск осуществляется во всех вводимых данных до тех пор, 
пока не будет обнаружено совпадение или достигнут конец вводимых данных.

`skip()` - если обнаружено совпадение с заданным шаблоном, метод просто пропускает его и возвращает ссылку на вызывающий 
объект. Если же совпадение с шаблоном не обнаружено, метод `skip()` генерирует исключение.

[к оглавлению](#io)

## 8. Что такое байтовый поток? Как он реализован внутри?

1) Байтовый поток в Java - классы во главе иерархии это InputStream/OutputStream.
2) В потоке можно прочитать или записать один или несколько байтов.
3) Внутри есть абстрактный метод read() / write(int b), для чтения/записи одного байта. Реализация этого метода и 
   определяет фактическую реализацию потока.
4) Также есть метод read(byte[] buf) / write(byte[] buf) для записи сразу массива байтов.

[к оглавлению](#io)

## 9. Что такое символьный поток? Как он реализован внутри?

1) Символьный поток в Java - классы во главе иерархии это Reader/Writer.
2) В потоке можно прочитать или записать один или несколько символов (char, 2 байта).
3) Внутри есть один абстрактный метод:
   read(char[] cbuf, int off, int len) или
   write(char cbuf[], int off, int len)
   Реализация этого метода и определяет фактическую реализацию работы объекта.
4) Также дополнительно есть метод read() / write(int c) для чтения/записи одного символа или write(String) для записи 
   строки (набора символов).

[к оглавлению](#io)

## 10. Что такое буферизированный поток?

Для оптимизации операций ввода-вывода используются буферизуемые потоки. Эти потоки добавляют к стандартным специальный
буфер в памяти, с помощью которого повышается производительность при чтении и записи потоков.
`BufferedInputStream` и `BufferedOutputStream` байтовые / `BufferedReader` и `BufferedWriter` символьные.
Это может сделать программу намного эффективней, т.к. каждый такой запрос часто инициировал доступ к диску, сетевое
действие, или некоторую другую работу, которая относительно дорога.

[к оглавлению](#io)

## 11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?

Класс `BufferedInputStream` позволяет заключить в обёртку любой поток ввода типа `InputStream` и добиться повышения 
производительности. У класса `BufferedInputStream` имеются два конструктора:

`BufferedInputStream(InputStream поток_ввода)`
`BufferedInputStream(InputStream поток_ввода, int размер_буфера)`

В первом конструкторе создается буферизованный поток ввода, использующий размер буфера по умолчанию. Во втором
конструкторе задается конкретный `размер_буфера`. Рекомендуется указывать размер буфера, кратный размеру страницы 
памяти, дисковому блок и т.п. Это окажет существенное положительное влияние на производительность. Оптимальный 
установить для потока ввода буфер размером 8192 байт или меньше. Таким образом, низкоуровневая система сможет читать 
блоки данных с диска или из сети и сохранять результат в установленном буфере. И даже если данные читаются байтами из 
потока ввода типа `InputStream`, то на практике придется, оперировать быстродействующей памятью.

Буферизация потока ввода служит также основанием для поддержки операции перемещения назад в потоке, имеющем свой буфер.
Помимо методов `read()` и `skip()`, реализуемых в любом из классов `InputStream` и `BufferedInputStream`, поддерживаются
также методы `mark()` и `reset()`. 

---

Класс `BufferedOutputStream` подобен любому классу `OutputStream`, за исключением дополнительного метода `flush()`,
обеспечивающего запись данных в буферизованный поток вывода. Класс `BufferedOutputStream` предназначен для повышения
производительности за счет сокращения количества операций записи данных, фактически выполняемых системой, и поэтому может
возникнуть потребность вызвать метод `flush()`, чтобы инициировать немедленный вывод всех данных из буфера.

В отличие от буферизованного ввода, буферизованный вывод не обеспечивает дополнительные функциональные возможности. 
Буферы вывода в Java требуются для повышения производительности. Ниже приведены два конструктора класса:

`BufferedOutputStream(OutputStream поток_вывода)`
`BufferedOutputStream(OutputStream поток_вывода, int размер_буфера)`

В первом конструкторе создается буферизованный поток вывода с использованием буфера, размер которого выбирается по 
умолчанию. А во второй форме конструктора задается конкретный _размер_буфера_. 

---

И их аналоги с символьными потоками:
`BufferedReader`
`BufferedWriter`

[к оглавлению](#io)

## 12. Как осуществляется ввод и вывод из командной строки?

Класс `System` содержит также три переменные предопределенных потоков ввода-вывода: `in`, `out` и `err`
+ Переменная `System.out` ссылается на стандартный поток вывода. По умолчанию это консоль.
+ Переменная `System.in` ссылается на стандартный поток ввода, которым по умолчанию является клавиатура.
+ `System.err` - для ошибок.

**Перенаправление стандартного ввода-вывода**

Класс `System` позволяет вам перенаправить стандартный ввод, вывод и поток ошибок. Для этого используются простые 
статические методы:

+ `setIn(InputStream)`
+ `setOut(PrintStream)`
+ `setErr(PrintStream)`

Перенаправление стандартного вывода особенно полезно тогда, когда ваша программа выдает слишком много сообщений сразу, и
вы попросту не успеваете читать их, поскольку они заменяются новыми сообщениями. Перенаправление ввода удобно для 
программ, работающих с командной строкой, в которых необходимо поддержать некоторую последовательность введенных 
пользователем данных.

[к оглавлению](#io)

## 13. Что такое класс Console? Расскажите его АПИ.

Класс `Console` служит для ввода-вывода данных на консоль, если таковая имеется, и реализует интерфейс `Flushable`. 
Класс `Console` является служебным, поскольку он функционирует в основном через стандартные потоки ввода-вывода
`System.in` и `System.out`. Тем не менее он упрощает некоторые виды консольных операций, особенно при чтении символьных
операций, особенно при чтении символьных строк с консоли.

Конструкторы в классе `Console` не предоставляются. Для создания экземпляра используется `System.console()`. Метод
может вернуть `null`, если консоль недоступна. Консоль позволяет вводить пароль используя метод `readPassword` (не
видны символы при вводе, не сохраняется в памяти).

+ `flush()` выводит на консоль все данные из буфера.
+ `format()` выводит на консоль строку с использованием форматирования.
+ `printf()` выводит на консоль строку с использованием форматирования (фактически то же самое, что и предыдущий метод)
+ `String readLine()` считывает с консоли введенную пользователем строку.
+ `char[] readPassword()` считывает с консоли введенную пользователем строку,
  при этом символы строки не отображаются на консоли.

Важно, что доступ к консоли мы можем получить только из самой консоли. При запуске, например, в Netbeans вызов 
System.console() будет возвращать значение null. Поэтому при работе с консолью желательно проверять полученное значение
на null.

[к оглавлению](#io)

## 14. Что такое поток данных? Data stream.

Классы `DataOutputStream` и `DataInputStream` позволяют записывать и считывать данные примитивных типов
(`boolean`, `char`, `byte`, `short`, `int`, `long`, `float` and `double`). Они реализуют интерфейсы `DataOutput` и
`DataInput` соответственно. В этих интерфейсах определяются методы, выполняющие взаимное преобразование значений
примитивных типов и последовательностей байтов. Такие потоки ввода-вывода упрощают сохранение в файле данных, 
представленных в двоичной форме, например целочисленных значений или числовых значений с плавающей точкой.

Класс `DataOutputStream` расширяет класс `FilterOutputStream`, который, в свою очередь, расширяет класс `OutputStream`.
Помимо интерфейса `DataOutput`, класс `DataOutputStream` реализует интерфейсы `AutoCloseable`, `Closeable` и `Flushable`.
В этом классе поддерживаются все методы, определенные в его суперклассах. Но по-настоящему привлекательным этот класс 
делают реализуемые в нем методы из интерфейса `DataOutput`. В интерфейсе `DataOutput` определяются методы, сначала 
преобразующие значения примитивных типов в последовательности байтов, а затем выводящие их в базовый поток. Пример:

+ `final void writeDouble(double значение) throws IOException`

Класс `DataInputStream` служит дополнением класса `DataOutputStream` для ввода примитивных типов данных в двоичной форме.
Он расширяет класс `FilterInputStream`, который в свою очередь, расширяет класс `InputStream`. Помимо интерфейса 
`DataInput`, класс `DataInputStream` реализует интерфейсы `AutoCloseable` и `Closeable`. 

Как и в классе `DataOutputStream`, в классе `DataInputStream` поддерживаются все методы из его суперклассов, а также 
методы, определенные в интерфейсе `DataInput`, что делает его особенно привлекательным. Эти методы вводят 
последовательность байтов и преобразуют их в значения примитивных типов. Пример:

+ `final double readDouble() throws IOException`

[к оглавлению](#io)

## 15. Что такое поток объектов, Object stream.

`ObjectOutputStream` используется для конвертации объектов в поток. В java это называется сериализация.
Объект преобразованный таким образом может быть сохранен в базу данных, передан по сети и т.п.
Для записи в файл можно использовать `FileOutputStream`.
Объект который передается в потоке должен реализовывать интерфейс `java.io.Serializable`.
```java
FileOutputStream fos = new FileOutputStream("EmployeeObject.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
// write object to file
oos.writeObject(emp);
```

При сериализации используют переменную `SerialVersionUID`.
Во время сериализации, среда выполнения Java создает номер версии для класса, так что она может десереализировать
его позже. В Java этот номер версии известен как `SerialVersionUID`. Если во время десериализации, `SerialVersionUID`
не соответствует, то процесс завершится с исключением

`SerialVersionUID` используется для указании версии сериализованных данных.
+ Когда мы не объявляем `SerialVersionUID` в нашем классе, среда выполнения Java делает это за нас, но этот процесс
  чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов,
  которые реализованы в классе и пр. Вы можете найти точную информацию в документации о сериализации от Oracle.
+ Рекомендуется объявлять `SerialVersionUID` как `private static final long` переменную во избежание механизма по умолчанию.

[к оглавлению](#io)

## 16. Что такое Path? Как он реализуется на разных ОС?

Java 7 представляет новую абстракцию для пути, а именно интерфейс `Path`. Он используется в новых функциях и API,
по всему NIO.2. Объект пути содержит имена каталогов и файлов, которые составляют полный путь до файла/каталога,
представленного объектом `Path`.

`Path` содержит методы для извлечения элементов пути, манипуляций с ними и их добавления.

Путь к файлу, в разных системх может записываться по разному, `\` или `/`, поэтому лучше
использовать `File.separator` для построения пути
```java
// Cоздание объекта Path через вызов статического метода get() класса Paths 
Path testFilePath = Paths.get("/home/heorhi/testfile.txt"); 
         
//Пример строки создания объекта Path пути для запуска в Windows 
Path testFilePath = Paths.get("D:\\test\\testfile.txt");
``` 

[к оглавлению](#io)

## 17. Как получить список файлов?

+ Без учета подпапок
```java
File file = new File("dir");
File[] filesArr = file.listFiles();
String[] filesNames = file.list();
```
+ С учетом подпапок
```java
public void listFilesForFolder(final File folder) {
    for (final File fileEntry : folder.listFiles()) {
        if (fileEntry.isDirectory()) {
            listFilesForFolder(fileEntry);
        } else {
            System.out.println(fileEntry.getName());
        }
    }
}
final File folder = new File("/home/you/Desktop");
listFilesForFolder(folder);
```

**Java 8**
+ Java NIO без учета подпапок
```java
Stream<Path> stramFiles = Files.list(Paths.get("dir"));
```
+ С учетом подпапок. Files.walk API is available from Java 8.
```java
try (Stream<Path> paths = Files.walk(Paths.get("/home/you/Desktop"))) {
    paths
        .filter(Files::isRegularFile)
        .forEach(System.out::println);
}
```
+ В Java есть встроенный механизм - FileVisitor.
```java
package ru.job4j.io;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;

import static java.nio.file.FileVisitResult.CONTINUE;

public class PrintFiles implements FileVisitor<Path> {


  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    return CONTINUE;
  }

  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    System.out.println(file.toAbsolutePath());
    return CONTINUE;
  }

  @Override
  public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    return CONTINUE;
  }

  @Override
  public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    return CONTINUE;
  }
}

class Search { 
    public static void main(String[] args) throws IOException {
        Path start = Paths.get(".");
        Files.walkFileTree(start, new PrintFiles()); 
    }
}
```

[к оглавлению](#io)

## 18. Как проверить что файловая сущность является файлом или папкой?

```java
File file = new File("/Users/pankaj/source.txt");
File dir = new File("/Users/pankaj");
File notExists = new File("/Users/pankaj/notafile");
        
System.out.println("/Users/pankaj/source.txt is file?" + file.isFile());
System.out.println("/Users/pankaj/source.txt is directory?" + file.isDirectory());
        
System.out.println("/Users/pankaj is file?" + dir.isFile());
System.out.println("/Users/pankaj is directory?" + dir.isDirectory());
        
System.out.println("/Users/pankaj/notafile is file?" + notExists.isFile());
System.out.println("/Users/pankaj/notafile is directory?" + notExists.isDirectory());
```
С использованием `path`
```java
Path file = new File(path).toPath();
boolean exists =      Files.exists(file);        // Check if the file exists
boolean isDirectory = Files.isDirectory(file);   // Check if it's a directory
boolean isFile =      Files.isRegularFile(file); // Check if it's a regular file
```

[к оглавлению](#io)

## 19. Как удалить файл?

**Using `java.io.File.delete()` function:**
```java
File file = new File("/Users/pankaj/file.txt");

if(file.delete()) {
    System.out.println("/Users/pankaj/file.txt File deleted");
} else {
    System.out.println("File /Users/pankaj/file.txt doesn't exist");
}    
```
**Using `java.nio.file.files.deleteIfExists(Path p)`**
```java
Files.deleteIfExists(Paths.get("C:\\Users\\Mayank\\Desktop\\445.txt")); 
```

[к оглавлению](#io)

## 20. Как переместить файл?

`Java.io.File` не содержит метода готового файла make move,
но вы можете обойти эту проблему с помощью следующих двух альтернатив:

+ `File.renameTo()` (может не сработать на разных файловых системах. Надо проверять результат)
+ Copy to new file and delete the original file.

Для Java 7:

+ `Files.move(Paths.get("/foo.txt")`, `Paths.get("bar.txt")`, `StandardCopyOption.REPLACE_EXISTING);`

[к оглавлению](#io)

## 21. Как управлять аттрибутами файла?

**Базовые атрибуты** (доступны во всех ОС):

+ File type
+ File size
+ Created time
+ Owner of the file
+ Last time modified
+ Last time accessed
+ Hidden
+ System file
+ Regular file
+ isDirectory

**`FileAttributeView`** - базовый интерфейс с подинтерфейсами

+ `BasicFileAttributeView`
+ `DosFileAttributeView`
+ `PosixFileAttributeView`
+ `UserDefinedFileAttributeView`
+ `AclFileAttributeView`
+ `FileOwnerAttributeView`

```java
Path path = FileSystems.getDefault().getPath("c:/test", "somefile.txt");
BasicFileAttributeView basicView = Files.getFileAttributeView(path, BasicFileAttributeView.class);
basicView.readAttributes().lastAccessTime().toMillis();  // will return the last time the file was read.
basicView.readAttributes().lastModifiedTime().toMillis();  // will return the last time the file was changed.
basicView.readAttributes().creationTime().toMillis();  // will return the creation time.
```

```java
DosFileAttributeView dosView = Files.getFileAttributeView(path,DosFileAttributeView.class);
dosView.setHidden(true);
dosView.setReadOnly(true);
dosView.setSystem(true);
dosView.setArchive(true);
```

[к оглавлению](#io)

## 22. Как создать файл?

Четыре способа:
1. `File file = new File(absoluteFilePath);`

   `file.createNewFile();`

2. `FileOutputStream fos = new FileOutputStream("name.txt");`

   `fos.close();`

3. `String fileData = "Pankaj Kumar";`

   `Files.write(Paths.get("name.txt"), fileData.getBytes());`

4. `Path path = Paths.get("name.txt");`

   `Files.createFile(path);`

[к оглавлению](#io)

## 23. Как создать директорию?

Два способа:
+ `new File("/path/directory").mkdirs();`

+ `Files.createDirectories(Paths.get("/path/to/directory"));`

[к оглавлению](#io)

## 24. Как записать в файл?

+ **BufferedWriter**
```java
    BufferedWriter writer = new BufferedWriter(new FileWriter("c:/temp/samplefile1.txt"));
    writer.write(fileContent);
    writer.close();
```

+ **FileWriter/PrintWriter**
```java
    FileWriter fileWriter = new FileWriter("c:/temp/samplefile2.txt");
    fileWriter.write(fileContent);
    fileWriter.close();
```

+ **FileOutputStream**
```java
    FileOutputStream fos = new FileOutputStream("c:/temp/samplefile4.txt");
    byte[] strToBytes = fileContent.getBytes();
    fos.write(strToBytes);
    fos.close();
```

+ **DataOutputStream**
```java
    FileOutputStream fos = new FileOutputStream("c:/temp/samplefile5.txt");
    DataOutputStream dataOutStream = new DataOutputStream(new BufferedOutputStream(fos));
    dataOutStream.writeUTF(fileContent);
    dataOutStream.close();
```

+ **FileChannel**
```java
    RandomAccessFile stream = new RandomAccessFile("c:/temp/samplefile6.txt", "rw");
    FileChannel channel = stream.getChannel();
    byte[] strBytes = fileContent.getBytes();
    ByteBuffer buffer = ByteBuffer.allocate(strBytes.length);
    buffer.put(strBytes);
    buffer.flip();
    channel.write(buffer);
    stream.close();
    channel.close();
```
+ **Java 7 Path**
```java
    Path path = Paths.get("c:/temp/samplefile7.txt");     
    Files.write(path, fileContent.getBytes());
```

**Summary**
+ Если мы попытаемся записать в файл, который не существует, файл будет создан первым, и исключение не будет создано
  (кроме использования метода `Path`).
+ Всегда закрывайте выходной поток после записи содержимого файла, чтобы освободить все ресурсы. Это также поможет не 
  повредить файл.
+ Используйте `PrintWriter` для записи форматированного текста.
+ Используйте `FileOutputStream` для записи двоичных данных.
+ Используйте `DataOutputStream` для записи примитивных типов данных.
+ Используйте `FileChannel` для записи файлов большего размера.

[к оглавлению](#io)

## 25. Как прочитать данные из файла?

+ **BufferedReader**
```java
    BufferedReader br = new BufferedReader(new FileReader(file));
    String st; 
    while ((st = br.readLine()) != null)  {
        System.out.println(st); 
    }
```

+ **FileReader**
```java
    FileReader fr = new FileReader("C:\\Users\\pankaj\\Desktop\\test.txt");
    int i; 
    while ((i=fr.read()) != -1) {
        System.out.print((char)i);
    }
```
+ **Scanner**
```java
    Scanner sc = new Scanner(file);
    // we just need to use \\Z as delimiter 
    sc.useDelimiter("\\Z"); 
      
    System.out.println(sc.next());
```
+ **Reading the whole file in a List**
```java
    data = new String(Files.readAllBytes(Paths.get(fileName)));
```

[к оглавлению](#io)

## 26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?

Класс `PrintStream` - это именно тот класс, который используется для вывода на консоль. Когда мы выводим на консоль 
некоторую информацию с помощью вызова `System.out.println()`, то тем самым мы задействуем `PrintStream`, так как переменная
out в классе System как раз и представляет объект класса PrintStream, а метод `println()` - это метод класса `PrintStream`.

Но `PrintStream` полезен не только для вывода на консоль. Мы можем использовать данный класс для записи информации в поток 
вывода. Для этого PrintStream определяет ряд конструкторов:

```java
PrintStream(OutputStream outputStream)
PrintStream(OutputStream outputStream, boolean autoFlushingOn)
PrintStream(OutputStream outputStream, boolean autoFlushingOn, String charSet) throws UnsupportedEncodingException
PrintStream(File outputFile) throws FileNotFoundException
PrintStream(File outputFile, String charSet) throws FileNotFoundException, UnsupportedEncodingException
PrintStream(String outputFileName) throws FileNotFoundException
PrintStream(String outputFileName, String charSet) throws FileNotFoundException, UnsupportedEncodingException
```

Параметр `outputStream` - это объект `OutputStream`, в который производится запись. Параметр `autoFlushingOn` при значении 
true позволяет автоматически записывать данные в поток вывода. По умолчанию этот параметр равен `false`. Параметр `charSet`
позволяет указать кодировку символов.

В качестве источника для записи данных вместо `OutputStream` можно использовать объект `File` или строковый путь, по 
которому будет создаваться файл.

Для вывода информации в выходной поток `PrintStream` использует следующие методы:

+ `println()`: вывод строковой информации с переводом строки
+ `print()`: вывод строковой информации без перевода строки
+ `printf()`: форматированный вывод

Кроме того, как и любой поток вывода и наследник класса `OutputStream` он имеет метод `write`.

---

На `PrintStream` похож другой класс `PrintWriter`. Его можно использовать как для вывода информации на консоль, так и в 
файл или любой другой поток вывода. Данный класс имеет ряд конструкторов:

+ `PrintWriter(File file)`: автоматически добавляет информацию в указанный файл
+ `PrintWriter(File file, String csn)`: автоматически добавляет информацию в указанный файл с учетом кодировки csn
+ `PrintWriter(OutputStream out)`: для вывода информации используется существующий объект `OutputStream`, автоматически 
  сбрасывая в него данные
+ `PrintWriter(OutputStream out, boolean autoFlush)`: для вывода информации используется существующий объект `OutputStream`,
  второй параметр указывает, надо ли автоматически добавлять в OutputStream данные
+ `PrintWriter(String fileName)`: автоматически добавляет информацию в файл по указанному имени
+ `PrintWriter(String fileName, String csn)`: автоматически добавляет информацию в файл по указанному имени, используя 
  кодировку csn
+ `PrintWriter(Writer out)`: для вывода информации используется существующий объект Writer, в который автоматически идет
  запись данных
+ `PrintWriter(Writer out, boolean autoFlush)`: для вывода информации используется существующий объект Writer, второй 
  параметр указывает, надо ли автоматически добавлять в Writer данные

PrintWriter реализует интерфейсы `Appendable`, `Closable` и `Flushable`, и поэтому после использования представляемый им
поток надо закрывать.

Для записи данных в поток он также используется методы `printf()` и `println()`.

В качестве потока вывода здесь применяется `System.out`, а на консоль будет выведена строка **"Hello world!"**

---

Класс `PrintWriter` и `PrintStream` - это классы ввода/вывода в Java, которые позволяют записывать текстовые данные в 
поток вывода (например, файл, консоль или сеть) с помощью методов, которые обрабатывают разные типы данных.

Главное отличие между `PrintWriter` и `PrintStream` заключается в том, как они обрабатывают исключения. В качестве части
их обязательств по обработке исключений, `PrintStream` предоставляет методы `checkError()`, а `PrintWriter` возвращает 
исключение с помощью метода `getError()`.

Кроме того, `PrintStream` использует кодировку, которая зависит от настроек операционной системы, в то время как 
`PrintWriter` всегда использует кодировку по умолчанию. Наконец, `PrintWriter` более эффективен, чем `PrintStream` на
запись в файлы, так как использует меньше буферов памяти.

Если вам нужно выводить текстовые данные в поток вывода, то в большинстве случаев вы можете использовать любой из этих
классов. Однако, если вам нужно более эффективный способ записи данных в файл, рекомендуется использовать PrintWriter.

[к оглавлению](#io)

## 27. Что такое потоки байтовых массивов? Как они устроены?

Для работы с массивами байтов - их чтения и записи используются классы `ByteArrayInputStream` и `ByteArrayOutputStream`.

**Чтение массива байтов и класс ByteArrayInputStream**

Класс `ByteArrayInputStream` представляет входной поток, использующий в качестве источника данных массив байтов. Он имеет 
следующие конструкторы:

```java
ByteArrayInputStream(byte[] buf)
ByteArrayInputStream(byte[] buf, int offset, int length)
```

В качестве параметров конструкторы используют массив байтов buf, из которого производится считывание, смещение 
относительно начала массива offset и количество считываемых символов length.

Считаем массив байтов и выведем его на экран:
```java
import java.io.*;
 
public class Program {
 
    public static void main(String[] args) {
         
        byte[] array1 = new byte[]{1, 3, 5, 7};
        ByteArrayInputStream byteStream1 = new ByteArrayInputStream(array1);
        int b;
        while((b=byteStream1.read())!=-1){
         
            System.out.println(b);
        }
         
        String text = "Hello world!";
        byte[] array2 = text.getBytes();
        // считываем 5 символов
        ByteArrayInputStream byteStream2 = new ByteArrayInputStream(array2, 0, 5);
        int c;
        while((c=byteStream2.read())!=-1){
         
            System.out.println((char)c);
        }
    } 
}
```

В отличие от других классов потоков для закрытия объекта ByteArrayInputStream не требуется вызывать метод close.

---

**Запись массива байт и класс ByteArrayOutputStream**

Класс `ByteArrayOutputStream` представляет поток вывода, использующий массив байтов в качестве места вывода.

Чтобы создать объект данного класса, мы можем использовать один из его конструкторов:

```java
ByteArrayOutputStream() 
ByteArrayOutputStream(int size)
```

Первая версия создает массив для хранения байтов длиной в 32 байта, а вторая версия создает массив длиной size.

Рассмотрим применение класса:
```java
import java.io.*;
 
public class Program {
 
    public static void main(String[] args) {
         
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        String text = "Hello Wolrd!";
        byte[] buffer = text.getBytes();
        try{
            baos.write(buffer);
        } catch(Exception ex){
            System.out.println(ex.getMessage());
        }
        // превращаем массив байтов в строку
        System.out.println(baos.toString());
        // получаем массив байтов и выводим по символьно
        byte[] array = baos.toByteArray();
        for(byte b: array){
            System.out.print((char)b);
        }
        System.out.println();
    } 
}
```

Как и в других потоках вывода в классе `ByteArrayOutputStream` определен метод write, который записывает в поток 
некоторые данные. В данном случае мы записываем в поток массив байтов. Этот массив байтов записывается в объекте 
`ByteArrayOutputStream` в защищенное поле `buf`, которое представляет также массив байтов (`protected byte[] buf`).

Так как метод `write` может сгенерировать исключение, то вызов этого метода помещается в блок` try..catch`.

Используя методы `toString()` и `toByteArray()`, можно получить массив байтов `buf` в виде текста или непосредственно в
виде массива байт.

С помощью метода `writeTo` мы можем вывести массив байт в другой поток. Данный метод в качестве параметра принимает 
объект `OutputStream`, в который производится запись массива байт:

```java
ByteArrayOutputStream baos = new ByteArrayOutputStream();
String text = "Hello Wolrd!";
byte[] buffer = text.getBytes();
try {
    baos.write(buffer);
}catch(Exception ex){
    System.out.println(ex.getMessage());
}
try(FileOutputStream fos = new FileOutputStream("hello.txt")){
    baos.writeTo(fos);
}catch(IOException e){
    System.out.println(e.getMessage());
}
```
После выполнения этой программы в папке с программой появится файл `hello.txt`, который будет содержать строку 
**"Hello Wolrd!"**.

И в заключении также надо сказать, что как и для объектов `ByteArrayInputStream`, для `ByteArrayOutputStream` не надо
явным образом закрывать поток с помощью метода `close`.

[к оглавлению](#io)

## 28. Зачем нужен класс RandomAccessFile?

Файл, который читается с помощью последовательного потока, называется файлом с последовательным доступом. Данные такого
файла нельзя обновлять, пока идёт чтение или запись. В Java есть возможность читать и записывать в файл одновременно.
Для этого существует класс `RandomAccessFile` в пакете `java.io`. Класс `RandomAccessFile` даёт возможность читать и 
записывать данные в любом месте файла. Таким образом можно обращаться к данным в произвольном порядке. Файл, читаемый 
с помощью класса `RandomAccessFile` называется файлом с произвольным доступом. Данные можно читать и записывать из / в
любого места файла.

В отличие от других классов-потоков, класс `RandomAccessFile` не наследуется от классов `InputStream` и `OutputStream`.
Вместо них он реализует интерфейсы `DataInput` и `DataOutput`, а также имеет свои методы для осуществления 
одновременного чтения и записи файла.

Файл произвольного доступа - это последовательность байтов. Он поддерживает файловый указатель - это указатель 
местоположения курсора в файле (его позиция). При создании файла произвольного доступа этот указатель всегда находится
на нулевой позиции. При чтении / записи одного байта указатель двигается вперёд к следующему байту данных.

Главная особенность класса `RandomAccessFile` - это возможность перемещаться по данным и читать только те данные, которые
нам нужны, вместо считывания файла целиком, а также записывать данные в указанное место (в начало, конец или произвольно).

Для этого в классе `RandomAccessFile` определены следующие методы:

- `seek(номер позиции)` - перемещает указатель на указанную позицию. Соответственно `seek(0)` переместит указатель в 
  начало файла, а `seek(файл.length())` переместит указатель в конец файла.
- `getFilePointer()` - возвращает текущую позицию, на которой находится указатель в данный момент. Файл произвольного 
  доступа - это последовательность байтов, поэтому этот и предыдущий методы устанавливают и возвращают позицию именно в
  байтах. То есть если у нас, например, в файле записано несколько значений типа `int`, то чтобы прочитать второе
  значение, нужно ставить указатель на 4 позицию, так как первые 4 байта (0-3 ячейки) будет занимать первое значение 
  типа `int`.
- Непосредственное чтение / запись производятся с помощью методов типа `read*Тип()`, `readLine()`, `readUTF()` /` write*Тип()`, 
  `writeUTF()` и т.д.

При создании файла произвольного доступа (объекта RandomAccessFile), помимо локации исходного файла нужно указывать 
режим:
```java
RandomAccessFile randomAccess = new RandomAccessFile("data/random.txt", "r");
```

Режимы бывают трех типов: "r" - файл будет открыт только для чтения, "rw" - чтение и запись, "rws" - чтение и запись,
при этом каждое изменение файла мгновенно отражается в исходном файле (то есть изменения сразу же сохраняются на
носителе). Если указанного файла не существует, то в режиме "r" будет выброшено исключение `FileNotFoundException`, а в 
режиме "rw" и "rws" будет создан новый файл с указанным названием.

[к оглавлению](#io)

## 29. Данные в каком виде можно считывать байтовыми и символьными потоками?

Например, текстовый файл содержит текст, то есть символы. Соответственно, быстрее будет читать данные не побайтово, а
посимвольно, для этого вместо байтовых потоков
```java
BufferedInputStream input = new BufferedInputStream(new FileInputStream("data/newData.txt"));
```

лучше применять символьные потоки:
```java
BufferedReader input = new BufferedReader(new FileReader("data/newData.txt"));
```

Практически у всех байтовых классов `InputStream` / `OuputStream` существует свой символьный аналог `Reader` / `Writer`.
Работают они аналогично друг другу. Выбор того или иного класса должен зависеть от того, в каком виде представлены 
данные, с которыми нужно работать.

Если нужно работать только с текстовыми (символьными) данными, то рекомендуется использовать символьные потоки и их
обёртки (`Reader` / `Writer`), а если данные имеют байтовый или смешанный вид, то рекомендуется применять байтовые 
потоки и их обёртки (`InputStream` / `OuputStream`). Это важно не только с точки зрения производительности, но и с точки
зрения целостности данных. Например, нельзя прочитать файл png символьным потоком, так как *.png файл содержит только
байтовые данные, которые невозможно привести к символам.

[к оглавлению](#io)

## 30. Что такое сокет?

Сокет (socket — разъём) - программный интерфейс для обмена данными между процессами. Процессы могут исполняться как на 
одном компьютере, так на разных, связанных сетью. Иначе говоря, сокет - объект, представляющий конечную точку соединения.
Сокет определяется IP-адресом компьютера и номером порта. Для протокола TCP номер порта - целое число от 0 до 65535.

[к оглавлению](#io)

## 31. Какие виды сокетов есть в Java? С каким протоколом они работают?

Класс `java.net.ServerSocket` используется серверными приложениями для получения порта и прослушивания клиентских 
запросов.

Класс `java.net.Socket` представляет собой сокет, который клиент и сервер используют для связи друг с другом. Клиент 
получает объект сокета, создав его, тогда как сервер получает объект сокета из возвращаемого значения метода `accept()`.

В Java сокеты обеспечивают механизм связи между двумя компьютерами, использующими TCP. **TCP** - TCP - это протокол 
управления передачей, который обеспечивает надежную связь между двумя приложениями. В Java TCP обычно используется 
через Интернет-протокол, который называется TCP/IP.

[к оглавлению](#io)

## 32. Как отправить через сокет сообщение?

Самый простой способ обмена:

На клиенте:

```java
public static void main(String[] args) throws IOException {
    Socket socket = new Socket("localhost", 8000);
    BufferedReader in = new BufferedReader(
            new InputStreamReader(
                    socket.getInputStream()));
    BufferedWriter out = new BufferedWriter(
            new OutputStreamWriter(
                    socket.getOutputStream()));

    out.write("Hello, it's a client!");
    out.newLine();
    out.flush();
    String word = in.readLine();
    System.out.println("Server: " + word);

    out.close();
    in.close();
    socket.close();
}
```

На сервере:

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(8000);
    Socket socket = serverSocket.accept();
    BufferedReader in = new BufferedReader(
            new InputStreamReader(
                    socket.getInputStream()));
    BufferedWriter out = new BufferedWriter(
            new OutputStreamWriter(
                    socket.getOutputStream()));

    String word = in.readLine();
    System.out.println("Client: " + word);
    out.write("Hello, it's a server!");
    out.newLine();
    out.flush();

    out.close();
    in.close();
    socket.close();
}
```

[к оглавлению](#io)

## 33. Что такое логирование?

Логгирование - это процесс записи в файл полезной информации о работе программы.

Полученный файл называют лог-файлом. Если приложение работает плохо, то первое что проверяют - это лог файл.

"Посмотри в лог" - это значит открыть файл логгирования и посмотреть наличие Exception.

[к оглавлению](#io)

## 34. Какие уровни логирования вы знаете?

+ OFF: никакие логи не записываются, все будут проигнорированы;
+ FATAL: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
+ ERROR: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. 
  Остальные запросы могут работать корректно;
+ WARN: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система 
  устояла и выполнила запрос;
+ INFO: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые 
  действия системы;
+ DEBUG: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее 
  ожидают, или описания действия системы: “method1 начал работу”;
+ TRACE: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
+ ALL: уровень, при котором будут записаны все логи из системы.

[к оглавлению](#io)

## 35. Какая библиотека для логгирования используется в курсе? Как ее настроить?

В курсе используется библиотека Log4j.

Настройка библиотеки:
1. Добавьте зависимость log4j.
   
```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```
2. Создайте файл /src/main/resources/log4j.properties. В нём указываются настройки. Содержимое файла:
```text
log4j.rootLogger=DEBUG, console
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{ISO8601} %5p %c:%M:%L - %m%n
```

**log4j.properties**
1. Запись в консоль, файл или базу данных. Log4j позволяет записывать информацию не только в консоль или файл, но так же
   в базу данных или отправлять по почте.
   
```text
log4j.appender.console=org.apache.log4j.ConsoleAppender
```

2. Формат записи. В логах удобно получать информацию о времени выполнении классе и строчке кода, где была сделана запись.
```text
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{ISO8601} %5p %c:%M:%L - %m%n
```
Дата: `%d{ISO8601}`

Уровень сообщения: `%5p`

Класс, метод, строчка: `%c:%M:%L`

Текст сообщения: `%m%n`

3. Уровень логгирования.
```text
log4j.rootLogger=DEBUG, console
```

Также в Java используется библиотека slf4j. Она позволяет абстрагироваться от конкретных библиотек. Это позволяет 
придерживаться единого стиля логгирования для проектов.

Для настройки необходимо добавить зависимость slf4j. И использовать другие импорты `import org.slf4j.Logger` и `import org.slf4j.LoggerFactory`.

```xml
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
  <version>1.7.30</version>
</dependency>
```

[к оглавлению](#io)

## 36. Опишите из каких элементов состоит формат JSON?

Примитивные типы данных в JSON:

+ число (целое или вещественное).
+ литералы true, false и null.
+ строка — символы юникода, заключённые в двойные кавычки.

Ссылочные типы данных:

+ Объект - заключается в фигурные скобки ({ и }) и содержит разделенный запятой список пар имя/значение.
+ Массив - заключается в квадратные скобки ([ и ]) и содержит разделенный запятой список значений.

[к оглавлению](#io)

## 37. Как преобразовать POJO в/из json?

**JSON-Java (org.json)** легковесная функциональная библиотека для работы с JSON, которая дополнительно умеет 
преобразовывать JSON в XML, HTTP header, Cookies и др. В отличие от Jackson или Gson, JSON-Java преобразует json-строку 
не в объект пользовательского класса (способ Data bind), а в объекты своей библиотеки JSONObject, JSONArray 
(способ Tree Model).

1. Необходимо добавить зависимость в Maven:
```xml
<dependency>
  <groupId>org.json</groupId>
  <artifactId>json</artifactId>
  <version>20200518</version>
</dependency>
```
2. Для корректного преобразования в строку с помощью org.json необходимо добавить геттеры к полям, которые хотим 
   преобразовывать в json.
   
Варианты преобразования:
```java
public static void main(String[] args) {

    /* JSONObject из json-строки строки */
    JSONObject jsonContact = new JSONObject("{\"phone\":\"+7(924)111-111-11-11\"}");

    /* JSONArray из ArrayList */
    List<String> list = new ArrayList<>();
    list.add("Student");
    list.add("Free");
    JSONArray jsonStatuses = new JSONArray(list);

    /* JSONObject напрямую методом put */
    final Person person = new Person(false, 30, new Contact("11-111"), "Worker", "Married");
    JSONObject jsonObject = new JSONObject();
    jsonObject.put("sex", person.isSex());
    jsonObject.put("age", person.getAge());
    jsonObject.put("contact", jsonContact);
    jsonObject.put("statuses", jsonStatuses);

    /* Выведем результат в консоль */
    System.out.println(jsonObject.toString());

    /* Преобразуем объект person в json-строку */
    System.out.println(new JSONObject(person).toString());
}
```

[к оглавлению](#io)

## 38. Опишите из каких элементов состоит формат XML?

1. **Объявление XML** 
   
Это первая строка, которая должна идти в файле, под расширением XML. В ней указывается кодировка и версия XML
```xml
<?xml version="1.1" encoding="UTF-8" ?>
```
2. **Теги** 
   
Теги - это основные детали из которых строится документ. Тег имеет имя и располагается между <>. 

Тег бывает открывающим. Располагается внутри <> и закрывающим располагается внутри < />. 

Между открывающим и закрывающим тегом уже располагаются либо другие теги, либо текст той сущности, что мы описываем 
через тег.

Пример:
```xml
<device>Lenovo Thinkpad</device>
```

Пример:
```xml
<device>
    <producer>Lenovo</producer>
    <model>Thinkpad</model>
</device>
```
Если между открывающим и закрывающим тегом ничего нет, то можно написать сокращенную запись:
```xml
<model/>
```
3. **Атрибуты**

Атрибуты - это часть синтаксиса, которая позволяет определить свойства элементов.

Атрибуты пишутся в открывающем теги, после его имени в формате: `имяАтрибут="его значение"`

Например:
```xml
<size width="100" height="100"/>
```

4. **Комментарии**

Комментарии как однострочные, так и многострочные пишутся внутри <!-- и -->

```xml
<!-- комментарии -->
```

[к оглавлению](#io)

## 39. Как преобразовать POJO в/из xml?

1. Для начала нам нужно добавить зависимости на библиотеку JAXB с помощью которой мы будем делать преобразования:

```xml
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
<dependency>
    <groupId>javax.activation</groupId>
    <artifactId>activation</artifactId>
    <version>1.1.1</version>
</dependency>
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
    <version>2.3.1</version>
</dependency>
```
2. Для использования JAXB нам нужно в модели добавить дефолтные конструкторы.

3. Для того чтобы сериализовать и десериализовать нам нужно добавить аннотации JAXB, которую дадут библиотеке информацию
   о том как парсить объект.

   1. xml обязательно должен иметь корневой тег, в котором все и будет располагаться. Для его обозначения служит 
      @XmlRootElement. Эту аннотацию нужно ставить над сущностью, которая будет корневой.
      
   2. Над вложенными сущностями нам нужно поставить просто @XmlElement

   3. Для того чтобы поле считалось атрибутом нужно поставить  @XmlAttribute, по умолчанию поле парсится как тег

   4. Мы можем указать также как мы хотим читать/писать объект. По геттерам/сеттерам или напрямую по полям 
      (используется рефлексия). Мы будем использовать доступ по полям. Для этих целей служит аннотация @XmlAccessType

[к оглавлению](#io)

## 40. Что такое сериализация / десериализация?

**Сериализация** – процесс преобразования объектов в бинарный (т.е. последовательность битов) или текстовый формат.

**Десериализация** – процесс преобразования сериализованных данных в объекты, т.е. операция обратная сериализации.

Обычно механизм сериализации/десериализации используется для сохранения состояния программы между запусками, хранения 
настроек, передачи данных между программами локально или по сети.

В Java существует стандартный механизм сериализации в бинарный формат – Java serialization, из текстовых форматов 
наиболее популярны JSON, XML, YAML, BSON (binary JSON).

**Java serialization**. Для стандартной сериализации объекта необходимо в классе имплементировать интерфейс 
`Serializable`, этот интерфейс является маркерным, т.е. нет необходимости реализовывать его методы, он сообщает JVM, что
объект нашего класса может быть сериализован. Для сериализации объектов в поток используется метод writeObject класса
`ObjectOutputStream`, для чтения из потока readObject класса ObjectOutputStream

+ Поле `serialVersionUID` - уникальный идентификатор версии сериализованного класса, необходим для обеспечения 
  механизмов версионности, т.е. нужен JVM для понимания, что сериализованный объект при десериализации имеет те же члены
  класса, методы и пр. Если значения не совпадают, будет выброшено исключение `java.io.InvalidClassException`. Для
  наглядности в примере мы задаем значение поля вручную, в реальной разработке лучше использовать штатный механизм Java 
  генерации `serialVersionUID` или разработать свой.
+ При сериализации объекта сериализуются все объекты, на которые он ссылается в своих полях, поэтому вложенные объекты
  тоже должны быть `Serializable`.
+ Для исключения полей из сериализации используется ключевое слово `transient`.
+ С помощью интерфейса `Externalizable` можно реализовать собственный алгоритм сериализации/десериализации, для этого 
  нужно переопределить два обязательных метода — `writeExternal()` и `readExternal()`.

[к оглавлению](#io)

## 41. Что такое регулярные выражения? Зачем они нужны?

Регулярные выражения (Regular Expressions или RegEx) - это шаблоны, с помощью которых производится поиск по совпадению
в тексте. То есть это строка, описывающая последовательность символов, которую желаем найти. С помощью определенного
синтаксиса искать можно не только символы напрямую, но и целые диапазоны или комбинации символов. Тем самым можно 
создавать самые разнообразные шаблоны для поиска с помощью последовательности обычных символов, метасимволов и 
квантификаторов.

[к оглавлению](#io)

## 42. Как создать регулярное выражение в Java?

В Java работа с регулярными выражениями производится с помощью классов `Pattern` и `Matcher` из пакета `java.util.regex`.
Эти классы работают в паре. В классе `Pattern` определяется регулярное выражение (создается шаблон и сопоставитель), а с 
помощью класса `Matcher` производится сопоставление шаблона с текстом.

Так выглядит регулярное выражение с помощью обычных символов (строки):
```java
Pattern pattern = Pattern.compile("Я готовлюсь к интервью"); 
```

Метод `compile()` класса `Pattern` создает неизменяемый шаблон из переданной последовательности символов, который мы 
можем использовать для проверки его на наличие присутствия в тексте. При создании шаблона производится проверка на 
соответствие синтаксису. Если шаблон создан с ошибкой, то будет выброшено исключение `PatternSyntaxException`.

Далее создадим "сопоставитель" шаблона и текста:
```java
String text = "Я готовлюсь к интервью"; 
Matcher matcher = pattern.matcher(text);
```

Метод `matcher()` класса `Pattern` создает сопоставитель нашего шаблона с заданным текстом.

Проверить данное сопоставление на полное соответствие шаблона тексту можно с помощью метода `matches()` класса `Matcher`.

[к оглавлению](#io)

## 43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?

**Метасимвол** - это символ или последовательность символов, имеющие специальное назначение.

### 1) Позиционные метасимволы.

Определяют позицию искомого символа или последовательности в тексте. Позиция - это место перед или после любого символа 
в слове. Для наглядности в слове _П_р_и_в_е_т_  все позиции отмечены символом подчеркивания. Ниже в описании 
метасимволов будет использоваться такое подчеркивание для указания описываемой позиции.

+ **^** - начало строки (**_**текст1 555 текст). Находит заданную последовательность, только если она является началом строки.
+ **$** - конец строки (текст1 555 текст**_**). Находит заданную последовательность, только если она является концом строки.
+ **\b** - граница слова (\_текст1\_ \_555\_ \_тек%ст\_). Слово - это непрерывная последовательность любых букв, цифр, символов.
+ **\B** - не граница слова (т_е_к_с_т_1 5_5_5). Все позиции, кроме границ слов.

### 2) Метасимволы группировки (символьные классы). Определяют диапазоны символов.

+ **[abc]** - символ(ы) или диапазон символов. Каждый проверяемый в тексте символ проверяется на присутствие в заданном диапазоне. Запись может быть в разном виде. Например, [a] - символ a, [at] - символы a и t, [a-k] - символы от a до k, [1-4] - символы от 1 до 4 и т.д.
+ **[a-сx-z]** - объединение диапазонов. В данной записи совмещены диапазоны а-с и x-z. Запись может содержать и одиночные символы.

### 3) Метасимволы группы литералов.

+ **.** (точка) - любой символ.
+ **\d** - любой цифровой символ.
+ **\D** - любой символ, кроме цифровых.
+ **\s** - символ пробела.
+ **\S** - все символы, кроме пробела.
+ **\w** - символ буквы, цифры или символ подчеркивания.
+ **\W** - любой символ, кроме буквы, цифры и символа подчеркивания.

### 4) Метасимволы редактирования текста.

+ **\n** - символ новой строки.
+ **\r** - символ возврата каретки в начало строки.
+ **\t** - символ табуляции.

### 5) Квантификаторы.

**Квантификатор** - это метасимвол, который обозначает количество вхождений символа и всегда ставится после него. При
использовании квантификаторов находится не только одиночный символ, но и последовательность символов (кроме нулевых 
вхождений).

+ \* - ноль или более раз
+ **\+** - один или более раз
+ **?** - один или отсутствует
+ **{x}** - х раз
+ **{x,}** - х раз и более. Т.е. символ должен встречаться не меньше х раз подряд.
+ **{x,y}** - от х до y раз (оба включительно).

**Режимы квантификаторов.**

Квантификаторы имеют несколько режимов: жадный, сверхжадный и ленивый.

_Жадный (greedy) режим._

Все квантификаторы по умолчанию работают в жадном режиме. Его работа заключается в том, что всегда ищется максимально
длинное совпадение.

_Сверхжадный (possessive) режим._

Записывается в виде символа "+" после квантификатора. Работает так же, как и жадный режим, но не имеет обратного прохода.

_Ленивый (reluctant) режим._

Записывается в виде символа "?" после квантификатора. Ленивый режим ищет самую короткую последовательность

[к оглавлению](#io)