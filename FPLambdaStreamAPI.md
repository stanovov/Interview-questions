## FP Lambda Stream API

[1. Что такое lambda выражение?](#1-Что-такое-lambda-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java.util.function.](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda выражении операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражении-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-stream-api)

[11. Расскажите, какой шаблон проектирования используется внутри Stream API?](#11-Расскажите-какой-шаблон-проектирования-используется-внутри-stream-api)

[12. Перечислите конвейерные методы Stream API](#12-Перечислите-конвейерные-методы-stream-api)

[13. Перечислите терминальные методы Stream API.](#13-Перечислите-терминальные-методы-stream-api)

[14. Что такое ленивая загрузка?](#14-Что-такое-ленивая-загрузка)

[15. Что делает метод filter?](#15-Что-делает-метод-filter)

[16. Что делает метод map?](#16-Что-делает-метод-map)

[17. Что делает метод flatMap?](#17-Что-делает-метод-flatmap)

[18. Что делает метод collect?](#18-Что-делает-метод-collect)

[19. Что делает метод reduce?](#19-Что-делает-метод-reduce)

[20. Что делает метод findFirst?](#20-Что-делает-метод-findfirst)

[21. Возможно ли прервать выполнение потока по аналогии с break?](#21-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[22. Возможно ли пропустить элемент потока по аналогии с continue?](#22-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[23. Что такое Optional?](#23-Что-такое-optional)

[24. Перечислите методы Optional?](#24-Перечислите-методы-optional)

[25. Расскажите про фабричные методы List.of, Set.of, Map.of?](#25-Расскажите-про-фабричные-методы-listof-setof-mapof)

[26. Для чего используется ключевое слово var?](#26-Для-чего-используется-ключевое-слово-var)

[27. В каких случаях можно использовать var?](#27-В-каких-случаях-можно-использовать-var)

## 1. Что такое lambda выражение?

Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен 
позже, один или несколько раз. 

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в **функциональном интерфейсе**.

Лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в 
Java.

+ #### Отложенное выполнение:

  Одним из ключевых моментов в использовании лямбд является отложенное выполнение. То есть мы определяем в одном месте 
  программы лямбда-выражение и затем можем его вызвать при необходимости неопределенное количество раз в различных частях
  программы.

+ #### Передача параметров в лямбда-выражение:

  Параметры лямбда-выражения должны соответствовать по типу параметрам метода из функционального интерфейса.

+ #### Лямбды и локальные переменные:
  
  Лямбда-выражение может использовать переменные, которые объявлены во вне в более общей области видимости - на уровне 
  класса или метода, в котором лямбда-выражение определено. Локальные переменные уровня метода мы также можем 
  использовать в лямбдах, но изменять их значение нельзя. Более того, мы не сможем изменить значение переменной, которая
  используется в лямбда-выражении, вне этого выражения.
  
[к оглавлению](#fp-lambda-stream-api)

## 2. Что такое функциональные интерфейсы?

Функциональный интерфейс - это интерфейс, который содержит только 1 абстрактный метод.

Основное назначение - использование в лямбда-выражениях, method reference или ссылок на конструкторы.
В функциональном интерфейсе методов может быть больше, чем один. Ограничение в один метод относится именно к абстрактным
методам, т.к. в java с 8 версии в интерфейсах для методов можно задавать код по умолчанию (default методы). 

В строке над описанием интерфейса можно использовать аннотацию `@FunctionalInterface`. Наличие такой аннотации перед
описанием интерфейса приводит к тому, что на этапе компиляции программного кода выполняется проверка на пердмет того,
действительно ли интерфейс функциональный.

[к оглавлению](#fp-lambda-stream-api)

## 3. Перечислите функциональные интерфейсы из пакета java.util.function.

В JDK в пакете java.util.function встроены готовые функциональные интерфейсы, описывающие всевозможные варианты.
Это `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, `UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы

+ **Predicate<T>** - проверяет соблюдение некоторого условия.
  Если оно соблюдается, то возвращается значение `true`. В качестве параметра лямбда-выражение принимает объект типа `T`

+ **Function<T,R>** - представляет функцию перехода от объекта типа `T` к объекту типа `R`.

+ **Consumer<T>** - выполняет некоторое действие над объектом типа `T`, при этом ничего не возвращая.

+ **Supplier<T>** - принимает никаких аргументов, но должен возвращать объект типа `T`.

+ **BinaryOperator<T>** - принимает в качестве параметра два объекта типа `T`, выполняет над ними бинарную операцию
  и возвращает ее результат также в виде объекта типа `T`.

+ **UnaryOperator<T>** - принимает в качестве параметра объект типа `T`,
  выполняет над ними операции и возвращает результат операций в виде объекта типа `T`.

[подробнее](https://metanit.com/java/tutorial/9.3.php)

[к оглавлению](#fp-lambda-stream-api)

## 4. Что такое функции высшего порядка?

Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают другие функции в качестве 
своих результатов.

У языка Java — имеются функции высшего порядка в форме так называемых лямбда-выражений.

Основная идея: функции имеют тот же статус, что и другие объекты данных.
```java
Function<Integer,Integer>   f = x -> x + 3;
BiFunction<Function<Integer,Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
System.out.println(g.apply(f,7));
```

[к оглавлению](#fp-lambda-stream-api)

## 5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?

Все, которые могут принимать другие функции в качестве своих параметров или возвращать другие функции в качестве своих 
результатов. По моей логике это все из этого списка: `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, 
`UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы. 

[к оглавлению](#fp-lambda-stream-api)

## 6. Что такое ссылки на методы?

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод. Если лямбда выражения 
вызывают только один существующий метод, лучше ссылать на этот метод по его имени. Ссылки на методы (Method References)
- это компактные лямбда выражения для методов у которых уже есть имя.

Работают ссылки на методы при условии, что параметры и возвращаемый тип вызываемого метода и в лямбде совпадают.

Ссылки на методы бывают четырех видов:
+ `имя_класса::имя_статического_метода` ссылка на статический метод.
+ `объект_класса::имя_метода` на метода конкретного объекта (экземпляра).
+ `тип_объекта::имя_метода` на метод произвольного объекта конкретного типа.
+ `название_класса::new` ссылка на конструктор.

[к оглавлению](#fp-lambda-stream-api)

## 7. Что такое ссылки на конструкторы?

Можно в качестве параметров использовать конструкторы: `название_класса::new`, для дженериков `название_класса<T>::new`.

При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.

[к оглавлению](#fp-lambda-stream-api)

## 8. Расскажите о зоне видимости переменных в lambda выражениях? 

Лямбда-выражения имеют доступ к переменным в области видимости, в которой их определили.
Но доступ возможен только при условии, что переменные являются `effective final`,
то есть либо явно имеют модификатор `final`, либо не меняют своего значения после инициализации (константы).
Если переменной присваивается значение во 2й раз, то лямбда-выражение вызовет ошибку компиляции.

Можно ссылаться на:
+ `effective final` локальные переменные;
+ поля примитивных типов;
+ статические переменные.

[к оглавлению](#fp-lambda-stream-api)

## 9. Как быть в ситуации, если внутри lambda выражении операторы могут выкинуть исключение?

Лямбда-выражение может генерировать исключение.
+ если тело лямбда-выражения может бросить проверяемое `checked` исключение, то оно должно быть объявлено в
  абстрактном методе целевого функционального интерфейса в выражении `throws`.
+ либо должно быть обработано внутри лямбда-выражения с помощью конструкции `try-catch-finally`.

Как известно из функциональных интерфейсов в `Stream API` нельзя выбрасывать контролируемые исключения.
Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
приходится оборачивать их в `RuntimeException`.

[подробней](https://www.codeflow.site/ru/article/java-lambda-exceptions)

[к оглавлению](#fp-lambda-stream-api)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности,
упростить операции фильтрации, сортировки и другие манипуляции с данными.

Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`.
Ключевым понятием в Stream API является поток данных.
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Все операции над потоками бывают 2х видов:
+ `terminal` терминальные или конечные операции возвращают конкретный результат (`void` или результат определенного типа).
+ `intermediate` промежуточные или конвейерные операции возвращают трансформированный поток.

Все потоки производят вычисления, в т.ч. в промежуточных операциях, только когда к ним применяется терминальная операция.
Т.е. в данном случае применяется отложенное выполнение.

Потоки не могут быть использованы повторно - как только была вызвана конечная операция, поток закрывается.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно
сократить запись выполняемых действий. Т.е. Stream API позволяет взаимодействовать с данными в функциональном стиле,
пердставляя их в качестве конечного потока данных.

[Javadoc](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)

[Полное руководство по Java 8 Stream API в картинках и примерах](https://annimon.com/article/2778)

[Шпаргалка Java программиста 4. Java Stream API](https://habr.com/ru/company/luxoft/blog/270383/)

[к оглавлению](#fp-lambda-stream-api)

## 11. Расскажите, какой шаблон проектирования используется внутри Stream API?

Для построения потоков при работе со Stream используется шаблон проектирования Builder.

Builder - это порождающий шаблон проектирования, который позволяет создавать сложные объекты пошагово. Он позволяет 
использовать один и тот же код построения объекта для получения разных представлений объектов.

Например у нас есть сложный объект, который для создания требует сложной пошаговой инициализации множества полей и 
вложенных объектов. Чтобы проинициализировать такой объект необходимо использовать очень большой конструктор с 
множеством параметров, который при использовании становится абсолютно нечитаемым и чтобы контролировать вводимые 
параметры в том месте где определено их место - требуется постоянно возвращаться к объявленному конструктору.

Именно для таких случаев используется шаблон Строитель. Он предлагает решение такой проблемы путем вынесения 
конструирования объекта за пределы его собственного класса (или за счет вложенного статического класса), поручив это 
дело отдельным объектам.

Шаблон предлагает разбить процесс конструирования объекта на отдельные шаги . Чтобы создавать объекты таким образом, нам
нужно поочередно вызывать методы строителя (build + название поля в стиле CamelCase). При этом нам не нужно запускать 
все шаги, а только те, которые нужны для производства объекта определенной конфигурации. 

Последний элемент реализации шаблона - метод, который построит готовый объект и вернет его экземпляр (метод build).

[к оглавлению](#fp-lambda-stream-api)

## 12. Перечислите конвейерные методы Stream API.

1. filter() - Отфильтровывает записи, возвращает только записи соответствующие условию
2. skip() - Позволяет пропустить N первых элементов
3. distinct() - возвращает стрим без дубликатов (проверка на равенство методом equals)
4. peek() - возвращает тот же стрим, но применяет функцию к каждому элементу стрима
5. limit() - позволяет ограничить выборку определенных количеством первых элементов
6. sorted() - позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator
7. boxed() - позволяет получить стрим оберток из стрима примитивов
8. takeWhile() - позвоялет брать из стрима только первые элементы, которые удовлетворяют определенному условию.
9. dropWhile() - позволяет пропустить из стрима первые элементы, которые удовлетворяют условию.
10. map() - преобразует каждый элемент стрима
11. mapToObj() - преобразует стрим примитивов в стрим объектов
12. mapToInt(), mapToDouble(), mapToLong() - аналоги map(), но возвращают стрим из примитивных типов
13. flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong() - создает из каждого элемента потока новые потоки по 
    некому правилу и объединяет получившиеся потоки в один.
    
[к оглавлению](#fp-lambda-stream-api)

## 13. Перечислите терминальные методы Stream API.

1. findFirst() - возвращает первый элемент из стрима (Возвращает Optional)
2. findAny() - возвращает любой подходящий элемент из стрима (Возвращает Optional)
3. collect() - представление результатов в виде коллекций и других структур данных
4. count() - возвращает количество элементов в стриме
5. anyMatch() - возвращает true, если условие выполняется хотя бы для одного элемента
6. noneMatch() - возвращает true, если условие не выполняется ни для одного элемента
7. allMatch() - возвращает true, если условие выполняется для всех элементов
8. min() - возвращает минимальный элемент, в качестве условия использует компаратор
9. max() - возвращает максимальный элемент, в качестве условия используется компаратор
10. forEach() - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
11. forEachOrdered() - применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует
12. toArray() - возвращает массив значений стрима

[к оглавлению](#fp-lambda-stream-api)

## 14. Что такое ленивая загрузка?

Ленивая загрузка (Отложенная инициализация) подразумевает отказ от загрузки дополнительных данных, когда в этом нет 
необходимости. Вместо этого ставится маркер о том, что данные не загружены и их надо загрузить в случае, если они 
понадобятся. Как известно, если Вы ленивы, то вы выигрываете в том случае, если дело, которое вы не делали на самом деле
и не надо было делать

Таким образом работают стримы. Пока у стрима не вызван терминальный метод, все конвейрные предшествующие методы вызваны 
не будут.

[к оглавлению](#fp-lambda-stream-api)

## 15. Что делает метод filter?

`filter` промежуточная операция, используется для фильтрации через функцию.

Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>`
и возвращает новый поток из элементов, которые удовлетворяют этому условию.

[к оглавлению](#fp-lambda-stream-api)

## 16. Что делает метод map?

`map` промежуточная операция. Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.

`<R> Stream<R> map(Function<? super T, ? extends R> mapper) `
Передаваемая в метод `map` функция задает преобразование от объектов типа `T` к типу `R`.
И в результате возвращается новый поток с преобразованными объектами.

[к оглавлению](#fp-lambda-stream-api)

## 17. Что делает метод flatMap?

`flatMap` промежуточная операция. Плоское отображение похоже на `map`, но может создавать из одного элемента несколько.
Т.е. каждый объект будет преобразован в 0, 1 или несколько других объектов, поддерживаемых потоком.

`<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`

Например,

`List<List<Integer>> lists = List.of(List.of(1, 2), List.of(3, 4));`

`list.stream()` - получаем стрим из List<Integer>

`.flatMap(subList -> subList.stream())` получаем стрим из элементов

`.forEarch(el -> System.out.println(el))`

[к оглавлению](#fp-lambda-stream-api)

## 18. Что делает метод collect?

`collect` терминальная операция, преобразует поток в коллекцию.

Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций,
определенных в классе `Collectors`:
+ `toList()` преобразование к типу `List`
+ `toSet()` преобразование к типу `Set`
+ `toMap()` преобразование к типу `Map`

[к оглавлению](#fp-lambda-stream-api)

## 19. Что делает метод reduce?

Этот метод находит первый элемент стрима, он становится результатом, а потом уже начинает применять оператор к 
последующим элементам.

Пример,

`Integer sum = List.of(1, 2, 3).stream().reduce((n1, n2) -> n1 + n2).get();` // сумма 6

`Integer sum = List.of(1).stream().reduce((n1, n2) -> n1 + n2).get();` // сумма 1, т.к. найдем только один элемент

Метод `reduce` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
1. `Optional<T> reduce(BinaryOperator<T> accumulator)`
2. `T reduce(T identity, BinaryOperator<T> accumulator)`
3. `U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`

Первая форма возвращает результат в виде объекта `Optional<T>`. Например, вычислим произведение набора чисел:

```java
    Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
    Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
    System.out.println(result.get()); // 720
```

Объект `BinaryOperator<T>` представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
версию метода `reduce()`, которая в качестве первого параметра принимает `T identity`.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

```java
    Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
    String sentence = wordsStream.reduce("Результат:", (x,y)->x + " " + y);
    System.out.println(sentence); // Результат: мама мыла раму
```

Допустим мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения.
Для этого используем третью версию метода `reduce`:

```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));
    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);
    System.out.println(sum); // 117000
```

[к оглавлению](#fp-lambda-stream-api)

## 20. Что делает метод findFirst?

`findFirst` терминальная операция, возвращает первый элемент из стрима в виде обертки `Optional`

[к оглавлению](#fp-lambda-stream-api)

## 21. Возможно ли прервать выполнение потока по аналогии с break?


Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.

С Java 9 можно использовать `java takeWhile` - промежуточная операция, возвращает элементы до тех пор, пока они
удовлетворяют условию, т.е. предикат возвращает `true`.

Лучше использовать итератор:
```java
    Iterator<BuyOrderType> iter = market.buyOrders() // replace BuyOrderType with correct type here
                .stream()
                .filter(buyOrder -> buyOrder.price >= sellOrder.price)
                .sorted(BY_ASCENDING_PRICE).iterator();
    while (iter.hasNext()) {
        BuyOrderType buyOrder = iter.next()  // replace BuyOrderType with correct type here
        double tradeVolume = Math.min(buyOrder.quantity, sellOrder.quantity);
        double price = buyOrder.price;
        buyOrder.quantity -= tradeVolume;
        sellOrder.quantity -= tradeVolume;
        Trade trade = new Trade.Builder(market, price, tradeVolume, Trade.Type.SELL).build();
        CommonUtil.convertToJSON(trade);
        if (sellOrder.quantity == 0) {
            System.out.println("order fulfilled");
            break;
        }
    }
```

[к оглавлению](#fp-lambda-stream-api)

## 22. Возможно ли пропустить элемент потока по аналогии с continue?

Вместо этого можно использовать `filter` - промежуточная операция, фильтрует элементы по условию.

А также `return`:
```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");
        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.
            System.out.println(str); // a c
        });
    }
```

[к оглавлению](#fp-lambda-stream-api)

## 23. Что такое Optional?

В релизе Java 8 появился новый класс `Optional` призванный помочь разработчикам в обработке `NullPointerException`.

Опциональное значение `Optional` - это контейнер для объекта. Он может содержать значение или некоторый тип `<T>`, или
просто быть `null`.

Такая обертка является удобным средством предотвращения `NullPointerException`, т.к. имеет некоторые функции высшего
порядка, избавляющие от добавления повторяющихся `if null/not null` проверок, что позволяет фокусироватья на
выполнении непосредственной задачи.

```java
    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();
    
    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);
    
    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
```

Метод `ifPresent()` позволяет также устранить некоторую избыточность кода, следующего вида:
```java
     if(person != null) {
    	System.out.println(person);
     }
```
Те же действия, но с использованием `Optional`: 
```java
person.ifPresent(System.out::println);
```

`orElse()`, `orElseThrow()`:

Как было раньше:
```java 
Person personNew = person != null ? person : new Person();
```

То же самое, но с использованием `Optional`: 
```java 
Person personNew = person.orElse(new Person());
```

Или, если не хотим создавать объект, можно выбросить исключение:
```java 
Person personNewThrow = person.orElseThrow(Exception::new);
```

[к оглавлению](#fp-lambda-stream-api)

## 24. Перечислите методы Optional?

+ `Optional.empty()` - возвращает `Optional` с `null` внутри.
+ `Optional.of(T value)` - возвращает `Optional` с `not null` значением внутри.
+ `Optional.ofNullable(T value)` - возвращает `Optional` который может содержать `null` значение внутри.

Методы конкретного объекта `Optional`:
+ `filter(Predicate<? super T> predicate)` - дает возможность отфильтровать значение опционального типа.
  Мы передаем ему в параметр `Predicat` (это стандартный функциональный интерфейс), он возвращает булево значение.
  Если значение `true`, то возвращается этот же опционал,
  если значение `false`, то возвращается пустой опционал `Optional.empty()`.

+ `flatMap(Function<? super T,Optional<U>> mapper)` - применяется для изменения значения установленного в опционале.
  Функция которая передается в метод `flatMap` должна возвращать опционал.
  Если значение не установлено, вернется `Optional.empty()`.

+ `get()` - возвращает значение из объекта `Optional`. Нужно аккуратно использовать этот метод, т.к. он может бросить
  исключение `NoSuchElementException`, если значение в опционале равно `null`.
  Чтобы безопасно использовать этот метод, перед его вызовом надо вызвать метод `isPresent()`.

+ `isPresent()` - возвращает булево значение `true`, если в опционале значение есть и возвращает `false`,
  если в опционале значение `null`.

+ `orElse(T other)` - используется для того, чтобы установить значение по-умолчанию в том случае,
  если значение в опционале отсутствует.

+ `orElseGet(Supplier<? extends T> other)` - это аналог метода `orElse`,
  только принимает в себя функциональный интерфейс, который должен вернуть значение.

+ `orElseThrow(Supplier<? extends X> exceptionSupplier)` - используется для того, чтобы бросить исключение,
  которое передается в метод `orElseThrow`, если значения в опционале не установлено.

+ `ifPresent(Consumer<? super T> consumer)` - исполняет функциональный интерфейс `Consumer`, если значение в опционале
  присутствует. Т.е. в `ifPresent` передается функция, которая принимает один параметр - значение из `Optional`.

[подробнее](https://habr.com/ru/post/346782/)

[к оглавлению](#fp-lambda-stream-api)

## 25. Расскажите про фабричные методы List.of, Set.of, Map.of?

С приходом Java 9 создавать неизменяемые `immutable` коллекции `List`, `Set`, `Map` стало намного проще.
Фабричные методы позволяют преобразовывать элементы в потоки.

1. Создание списка `List<Integer> nums = List.of(1,2,3,4,5);`

   Метод `of()` в интерфейсе `List` перегружен и принимает от одного до десяти элементов.
   Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с `varargs`:
   `static <E> List<E> of(E... elements)`. Это сделано с целью оптимизации, т.к. при каждом вызове метода c `varargs`
   будет создаваться новый массив

2. Создание множества `Set<String> questions = Set.of("What?", "Where?", "When?");`

   Метод `of()` также имеет перегруженные методы, но в отличии от `List`, если передать дубликат в метод `of()`, то получим исключение
   `Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What?`

3. Создание карты `Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried");`

   Последовательности идут парами `key`, `value`. Всего таких пар может быть 10, в отличии от `List` и `Set`,
   если в последовательности будут повторения ключей - получим исключение
   `Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально`

Обратите внимание:
+ Вышеупомянутые коллекции нельзя изменить, при попытке получим `UnsupportedOperationException`.
+ В метод `of()` нельзя передать `null`, во всех коллекциях получим `NullPointerException`.
+ Метод `of()` не создает привычные `ArrayList`, `HashSet` или `HashMap`. В Java 9 были созданы специальные
  `ImmutableCollections` которые и возвращаются.
+ `ImmutableCollections` являются сериализуемыми, если содержимое тоже является сериализуемым.

[к оглавлению](#fp-lambda-stream-api)

## 26. Для чего используется ключевое слово var?

Нововведение Java 10 `var` аббревеатура `Local Variable Type-Inference`,
используется для вывода типов локальных переменных.

Дает возможность сократить объявления переменных используя ключевое слово `var`.
При обработке `var`, компилятор просматривает правую часть объявления,
так называемый инициализатор и использует его тип для переменной.

`var` доступна только для локальных переменных с инициализатором.
```java
     var first = 1;
     var second = 2;
     var rst = first + second;
     System.out.println(rst);
     
     var list = List.of(1, 2, 5);
     
     for(var item : items) {
        System.out.println(item);
     }
```

`var` это зарезервированное имя, но не ключевое слово (наряду с `true`, `false`, и `null`), что обеспечивает обратную
совестимость программ, использующих его.

`var` нельзя использовать для:
+ полей класса;
+ параметров методов;
+ переменных без знания (т.е. без инициализатора).

также `var`:
+ не будет работать, если инициализируется `null`.
+ не будет работать для нелокальных переменных.
+ нельзя использовать в лямбда-выражениях, т.к. им нужен явный целевой тип.
+ нельзя использовать в случае инициализации массива.

[к оглавлению](#fp-lambda-stream-api)

## 27. В каких случаях можно использовать var?

`var` может использоваться только в сочетании с данными, т.е. нужно обязательно инициализировать переменную.
Компилятору нужно знать тип переменной, а тип можно извлечь только из значения.

[к оглавлению](#fp-lambda-stream-api)
