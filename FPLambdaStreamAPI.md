## FP Lambda Stream API

[1. Что такое lambda выражение?](#1-Что-такое-lambda-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java.util.function.](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda - выражения операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda---выражения-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-stream-api)

[11. Расскажите, какие шаблоны проектирования используются внутри Stream API?](#11-Расскажите-какие-шаблоны-проектирования-используются-внутри-stream-api)

[12. Какие существуют способы создания стрима?](#12-Какие-существуют-способы-создания-стрима)

[13. Что такое конвейерные и терминальные операции?](#13-Что-такое-конвеййрные-и-терминальные-операции)

[14. Перечислите конвейерные (промежуточные) методы Stream API.](#14-Перечислите-конвейерные-промежуточные-методы-stream-api)

[15. Перечислите терминальные методы Stream API.](#15-Перечислите-терминальные-методы-stream-api)

[16. Что такое отложенное выполнение lambda?](#16-Что-такое-отложенное-выполнение-lambda)

[17. Что делает метод filter()?](#17-Что-делает-метод-filter)

[18. Что делает метод map()?](#18-Что-делает-метод-map)

[19. Что делает метод flatMap()?](#19-Что-делает-метод-flatmap)

[20. Что делает метод collect?](#20-Что-делает-метод-collect)

[21. Что делает метод findFirst?](#21-Что-делает-метод-findfirst)

[22. Что делает метод reduce?](#22-Что-делает-метод-reduce)

[23. Что делают методы min и max?](#23-Что-делают-методы-min-и-max)

[24. Что делают методы count, sum, average?](#24-Что-делают-методы-count-sum-average)

[25. Что делают методы forEach и peek?](#25-Что-делают-методы-foreach-и-peek)

[26. Что делают методы skip и limit?](#26-Что-делают-методы-skip-и-limit)

[27. Что делают методы allMatch(), noneMatch() и anyMatch()?](#27-Что-делают-методы-allmatch-nonematch-и-anymatch)

[28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?](#28-Что-делают-методы-maptoint-flatmaptoint-maptoobj)

[29. Что такое числовой поток?](#29-Что-такое-числовой-поток)

[30. Чем отличается Stream<Integer> от IntStream<int>?](#30-Чем-отличается-streaminteger-от-intstreamint)

[31. Что делает метод boxed?](#31-Что-делает-метод-boxed)

[32. Возможно ли прервать выполнение потока по аналогии с break?](#32-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[33. Возможно ли пропустить элемент потока по аналогии с continue?](#33-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[34. Что такое Optional?](#34-Что-такое-optional)

[35. Перечислите методы Optional?](#35-Перечислите-методы-optional)

[36. Расскажите про фабричные методы List.of, Set.of, Map.of?](#36-Расскажите-про-фабричные-методы-listof-setof-mapof)

[37. Для чего используется var?](#37-Для-чего-используется-var)

[38. В каких случаях можно использовать var?](#38-В-каких-случаях-можно-использовать-var)

## 1. Что такое lambda выражение?

Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен 
позже, один или несколько раз. 

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в **функциональном интерфейсе**.

Лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в 
Java.

+ #### Отложенное выполнение:

  Одним из ключевых моментов в использовании лямбд является отложенное выполнение. То есть мы определяем в одном месте 
  программы лямбда-выражение и затем можем его вызвать при необходимости неопределенное количество раз в различных частях
  программы.

+ #### Передача параметров в лямбда-выражение:

  Параметры лямбда-выражения должны соответствовать по типу параметрам метода из функционального интерфейса.

+ #### Лямбды и локальные переменные:
  
  Лямбда-выражение может использовать переменные, которые объявлены во вне в более общей области видимости - на уровне 
  класса или метода, в котором лямбда-выражение определено. Локальные переменные уровня метода мы также можем 
  использовать в лямбдах, но изменять их значение нельзя. Более того, мы не сможем изменить значение переменной, которая
  используется в лямбда-выражении, вне этого выражения.
  
[к оглавлению](#fp-lambda-stream-api)

## 2. Что такое функциональные интерфейсы?

Функциональный интерфейс - это интерфейс, который содержит только 1 абстрактный метод.

Основное назначение - использование в лямбда-выражениях, method reference или ссылок на конструкторы.
В функциональном интерфейсе методов может быть больше, чем один. Ограничение в один метод относится именно к абстрактным
методам, т.к. в java с 8 версии в интерфейсах для методов можно задавать код по умолчанию (default методы). 

В строке над описанием интерфейса можно использовать аннотацию `@FunctionalInterface`. Наличие такой аннотации перед
описанием интерфейса приводит к тому, что на этапе компиляции программного кода выполняется проверка на предмет того,
действительно ли интерфейс функциональный.

[к оглавлению](#fp-lambda-stream-api)

## 3. Перечислите функциональные интерфейсы из пакета java.util.function.

В JDK в пакете java.util.function встроены готовые функциональные интерфейсы, описывающие всевозможные варианты.
Это `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, `UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы

+ **Predicate<T>** - проверяет соблюдение некоторого условия.
  Если оно соблюдается, то возвращается значение `true`. В качестве параметра лямбда-выражение принимает объект типа `T`

+ **Function<T,R>** - представляет функцию перехода от объекта типа `T` к объекту типа `R`.

+ **Consumer<T>** - выполняет некоторое действие над объектом типа `T`, при этом ничего не возвращая.

+ **Supplier<T>** - не принимает никаких аргументов, но должен возвращать объект типа `T`.

+ **UnaryOperator<T>** - принимает в качестве параметра объект типа `T`,
  выполняет над ним операцию и возвращает результат операций в виде объекта типа `T`.

+ **BinaryOperator<T>** - принимает в качестве параметра два объекта типа `T`, выполняет над ними бинарную операцию
  и возвращает ее результат также в виде объекта типа `T`.

[подробнее](https://metanit.com/java/tutorial/9.3.php)

[к оглавлению](#fp-lambda-stream-api)

## 4. Что такое функции высшего порядка?

Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают другие функции в качестве 
своих результатов.

У языка Java — имеются функции высшего порядка в форме так называемых лямбда-выражений.

Основная идея: функции имеют тот же статус, что и другие объекты данных.
```java
Function<Integer,Integer>   f = x -> x + 3;
BiFunction<Function<Integer,Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
System.out.println(g.apply(f,7));
```

[к оглавлению](#fp-lambda-stream-api)

## 5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?

Все, которые могут принимать другие функции в качестве своих параметров или возвращать другие функции в качестве своих 
результатов. По моей логике это все из этого списка: `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, 
`UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы. 

[к оглавлению](#fp-lambda-stream-api)

## 6. Что такое ссылки на методы?

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод. Если лямбда выражения 
вызывают только один существующий метод, лучше ссылать на этот метод по его имени. Ссылки на методы (Method References)
- это компактные лямбда выражения для методов у которых уже есть имя.

Работают ссылки на методы при условии, что параметры и возвращаемый тип вызываемого метода и в лямбде совпадают.

Ссылки на методы бывают четырех видов:
+ `имя_класса::имя_статического_метода` ссылка на статический метод.
+ `объект_класса::имя_метода` на метода конкретного объекта (экземпляра).
+ `тип_объекта::имя_метода` на метод произвольного объекта конкретного типа.
+ `название_класса::new` ссылка на конструктор.

[к оглавлению](#fp-lambda-stream-api)

## 7. Что такое ссылки на конструкторы?

Можно в качестве параметров использовать конструкторы: `название_класса::new`, для дженериков `название_класса<T>::new`.

При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.

[к оглавлению](#fp-lambda-stream-api)

## 8. Расскажите о зоне видимости переменных в lambda выражениях? 

Лямбда-выражения имеют доступ к переменным в области видимости, в которой их определили.
Но доступ возможен только при условии, что переменные являются `effective final`,
то есть либо явно имеют модификатор `final`, либо не меняют своего значения после инициализации (константы).
Если переменной присваивается значение во 2й раз, то лямбда-выражение вызовет ошибку компиляции.

Можно ссылаться на:
+ `effective final` локальные переменные;
+ поля примитивных типов;
+ статические переменные.

[к оглавлению](#fp-lambda-stream-api)

## 9. Как быть в ситуации, если внутри lambda - выражения операторы могут выкинуть исключение?

Лямбда-выражение может генерировать исключение.
+ если тело лямбда-выражения может бросить проверяемое `checked` исключение, то оно должно быть объявлено в
  абстрактном методе целевого функционального интерфейса в выражении `throws`.
+ либо должно быть обработано внутри лямбда-выражения с помощью конструкции `try-catch-finally`.

Как известно из функциональных интерфейсов в `Stream API` нельзя выбрасывать контролируемые исключения.
Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
приходится оборачивать их в `RuntimeException`.

[подробней](https://www.codeflow.site/ru/article/java-lambda-exceptions)

[к оглавлению](#fp-lambda-stream-api)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности,
упростить операции фильтрации, сортировки и другие манипуляции с данными.

Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`.
Ключевым понятием в Stream API является поток данных.
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Все операции над потоками бывают 2х видов:
+ `terminal` терминальные или конечные операции возвращают конкретный результат (`void` или результат определенного типа).
+ `intermediate` промежуточные или конвейерные операции возвращают трансформированный поток.

Все потоки производят вычисления, в т.ч. в промежуточных операциях, только когда к ним применяется терминальная операция.
Т.е. в данном случае применяется отложенное выполнение.

Потоки не могут быть использованы повторно - как только была вызвана конечная операция, поток закрывается.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно
сократить запись выполняемых действий. Т.е. Stream API позволяет взаимодействовать с данными в функциональном стиле,
предоставляя их в качестве конечного потока данных.

[Javadoc](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)

[Полное руководство по Java 8 Stream API в картинках и примерах](https://annimon.com/article/2778)

[Шпаргалка Java программиста 4. Java Stream API](https://habr.com/ru/company/luxoft/blog/270383/)

[к оглавлению](#fp-lambda-stream-api)

## 11. Расскажите, какие шаблоны проектирования используются внутри Stream API?

Для построения потоков при работе со Stream используется шаблон проектирования Builder.

Builder - это порождающий шаблон проектирования, который позволяет создавать сложные объекты пошагово. Он позволяет 
использовать один и тот же код построения объекта для получения разных представлений объектов.

Например, у нас есть сложный объект, который для создания требует сложной пошаговой инициализации множества полей и 
вложенных объектов. Чтобы проинициализировать такой объект, необходимо использовать очень большой конструктор с 
множеством параметров, который при использовании становится абсолютно нечитаемым и чтобы контролировать вводимые 
параметры в том месте где определено их место - требуется постоянно возвращаться к объявленному конструктору.

Именно для таких случаев используется шаблон Строитель. Он предлагает решение такой проблемы путем вынесения 
конструирования объекта за пределы его собственного класса (или за счет вложенного статического класса), поручив это 
дело отдельным объектам.

Шаблон предлагает разбить процесс конструирования объекта на отдельные шаги . Чтобы создавать объекты таким образом, нам
нужно поочередно вызывать методы строителя (build + название поля в стиле CamelCase). При этом нам не нужно запускать 
все шаги, а только те, которые нужны для производства объекта определенной конфигурации. 

Последний элемент реализации шаблона - метод, который построит готовый объект и вернет его экземпляр (метод build).

[к оглавлению](#fp-lambda-stream-api)

## 12. Какие существуют способы создания стрима?

1. Из коллекции:
```java 
Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
```
2. Из набора значений:
```java 
Stream<String> fromValues = Stream.of("x", "y", "z");
```
3. Из массива:
```java 
Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
```
4. Из файла (каждая строка в файле будет отдельным элементом в стриме):
```java 
Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
```
5. Из строки:
```java 
IntStream fromString = "0123456789".chars();
```
6. С помощью `Stream.builder()`:
```java 
Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
```
7. С помощью `Stream.iterate()` (бесконечный):
```java 
Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
```
8. С помощью `Stream.generate()` (бесконечный):
```java 
Stream<String> fromGenerate = Stream.generate(() -> "0");
```

[к оглавлению](#fp-lambda-stream-api)

## 13. Что такое конвейерные и терминальные операции?

- Промежуточные (конвейерные). Преобразовывают элементы потока, возвращая новый преобразованный поток. Методов данного
  типа может быть сколько угодно в цепочке преобразований элементов потока. Данные методы ленивы, то есть отрабатывают
  только когда для потока вызван конечный метод. Промежуточных методов у потока может и не быть. Промежуточные операции 
  не выполняются без конечных! Промежуточные методы ленивы - они начинают вычисляться только когда начнется терминальная 
  операция, то есть вычисление происходит только тогда, когда оно нужно.

- Конечные (терминальные). Метод данного типа всегда один, располагается в конце цепочки промежуточных методов (если они 
  есть). Данный метод возвращает другой тип объекта (например, Optional, коллекцию и т.д.). То есть конечный метод 
  собирает результаты обработки элементов потока и возвращает единый результат. Конечный метод для завершения потока
  обязателен.

[к оглавлению](#fp-lambda-stream-api)

## 14. Перечислите конвейерные (промежуточные) методы Stream API.

1. filter() - Отфильтровывает записи, возвращает только записи соответствующие условию
2. distinct() - возвращает стрим без дубликатов (проверка на равенство методом equals)
3. peek() - возвращает тот же стрим, но применяет функцию к каждому элементу стрима
4. sorted() - позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator
5. limit() - позволяет ограничить выборку определенных количеством первых элементов
6. skip() - Позволяет пропустить N первых элементов
7. boxed() - позволяет получить стрим оберток из стрима примитивов
8. takeWhile() - позволяет брать из стрима только первые элементы, которые удовлетворяют определенному условию.
9. dropWhile() - позволяет пропустить из стрима первые элементы, которые удовлетворяют условию.
10. map() - преобразует каждый элемент стрима
11. mapToObj() - преобразует стрим примитивов в стрим объектов
12. mapToInt(), mapToDouble(), mapToLong() - аналоги map(), но возвращают стрим из примитивных типов
13. flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong() - создает из каждого элемента потока новые потоки по 
    некому правилу и объединяет получившиеся потоки в один.
    
[к оглавлению](#fp-lambda-stream-api)

## 15. Перечислите терминальные методы Stream API.

1. findFirst() - возвращает первый элемент из стрима (Возвращает Optional)
2. findAny() - возвращает любой подходящий элемент из стрима (Возвращает Optional)
3. collect() - представление результатов в виде коллекций и других структур данных
4. count() - возвращает количество элементов в стриме
5. anyMatch() - возвращает true, если условие выполняется хотя бы для одного элемента
6. noneMatch() - возвращает true, если условие не выполняется ни для одного элемента
7. allMatch() - возвращает true, если условие выполняется для всех элементов
8. min() - возвращает минимальный элемент, в качестве условия использует компаратор
9. max() - возвращает максимальный элемент, в качестве условия используется компаратор
10. forEach() - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
11. forEachOrdered() - применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует
12. toArray() - возвращает массив значений стрима

[к оглавлению](#fp-lambda-stream-api)

## 16. Что такое отложенное выполнение lambda?

Ленивая загрузка (Отложенная инициализация) подразумевает отказ от загрузки дополнительных данных, когда в этом нет
необходимости. Вместо этого ставится маркер о том, что данные не загружены и их надо загрузить в случае, если они
понадобятся. Как известно, если Вы ленивы, то вы выигрываете в том случае, если дело, которое вы не делали на самом деле
и не надо было делать

Таким образом работают стримы. Пока у стрима не вызван терминальный метод, все конвейерные предшествующие методы вызваны
не будут.

[к оглавлению](#fp-lambda-stream-api)

## 17. Что делает метод filter()?

`filter` промежуточная операция, используется для фильтрации через функцию.

Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>`
и возвращает новый поток из элементов, которые удовлетворяют этому условию.

[к оглавлению](#fp-lambda-stream-api)

## 18. Что делает метод map()?

`map` промежуточная операция. Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.

`<R> Stream<R> map(Function<? super T, ? extends R> mapper) `
Передаваемая в метод `map` функция задает преобразование от объектов типа `T` к типу `R`.
И в результате возвращается новый поток с преобразованными объектами.

[к оглавлению](#fp-lambda-stream-api)

## 19. Что делает метод flatMap()?

`flatMap` промежуточная операция. Плоское отображение похоже на `map`, но может создавать из одного элемента несколько.
Т.е. каждый объект будет преобразован в 0, 1 или несколько других объектов, поддерживаемых потоком.

`<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`

Например,

`List<List<Integer>> lists = List.of(List.of(1, 2), List.of(3, 4));`

`list.stream()` - получаем стрим из List<Integer>

`.flatMap(subList -> subList.stream())` получаем стрим из элементов

`.forEarch(el -> System.out.println(el))`

[к оглавлению](#fp-lambda-stream-api)

## 20. Что делает метод collect?

`collect` терминальная операция, преобразует поток в коллекцию.

Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций,
определенных в классе `Collectors`:
+ `toList()` преобразование к типу `List`
+ `toSet()` преобразование к типу `Set`
+ `toMap()` преобразование к типу `Map`

[к оглавлению](#fp-lambda-stream-api)

## 21. Что делает метод findFirst?

`findFirst` терминальная операция, возвращает первый элемент из стрима в виде обертки `Optional`

[к оглавлению](#fp-lambda-stream-api)

## 22. Что делает метод reduce?

Этот метод находит первый элемент стрима, он становится результатом, а потом уже начинает применять оператор к
последующим элементам.

Метод `reduce` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
1. `Optional<T> reduce(BinaryOperator<T> accumulator)`
2. `T reduce(T identity, BinaryOperator<T> accumulator)`
3. `U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`

Первая форма возвращает результат в виде объекта `Optional<T>`.
Объект `BinaryOperator<T>` представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
версию метода `reduce()`, которая в качестве первого параметра принимает `T identity`.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций.

Третья версия метода `reduce` используется для параллельного потока.

Таким образом, combiner вызывается только для параллельного потока. `combiner` – функция, принимающая два параметра:
частичный результат операции редукции и следующий элемент потока `combiner` – функция, используемая для объединения
частичного результата операции редукции при распараллеливании редукции или при несоответствии типов аргументов
накопителя и типов реализации накопителя.

[к оглавлению](#fp-lambda-stream-api)

## 23. Что делают методы min и max?

`min()` терминальный метод, который возвращает минимальный элемент, используя в качестве условия Comparator, либо 
natural ordering;

`max()` терминальный метод, который возвращает максимальный элемент, используя в качестве условия Comparator, либо
natural ordering;

[к оглавлению](#fp-lambda-stream-api)

## 24. Что делают методы count, sum, average?

### Для всех

`count()` терминальный метод, который возвращает количество элементов;

### Для числовых

`sum()` терминальный метод, который возвращает сумму всех чисел;

`average()` терминальный метод, возвращает среднее арифметическое всех чисел.

[к оглавлению](#fp-lambda-stream-api)

## 25. Что делают методы forEach и peek?

`forEach()` терминальный метод, который применяет функцию к каждому объекту (порядок при параллельном выполнении не 
гарантируется);

`peek()` конвейерный метод, который возвращает тот же стрим, применяя к каждому элементу функцию;

[к оглавлению](#fp-lambda-stream-api)

## 26. Что делают методы skip и limit?

`skip()` конвейерный метод, позволяет пропустить определённое количество элементов в начале;

`limit()` конвейерный метод, позволяет ограничить выборку определенным количеством первых элементов;

[к оглавлению](#fp-lambda-stream-api)

## 27. Что делают методы allMatch(), noneMatch() и anyMatch()?

`allMatch()` терминальный метод, который возвращает `true`, если условие выполняется для всех элементов;

`noneMatch()` терминальный метод, который возвращает `true`, если условие не выполняется ни для одного элемента;

`anyMatch()` терминальный метод, который возвращает `true`, если условие выполняется хотя бы для одного элемента;

[к оглавлению](#fp-lambda-stream-api)

## 28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?

Всё конвейерные методы:

`mapToInt()`, `mapToDouble()`,` mapToLong()` - аналоги map() возвращающие стрим числовых примитивов;

`flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - похожи на `map()`, но могут создавать из одного 
элемента несколько.

Для числовых стримов дополнительно доступен метод `mapToObj()`, который преобразует числовой стрим обратно в объектный.

[к оглавлению](#fp-lambda-stream-api)

## 29. Что такое числовой поток?

Чтобы обеспечить способ работы с тремя наиболее часто используемыми типами примитивов – `int`, `long` и `double` – 
библиотека `java.util.stream` включает три реализации стрима примитивов:

+ `IntStream`
+ `LongStream`
+ `DoubleStream`

Стримы примитивных типов данных имеют ряд уникальных методов, например диапазон и сумма всех элементов потока.

Методы диапазона доступны только для IntStream и LongStream.
Существует два метода получения стрима из диапазона чисел:

```java
range(int startInclusive, int endExclusive)
```

```java
rangeClosed(int startInclusive, int endInclusive)
```

В методе `range()` второй аргумент метода не входит в диапазон чисел, в то время как метод `rangeClosed()` включает его 
в диапазон.

[к оглавлению](#fp-lambda-stream-api)

## 30. Чем отличается Stream<Integer> от IntStream<int>?

По сути `IntStream<int>` обрабатывается как поток примитивных чисел

`mapToInt()` - преобразовывает поток объектов в поток примитивных чисел типа `int`. Является промежуточной операцией. 
Применяется, если исходящий поток состоит из элементов-объектов, а в результате их обработки будет получен примитивный 
тип `int`. Метод `mapToInt` возвращает объект интерфейса `IntStream` (числовой поток)

`flatMapToInt()` - трансформирует поток массивов в поток примитивных чисел `int`. Работает как `mapToInt()`, но 
возвращает не одно преобразованное в `int` значение, а поток примитивов `int`. Является промежуточной операцией.

`mapToObj()` - преобразует поток примитивных чисел в поток объектов. Является промежуточной операцией.

[к оглавлению](#fp-lambda-stream-api)

## 31. Что делает метод boxed?

Примитивные числа не являются объектами, поэтому для того, чтобы собрать в `List` наш поток элементов типа `int`, нужно
обернуть их в тип `Integer`. Это можно сделать с помощью метода `boxed()`

[к оглавлению](#fp-lambda-stream-api)

## 32. Возможно ли прервать выполнение потока по аналогии с break?

Stream может выполняться в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.

С Java 9 можно использовать операцию `takeWhile` - промежуточная операция, возвращает элементы до тех пор, пока они
удовлетворяют условию, т.е. предикат возвращает `true`.

[к оглавлению](#fp-lambda-stream-api)

## 33. Возможно ли пропустить элемент потока по аналогии с continue?

Вместо этого можно использовать `filter` - промежуточная операция, фильтрует элементы по условию.

А также `return`:
```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");
        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.
            System.out.println(str); // a c
        });
    }
```

[к оглавлению](#fp-lambda-stream-api)

## 34. Что такое Optional?

В релизе Java 8 появился новый класс `Optional` призванный помочь разработчикам в обработке `NullPointerException`.

Опциональное значение `Optional` - это контейнер для объекта. Он может содержать значение или некоторый тип `<T>`, или
просто быть `null`.

Такая обертка является удобным средством предотвращения `NullPointerException`, т.к. имеет некоторые функции высшего
порядка, избавляющие от добавления повторяющихся `if null/not null` проверок, что позволяет фокусироватья на
выполнении непосредственной задачи.

[к оглавлению](#fp-lambda-stream-api)

## 35. Перечислите методы Optional?

+ `Optional.empty()` - возвращает `Optional` с `null` внутри.
+ `Optional.of(T value)` - возвращает `Optional` с `not null` значением внутри.
+ `Optional.ofNullable(T value)` - возвращает `Optional` который может содержать `null` значение внутри.

Методы конкретного объекта `Optional`:
+ `filter(Predicate<? super T> predicate)` - дает возможность отфильтровать значение опционального типа.
  Мы передаем ему в параметр `Predicat`, он возвращает булево значение. Если значение `true`, то возвращается этот же 
  опционал, если значение `false`, то возвращается пустой опционал.

+ `flatMap(Function<? super T,Optional<U>> mapper)` - применяется для изменения значения установленного в опционале.
  Функция которая передается в метод `flatMap` должна возвращать опционал.
  Если значение не установлено, вернется `Optional.empty()`.

+ `get()` - возвращает значение из объекта `Optional`. Нужно аккуратно использовать этот метод, т.к. он может бросить
  исключение `NoSuchElementException`, если значение в опционале равно `null`.
  Чтобы безопасно использовать этот метод, перед его вызовом надо вызвать метод `isPresent()`.

+ `isPresent()` - возвращает булево значение `true`, если в опционале значение есть и возвращает `false`,
  если в опционале значение `null`.

+ `orElse(T other)` - используется для того, чтобы установить значение по-умолчанию в том случае,
  если значение в опционале отсутствует.

+ `orElseGet(Supplier<? extends T> other)` - это аналог метода `orElse`,
  только принимает в себя функциональный интерфейс, который должен вернуть значение.

+ `orElseThrow(Supplier<? extends X> exceptionSupplier)` - используется для того, чтобы бросить исключение,
  которое передается в метод `orElseThrow`, если значения в опционале не установлено.

+ `ifPresent(Consumer<? super T> consumer)` - исполняет функциональный интерфейс `Consumer`, если значение в опционале
  присутствует. Т.е. в `ifPresent` передается функция, которая принимает один параметр - значение из `Optional`.

[подробнее](https://habr.com/ru/post/346782/)

[к оглавлению](#fp-lambda-stream-api)

## 36. Расскажите про фабричные методы List.of, Set.of, Map.of?

С приходом Java 9 создавать неизменяемые `immutable` коллекции `List`, `Set`, `Map` стало намного проще.
Фабричные методы позволяют преобразовывать элементы в потоки.

1. Создание списка `List<Integer> nums = List.of(1,2,3,4,5);`

   Метод `of()` в интерфейсе `List` перегружен и принимает от одного до десяти элементов.
   Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с `varargs`:
   `static <E> List<E> of(E... elements)`. Это сделано с целью оптимизации, т.к. при каждом вызове метода c `varargs`
   будет создаваться новый массив

2. Создание множества `Set<String> questions = Set.of("What?", "Where?", "When?");`

   Метод `of()` также имеет перегруженные методы, но в отличии от `List`, если передать дубликат в метод `of()`, то 
   получим исключение 
   `Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What?`

3. Создание карты `Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried");`

   Последовательности идут парами `key`, `value`. Всего таких пар может быть 10, в отличии от `List` и `Set`,
   если в последовательности будут повторения ключей - получим исключение
   `Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально`

Обратите внимание:
+ Вышеупомянутые коллекции нельзя изменить, при попытке получим `UnsupportedOperationException`.
+ В метод `of()` нельзя передать `null`, во всех коллекциях получим `NullPointerException`.
+ Метод `of()` не создает привычные `ArrayList`, `HashSet` или `HashMap`. В Java 9 были созданы специальные
  `ImmutableCollections` которые и возвращаются.
+ `ImmutableCollections` являются сериализуемыми, если содержимое тоже является сериализуемым.

[к оглавлению](#fp-lambda-stream-api)

## 37. Для чего используется var?

Нововведение Java 10 `var` аббревеатура `Local Variable Type-Inference`, используется для вывода типов локальных переменных.

Дает возможность сократить объявления переменных используя ключевое слово `var`. При обработке `var`, компилятор 
просматривает правую часть объявления, так называемый инициализатор и использует его тип для переменной.

`var` доступна только для локальных переменных с инициализатором.
```java
     var first = 1;
     var second = 2;
     var rst = first + second;
     System.out.println(rst);
     
     var list = List.of(1, 2, 5);
     
     for(var item : items) {
        System.out.println(item);
     }
```

`var` это зарезервированное имя, но не ключевое слово (наряду с `true`, `false`, и `null`), что обеспечивает обратную
совестимость программ, использующих его.

`var` нельзя использовать для:
+ полей класса;
+ параметров методов;
+ переменных без знания (т.е. без инициализатора).

также `var`:
+ не будет работать, если инициализируется `null`.
+ не будет работать для нелокальных переменных.
+ нельзя использовать в лямбда-выражениях, т.к. им нужен явный целевой тип.
+ нельзя использовать в случае инициализации массива.

[к оглавлению](#fp-lambda-stream-api)

## 38. В каких случаях можно использовать var?

`var` может использоваться только в сочетании с данными, т.е. нужно обязательно инициализировать переменную.
Компилятору нужно знать тип переменной, а тип можно извлечь только из значения.

[к оглавлению](#fp-lambda-stream-api)
