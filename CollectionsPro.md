## Collections Pro

[1. Что такое generic?](#1-Что-такое-generic)

[2. Что такое wild cards?](#2-Что-такое-wild-cards)

[3. Что такое bounded wild cards?](#3-Что-такое-bounded-wild-cards)

[4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)

[5. Где хранится информация про Generics?](#5-Где-хранится-информация-про-generics)

[6. Как можно получить тип Generics?](#6-Как-можно-получить-тип-generics)

[7. Что такое итератор? В чем разница между itetator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница?  Когда возникает ConcurrentModificationException?](#7-Что-такое-итератор-В-чем-разница-между-itetator-и-listiterator-Что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-Когдаа-возникает-concurrentmodificationexception)

[8. Что такое коллекции?](#8-Что-такое-коллекции)

[9. Назовите базовые интерфейсы коллекций?](#9-Назоваите-базовые-интерфейсы-коллекций)

[10. Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-list)

[11. Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-set)

[12. Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-map)

[13. Отличие ArrayList от LinkedList?](#13-Отличие-arraylist--linkedlist)

[14. Отличие Set от List?](#14-Отличие-set-от-list)

[15. Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-object-hashcode-и-equals)

[16. Расскажите про реализации Map?](#16-Расскажите-про-реализации-map)

[16. Расскажите, что такое коллизии в Map? Как с ними бороться?](#16-Расскажите-что-такое-коллизии-в-map-как-с-ними-бороться)

[17. Расскажите, что такое анализ алгоритма?](#17-Расскажите-что-такое-анализ-алгоритма)

[18. Какая временная сложность алгоритмов(O нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#18-Какая-временная-сложность-o-нотация-добавления-замены-и-удаления-в-каждой-из-коллекций-с-чем-связаны-отличия)

[19 Расскажите реализации данных очередей и стеков](#19-Расскажите-реализации-данных-очередей-и-стеков)

[20. Расскажите про реализации деревьев](#20-Расскажите-про-реализации-деревьев)

[21. Что такое loadFactor?](#21-Что-такое-loadfactor)

[22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.](#22-Перечислите-побитовые-логические-операции-которые-вы-знаете-Расскажите-как-они-работают)

[23. Расскажите про операции сдвига. Какие они бывают и что делают?](#23-Расскажите-про-операции-сдвига-Какие-они-бывают-и-что-делают)

[24. Как хранится знак числа в Java? Как хранятся отрицательные числа?](#24-Как-хранится-знак-числа-в-java-Как-хранятся-отрицательные-числа)

[25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?](#25-Расскажите-о-системах-сборки-проекта-В-чем-отличие-систем-сборки-ant-maven-и-gradle)

[26. Как создать maven - проект?](#26-Как-создать-maven---проект)

[27. Какова структура maven-проекта?](#27-Какова-структура-maven-проекта)

[28. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?](#28-Расскажите-о-файле-pomxml-Как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)

[29. Что такое координаты зависимости?](#29-Что-такое-координаты-зависимости)

[30. Что такое транзитивные зависимости?](#30-Что-такое-транзитивные-зависимости)

[31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#31-Что-такое-область-видимости-зависимости-Сколько-областей-видимости-предусмотрено-и-где-они-применяются)

[32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#32-Расскажите-о-жизненном-цикле-maven-В-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

## 1. Что такое generic?

**Дженерики** (обобщения) - это особые средства языка Java для реализации обобщенного программирования: особого подхода 
к описанию данных и алгоритмов, позволяющего работать с различными типами данных без изменения их описания. Это 
параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.

Начиная с JDK 1.5, в Java появляются новые возможности для программирования. Одним из таких нововведений являются 
Generics. Generics позволяют абстрагировать множество типов. Наиболее распространенными примерами являются Коллекции.
Обычно Generics используют в тех случаях, когда с помощью класса реализуется некоторая "структура" или
"конструкция", которая имеет универсальные характеристики и слабо зависит от конкретного типа данных, с которыми
приходится оперировать. 

В Java дженерики добавили для реализации обобщенных коллекций, безопасных с точки зрения типов. 
Ошибка компиляции - это лучше, чем исключение `ClassCastException` в связи с неправильным приведением типов во время 
выполнения.

Эффект от Generics особенно проявляется в крупных проектах: он улучшает читаемость и надежность кода в целом.

Свойства дженериков: строгая типизация, единая реализация, отсутствие информации о типе.

[к оглавлению](#Collections-Pro)

## 2. Что такое wild cards?

**Wildcards** - это специальные вопросительные знаки, отмечающие место, где должно оказаться название параметра типа. 
Они являются средством выражения ограничений в условиях неизвестности какого-нибудь типа. Wildcards играют важную роль в 
системе типов. Они позволяют задать границы для семейства типов, определенных каким-нибудь generic-классом. Они 
используются в сочетании с ключевыми словами `extends` и `super`.

Для выбора типа используют принцип PECS (`Producer Extends` `Consumer Super`)
+ `extends` - когда надо только получать данные из объекта. Метод передает данные в аргумент.
+ `super` - когда надо только вставлять данные в объект. Метод читает данные из аргумента.
+ не использовать `wildcard`, когда требуется и получать и вставлять данные в структуру.

[к оглавлению](#Collections-Pro)

## 3. Что такое bounded wild cards?

**Bound wild cards** - это ограничение сверху или снизу, для `upper bounded wildcard` имеет вид <? extends P> и для 
`lower bounded wildcard` <? super P>. Где `P` представляет собой границу.

`List<? extends Number>` может содержать объекты, класс которых является Number или наследуется от Number. 

`List<? super Number>` может содержать объекты, класс которых Number или у которых Number является наследником.

[к оглавлению](#Collections-Pro)

## 4. Что такое unbounded wild cards?

**Unbounded wild cards** - это дженерики вида <?>, что означает, что тип может быть чем угодно, т.е. он имеет 
соответствие с любым типом. По сути это wildcard с неограниченным символом подстановки.

На самом деле такой "неограниченный" wildcard всё-таки ограничен, сверху. Запись вида Collection<?> равносильна 
Collection<? extends Object>, а значит - коллекция может содержать объекты любого класса, так как все классы в Java 
наследуются от Object - поэтому подстановка называется неограниченной.

[к оглавлению](#Collections-Pro)

## 5. Где хранится информация про Generics?

Только в исходном коде до момента компиляции

[к оглавлению](#Collections-Pro)

## 6. Как можно получить тип Generics?

По сути это невозможно, если речь о runtime'e, т.к. все стирается до Object'a, если речь не идет о классах, которые 
наследовались от дженерик-класса с конкретными типами, то можно через отражение (reflection) получить эту информацию.

```java
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;

public class FloatList extends ArrayList<Float> {
    public static void main(String[] args) {
        ArrayList<Float> list = new FloatList();
        Class actual = list.getClass();
        ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
        System.out.println(type);
        Class parameter = (Class) type.getActualTypeArguments()[0];
        System.out.println(parameter);
    }
}
```

[к оглавлению](#Collections-Pro)

## 7. Что такое итератор? В чем разница между itetator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница?  Когда возникает ConcurrentModificationException?

Шаблон "итератор" позволяет последовательно получить элементы набора данных. Шаблон итератор описывается интерфейсом - 
`java.util.Iterator`. Шаблон итератор используется в коллекциях, базах данных, чтении файлов.

Основные методы:
`hasNext()` - проверяет, есть ли следующий элемент.
`next()` - возвращает первый элемент ячейки. Второй вызов метода вернет второй элемент и т.д. Сдвигает указатель 
итератора. Указатель - это ссылка на элемент, котрый нужно вернуть.

В стандартной бибилиотеке Java существует 2 интерфейса это `Iterable` и `Iterator`:
+ `Iterable` - вынуждает реализовать метод возвращающий итератор.
+ `Iterator` - вернуть объект итератора.

---

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`.
  `ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`.
  `ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
  `remove()`. Iterator не поддерживает данного функционала.

---

Fail-fast и fail-safe представляют две разные стратегии обработки ошибок, применяемые при работе с коллекциями в Java.

Итераторы fail-fast были добавлены в Java для обеспечения безопасности при работе с многопоточными коллекциями. Они 
основаны на модели "чистого" итератора, который не позволяет изменять список, пока он перебирается. Если во время 
перебора элементов коллекции происходит изменение структуры коллекции (например, добавление или удаление элемента), то
итератор быстро завершает работу и выбрасывает исключение ConcurrentModificationException, чтобы предотвратить возможные
ошибки в работе программы

Итераторы fail-safe предоставляют альтернативный подход для работы с коллекциями. Они не используют блокировку при 
доступе к коллекции и не генерируют исключение ConcurrentModificationException при изменении коллекции во время итерации.
Вместо этого они работают с копией коллекции, которая создается перед началом итерации, и гарантируют, что оригинальная
коллекция не будет изменена никаким другим потоком во время итерации. Это обеспечивает более предсказуемое поведение 
итератора, но может приводить к неожиданному поведению в случае изменения коллекции другим потоком.

Таким образом, основная разница между fail-fast и fail-safe заключается в том, что fail-fast выбрасывает исключение при
обнаружении изменений в коллекции, а fail-safe работает с копией коллекции, чтобы избежать конфликтов при изменении 
коллекции другим потоком. Решение о том, какой тип итератора использовать, зависит от требований проекта и особенностей 
работы с коллекцией. Если коллекция используется только в одном потоке или изменения происходят редко, то можно
использовать итераторы fail-fast. Если же коллекция используется в многопоточной среде или изменения происходят часто, 
то следует использовать итераторы fail-safe.

[к оглавлению](#Collections-Pro)

## 8. Что такое коллекции?

**Коллекции** - это хранилища, поддерживающие различные способы накопления и упорядочивания объектов с целью обеспечения
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#Collections-Pro)

## 9. Назовите базовые интерфейсы коллекций?

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы 
разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы
элементов и наборы пар "ключ - значение" соответственно.

Интерфейс `Collection` расширяют интерфейсы:

+ `List` (список) представляет собой коллекцию, в которой допустимы дублирующие значения.
+ `Set` (множество) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов.
+ `Queue` (очередь) предназначена для хранения элементов с предопределенным способом вставки и извлечения FIFO 
  (first-in-first-out).

[к оглавлению](#Collections-Pro)

## 10. Расскажите реализации интерфейса List?

**`ArrayList`** - В основе реализации этого списка лежит массив. Но при этом ArrayList позволяет справиться с самой 
важной проблемой массивов - неизменяемость размера массива. Это значит, что ArrayList может менять свой размер во 
время исполнения программы и при этом нет строгого требования указывать размерность при создании объекта ArrayList.

**`LinkedList`** - класс, который реализует два интерфейса `List` и `Deque`. Этим обеспечивает возможность создавать 
двунаправленные(те, которые можно обходить в обоих направлениях) очереди из любых(в том числе и null) элементов. Каждый 
объект помещенный в связанный список, является узлом (для этого используются объекты вложенного класса Node). Каждый 
узел содержит в себе элемент который мы добавили, а также ссылку на предыдущий и следующий узел.

**`Vector`** - реализует динамический массив. Он похож на ArrayList, но с двумя отличиями:

+ Vector синхронизирован.
+ Vector содержит много устаревших методов, который не являются частью структуры коллекций.

**`Stack`** - является подклассом Vector, реализация стека LIFO (last-in-first-out).

[к оглавлению](#Collections-Pro)

## 11. Расскажите реализации интерфейса Set?

**`HashSet`** - HashSet инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом 
ключами в таблице будут значения, которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - будут 
значения null. Для того, чтобы использовать HashSet для хранения объектов, в классах этих объектов необходимо 
переопределять методы hashCode() и equals(). Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс 
хэширования не позволяет сделать в итоге отсортированный набор данных.

**`LinkedHashSet`** - расширяет класс HashSet, гарантирует, что порядок элементов при обходе коллекции будет идентичен 
порядку добавления элементов.

**`TreeSet`** - представляет собой структуру данных в виде дерева, в котором все объекты хранятся в отсортированном по 
возрастанию порядке. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное 
красно-черное дерево для хранения элементов.

[к оглавлению](#Collections-Pro)

## 12. Расскажите реализации интерфейса Map?

**`HashMap`** - реализация карты на основе хеш-таблицы. Поиск и вставка пар занимает небольшое постоянное время. 
Производительность можно настроить, указав в конструкторах особые значения для *емкости* и *коэффициента загрузки*.

**`LinkedHashMap`** - Похожа на HashMap, однако при переборе выдает пары в порядке их добавления, или согласно принципу
LRU("наименее используемые идут первыми", least-recently-used). Лишь немногим медленнее HashMap, за исключением процесса
перечисления элементов, где она быстрее за счет внутреннего связанного списка, отвечающего за хранение порядка 
добавления элементов.

**`TreeMap`** - Реализация карты на базе красно-черного дерева. При просмотре ключей или пар видно, что они соблюдают
определенный порядок (который определяется интерфейсами Comparable или Comparator). Область применения карты TreeMap - 
выдача результатов в отсортированном виде. Карта TreeMap - единственная карта с методом subMap(), который позволяет
выделять из карты некоторую её часть.

**`WeakHashMap`** - Карта, состоящая из "слабых" ключей, которые не препятствуют освобождению объектов, на которые 
ссылается карта. Разработана для решения определенного класса задач. Если за пределами карты ссылок на ключ нет, он 
может быть удален уборщиком мусора.

**`ConcurrentHashMap`** - Потоко-безопасная версия Map, не использующая синхронизационную блокировку.

**`IdentityHashMap`** - Хеш-таблица, использующая для сравнения ключей оператор == вместо метода equals(). Применяется
в особых случаях, не для рядовых целей.

[к оглавлению](#Collections-Pro)

## 13. Отличие ArrayList от LinkedList?

`ArrayList` это список, реализованный на основе массива, а `LinkedList` — это классический двусвязный список, основанный
на объектах с ссылками между ними.

`ArrayList`:
+ доступ к произвольному элементу по индексу за константное время O(1);
+ доступ к элементам по значению за линейное время O(N);
+ вставка в конец в среднем производится за константное время O(1);
+ удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее»
  смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
+ вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся 
  «правее» смещаются на одну ячейку вправо;
+ минимум накладных расходов при хранении.

`LinkedList`:
+ на получение элемента по индексу или значению потребуется линейное время O(N);
+ на добавление и удаление в начало или конец списка потребуется константное O(1);
+ вставка или удаление в/из произвольного место константное O(1);
+ требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще 
  указатели на следующий и предыдущий элементы списка.

В целом, `LinkedList` в абсолютных величинах проигрывает `ArrayList` и по потребляемой памяти, и по скорости выполнения 
операций. `LinkedList` предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда 
необходимо гарантированное время добавления элемента в список.

[к оглавлению](#Collections-Pro)

## 14. Отличие Set от List?

**`List<E>`** - упорядоченная коллекция (также известная как список). Пользователь этого интерфейса имеет полный 
контроль над тем, где в списке каждый элемент вставлен. Пользователь может получить доступ к элементам по их 
целочисленному индексу (позиция в списке) и искать элементы.

**`Set<E>`** - это множество. Коллекция, которая не содержит повторяющихся элементов. 

[к оглавлению](#Collections-Pro)

## 15. Расскажите про методы Object hashCode и equals?

`Equals` и `hashCode` являются фундаментальными методами объявленные в классе `Object` и содержатся в стандартных
библиотеках Java.

Метод `equals()` используется для сравнения объектов, а `hashCode()` - для генерации целочисленного кода объекта.
Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в `HashMap`. Метод
`equals` также используется для обеспечения хранения только уникальных объектов в `HashSet` и других `Set` реализациях,
а также в любых других случаях, когда нужно сравнивать объекты.

Реализация по умолчанию метода `equals()` в классе `java.lang.Object` сравнивает ссылки на адреса в памяти, которые
хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные ссылаются
на один и тот же объект.

Java рекомендует переопределять методы `equals()` и `hashCode()`, если предполагается, что сравнение должно
осуществляться в соответствии с бизнес-логикой.

Так как `HashMap` в Java полагается на методы equals() и hashCode() для сравнения своих `key` и `values`, то Java
предлагает следующие правила для переопределения этих методов:

1. Рефлексивность: Объект должен равняться себе самому.

2. Симметричность: если `a.equals(b)` возвращает `true`, то `b.equals(a)` должен тоже вернуть `true`.

3. Транзитивность: если `a.equals(b)` возвращает `true` и `b.equals(с)` тоже возвращает `true`, то `c.equals(a)` тоже
   должен возвращать `true`.

4. Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение до тех пор, пока какое-либо
   значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их
   свойства остаются неизменными.

5. Сравнение `null`: объект должен быть проверен на `null`. Если объект равен `null`, то метод должен вернуть `false`,
   а не `NullPointerException`. Например `a.equals(null)` должен вернуть `false`.

Соглашение между `equals` и `hashCode` в Java:

1. Если объекты равны по результатам выполнения метода `equals`, тогда их `hashCode` должны быть одинаковыми.

2. Если объекта не равны по результатам выполнения метода `equals`, тогда их `hashCode` могут быть как одинаковыми, так
   и разными. Однако для повышенной производительности, лучше, чтобы разные объекты возвращали разные коды.
   
**Метод `equals()` переопределяется так:**
1. Не равны ли ссылки.
2. Не равен `null`.
3. Проверяем что объекты от одного класса.
4. Не равны ли `hashCode`.
5. Не равны состояния полей.

**Метод `hashCode()` переопределяется так:**
1. Сохраните некоторое ненулевое значение (скажем 17) в целочисленной (int) переменной с названием result.
2. Для каждого значимого поля f в вашем классе (значимое поле - это то, которое учитывает метод equals()) вычислите целое (int) значение хеш-кода c. 

Тип данных | Вычисления
--- | --- 
Boolean | c = (f ? 0 : 1)
byte, char, short или int | c = (int) f
long | c = (int) (f ^ (f >>> 32))
float | c = Float.floatToIntBits(f)
double | long l = Double.doubleToLongBits(f);c = (int) (l ^ (l >>> 32));
Object, где метод equals() вызывает equals() для каждого поля | c = f.hashCode()
Массив | К каждому элементу применяются описанные выше правила

3. Скомбинируйте хеш-коды, полученные по указанным формулам: result = 37 * result + c;
4. Верните result;

[к оглавлению](#Collections-Pro)

## 16. Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизия - это ситуация, когда не эквивалентные элементы имеют одинаковые хеш-коды. Возникает оттого, что количество
значений хеш-функций меньше (ограничены диапазоном значений типа `int 2^32`), чем вариантов исходных данных.
Вероятность возникновения коллизий оценивает качество хеш-функций.

По простому:

**Коллизия** - это когда для двух объектов вычисляется одинаковый индекс при вычислении хеш-кода и хеша.

Решение: проверить методом `equals()`, что объекты не равны. Для хэш-таблицы в тот же бакет добавляется еще один объект
в конец списка, за счет того что каждая ячейка - это связанный список.

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине
превышает определенное значение, данная корзина переходит от использования связного списка к использованию
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок.
Т.е. при использовании данных типа `int` или `double` имеет смысл переходить к дереву поиска, а при использовании
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс.
Такой подход позволяет улучшить производительность с `O(n)` до `O(log(n))`.

[к оглавлению](#Collections-Pro)

## 17. Расскажите, что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью.

Временная сложность алгоритма – это функция, позволяющая определить,
как быстро увеличивается время работы алгоритма с увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:
+ `O(1)` – константная сложность (т.е. константное время);
+ `О(n)` – линейная сложность;
+ `О(nа)` – полиномиальная сложность;
+ `О(log(n))` – логарифмическая сложность;
+ `O(n*log(n))` – квазилинейная сложность;
+ `O(2n)` – экспоненциальная сложность;
+ `O(n!)` – факториальная сложность.

**Мышление в терминах Big O**
+ Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O 
  это будет O(1)
+ Перебор коллекции это O(n)
+ Вложенные циклы по той же коллекции это O(n^2)
+ Разделяй и властвуй (Divide and Conquer) всегда O(log n)
+ Итерации которые используют Divide and Conquer это O(n log n)

[к оглавлению](#Collections-Pro)

## 18. Какая временная сложность алгоритмов(O нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.

+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.

+ **Деревья** для всех операций - `O(log(n))`.

+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.

[Справочник по Java Collections Framework](https://habr.com/ru/post/237043/)

[к оглавлению](#Collections-Pro)

## 19. Расскажите реализации данных очередей и стеков

**`ArrayDeque`** - создает двунаправленную очередь. Реализует интерфейс Deque.

**`LinkedList`** - это двусвязный список. Реализует сразу два интерфейса - List, Deque.

**`PriorityQueue`** - это класс очереди с приоритетом. По умолчанию очередь с приоритетами размещает элементы согласно 
естественному порядку сортировки используя Comparable. Элементу с наименьшим значением присваивается наибольший 
приоритет. Если несколько элементов имеют одинаковый наивысший элемент - связь определяется произвольно. Также можно 
указать специальный порядок размещения, используя Comparator.

**`Stack`** - является подклассом Vector и реализовывает структуру “крайний на вход – первый на выход”.

[к оглавлению](#Collections-Pro)

## 20. Расскажите про реализации деревьев

+ **`TreeMap`** - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в 
  конструкторе. Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты 
  дерева от числа узлов.

+ **`TreeSet`** - инкапсулирует в себе TreeMap, тем самым перенимает все свойства. Добавляемые значения выступают 
  ключами, а соответствующие ключам значения - null значения.

[к оглавлению](#Collections-Pro)

## 21. Что такое loadFactor?

**loadFactor** - коэффициент заполнения HashMap, при превышении которого происходит увеличение количества корзин и 
автоматическое перехэширование. Равен отношению числа уже хранимых элементов в таблице к её размеру.

[к оглавлению](#Collections-Pro)

## 22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

- **Побитовое "ИЛИ" ( | )** В результирующий бит будет записана единица, если хотя бы один операнд равен единице.
- **Побитовое "И" (&)** В результирующий бит будет записана единица только в том случае, если оба операнда равны единице.
- **Побитовое "Исключающее ИЛИ" (^)** По-другому называется XOR (исключение - X, или - OR).  В результирующий бит будет 
  записана единица только в том случае, если операнды не равны между собой.
- **Унарная операция "НЕ" (~)** По-другому называется поразрядным отрицанием. Инвертирует все двоичные разряды числа, то 
  есть меняет значение каждого разряда на противоположное.

[к оглавлению](#Collections-Pro)

## 23. Расскажите про операции сдвига. Какие они бывают и что делают?

- **Беззнаковый сдвиг влево (<<)**

Сдвигает двоичное представление первого операнда влево на количество бит, заданное во втором операнде, знак числа не сохраняется. Младшие(крайние правые) биты при этом заполняются нулями. Сдвиг на 1 бит влево соответствует умножению на 2.

Примеры:

`27 (11011) << 1 = 54 (110110)`

`-5 (1111 1111 1111 1111 1111 1111 1111 1011) << 1 = -10 (1111 1111 1111 1111 1111 1111 1111 0110)`

Если число выходит за границы диапазона типа int, крайний бит (знак числа) теряется:

`2 147 483 647 (0111 1111 1111 1111 1111 1111 1111 1111) << 1 = -2 (1111 1111 1111 1111 1111 1111 1111 1110)`

- **Знаковый сдвиг вправо (>>)**

Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во втором операнде, знак числа 
сохраняется. Старшие(крайние левые биты) заполняются ведущими нулями (при сдвиге положительного числа) или единицами 
(при сдвиге отрицательного числа). Сдвиг на 1 бит вправо соответствует делению на 2:

`24 (11000) >> 1 = 12 (1100)`

`-4 (1111 1111 1111 1111 1111 1111 1111 1100) >> 1 = -2 (1111 1111 1111 1111 1111 1111 1111 1110)`

- **Беззнаковый сдвиг вправо(>>>)**

Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во втором операнде, знак числа не 
сохраняется. Для положительных чисел работает как деление:

`24 (11000) >>> 1 = 12 (1100)`

`-24 (1111 1111 1111 1111 1111 1111 1110 1000) >>> 1 = 2147483636 (0111 1111 1111 1111 1111 1111 1111 0100)`

Можно увидеть, что знаковый бит был заменён нулём.

Беззнакового(логического) сдвига _влево_ не существует, потому что такой сдвиг не оказывает влияния на старший значащий 
бит(MSB) - крайний левый бит числа, изменяются только крайние правые биты. Кроме того, в процессорах семейства 8086 
арифметический и логический сдвиг выполняют одну и ту же операцию.

Операторы сдвига всегда возвращают тип int, даже если аргумент типа, например, byte.

**Примеры применения битовых операций:**

+ Ускорение операций умножения и деления чисел на два. Примеры можно увидеть в стандартной библиотеке jdk. Важно понимать, что сдвиги намного хуже читаются в коде, нежели обычные арифметические операции, поэтому применять их нужно согласованно на уровне команды/проекта, иначе другие программисты могут внезапно столкнуться со сложностями чтения такого кода.
+ Битовые поля(флаги). Пример: пусть есть права на доступ - чтение, запись, выполнение. Их удобнее хранить не в трёх разных переменных, а в одной, устанавливая соответствующие биты.
+ Алгоритмы шифрования и сжатия (например, Шифр Вернама построен на XOR).
+ Работа с графикой.
+ Работа с сетью.

[к оглавлению](#Collections-Pro)

##  24. Как хранится знак числа в Java? Как хранятся отрицательные числа?

**Знак числа в Java**

Все примитивные (целочисленные) типы данных в Java (кроме char) представлены со знаком, то есть число может быть 
положительным или отрицательным. Знак числа определяет старший двоичный разряд (самый левый). 0 - знак плюс. 1 - 
знак минус. Старший двоичный разряд называется дополнительным кодом (или вторым дополнением (two's complement)), так 
как хранит только знак числа. Например, в типе int старший двоичный разряд уходит под хранение знака, а под само 
значение уходят остальные 31 бит.

**Представление отрицательных чисел в Java**

Чтобы преобразовать положительное число в отрицательное, нужно инвертировать все его биты и к получившемуся числу 
добавить 1.

[к оглавлению](#Collections-Pro)

## 25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?

В целом, Maven и Gradle имеют свои сильные и слабые стороны:

+ **Индивидуальные сборки.** С помощью Maven вы можете легко определить метаданные и зависимости вашего проекта, но создание 
  очень индивидуальной сборки может стать кошмаром для пользователей Maven. Файл POM может легко раздуться по мере роста 
  проекта и впоследствии превратиться в нечитаемый XML-файл.
+ **Управление зависимостями и структура каталогов.** Тем не менее, Maven обеспечивает простое, но эффективное управление 
  зависимостями, а поскольку он имеет структуру каталогов для ваших проектов, у вас есть своего рода стандартная схема 
  для всех ваших проектов. Он использует декларативный XML-файл для своего POM-файла и имеет множество плагинов, которые 
  вы можете использовать. Gradle использует структуру каталогов, которую вы видите в Maven, но она может быть настроена. 
  Он также использует тот же формат GAV, который Maven использует для идентификации артефактов.
+ **Плагины и интеграции.** Maven также поддерживает широкий спектр этапов жизненного цикла сборки и легко интегрируется со 
  сторонними инструментами, такими как CI-серверы, плагины покрытия кода, системы репозиториев артефактов и др. Что 
  касается плагинов, то в настоящее время количество доступных плагинов растет, и есть крупные поставщики, у которых 
  есть плагины, совместимые с Gradle. Тем не менее, количество доступных плагинов для Maven все еще больше, чем для Gradle.
+ **Гибкость.** Gradle, с другой стороны, очень гибкий и основан на скрипте. Пользовательские сборки было бы легко делать на 
  Gradle. Однако, поскольку Gradle практически недавно появился, количество разработчиков, знающих Gradle изнутри, может 
  быть ограничено.

В конечном счете, выбор будет зависеть в первую очередь от того, что вам нужно. Gradle более мощный.  Однако бывает так, 
что вам не нужно большинство возможностей и функций, которые он предлагает. Maven может подойти для небольших проектов, 
а Gradle — для более крупных. Если вы работали с Maven и обнаружили, что ваш проект перерос его, можно перейти с Maven 
на Gradle.

---

|Ant|Maven| 
|---|---|
|Поскольку в Ant отсутствуют формальные соглашения, мы должны включить информацию о структуре проекта в файл build.xml.|В Maven существует соглашение о хранении исходного кода, скомпилированного кода и т. д. В результате нам не нужно предоставлять информацию о структуре проекта в файле pom.xml.| 
|Ant является процедурным, поэтому вам нужно будет написать код, чтобы сообщить ему, что и когда делать. Вы должны поддерживать порядок.|В Maven существует соглашение о хранении исходного кода, скомпилированного кода и т. д. В результате нам не нужно предоставлять информацию о структуре проекта в файле pom.xml.| 
|У Ant нет жизненного цикла.|У Maven есть жизненный цикл.| 
|Ant — это ящик для инструментов.|Maven — это фреймворк.|
|Ant — это прежде всего инструмент сборки.|Maven — это прежде всего инструмент управления проектами.|
|Сценарии ant нельзя использовать повторно.|Плагины maven можно использовать повторно.|

[к оглавлению](#Collections-Pro)

## 26. Как создать maven - проект?

Архетип в мавене — это шаблон нового проекта, со структурой и заготовками исходных и конфигурационных файлов.

Типичный метод создания проекта:

```
	mvn archetype:create                                    \
	  -DarchetypeGroupId=<archetype-groupId>                \
	  -DarchetypeArtifactId=<archetype-artifactId>          \
	  -DarchetypeVersion=<archetype-version>                \
	  -DgroupId=<my-groupid>                                \
	  -DartifactId=<my-artifactId>
```

Если мы например, захотим создать простоe приложение, то мы используем архетип под названием maven-archetype-quickstart, 
например вот так:

```
	mvn archetype:create                                    \
	  -DarchetypeGroupId=org.apache.maven.archetypes        \
	  -DarchetypeArtifactId=maven-archetype-quickstart      \
	  -DarchetypeVersion=1.0                                \
	  -DgroupId=org.example                                 \
	  -DartifactId=simpleapp
```

+ groupId=org.example указывает на разработчика ПО, там вы можете указать доменное имя своей компании.
+ artifactId=simpleapp — название проекта. Maven оперирует так называемыми артефактами. Это приложения, плагины, архетипы и
  другие проекты. И ваша разработка также будет считаться артефактом.
+ archetypeArtifactId=maven-archetype-quickstart указывает, какой архетип использовать в качестве шаблона для создания 
  приложения. Как видите, это тоже артефакт. Указанный архетип создаст простой проект, сгенерирует структуру каталогов и даже заботливо положит в папку исходников программу «Hello, world!», чтобы вам не пришлось самому писать её в двухсотый раз.
+ archetypeVersion=1.0 указывает на версию артефакта «архетип».

Есть более удобный способ создания проекта, с помощью цели archetype:generate. При вызове, в интерактивном режиме будет 
предложено ввести параметры нового проекта.

`mvn archetype:generate`

+ interactiveMode=false отключает создание проекта в интерактивном режиме. Вы можете запустить цель archetype:generate
  без параметров, и Maven предложит установить параметры в процессе генерации. В данном случае нам это не нужно. Кстати,
  отключить интерактивный режим можно параметром -B. Полный список параметров для mvn можно получить по команде mvn -h.

[к оглавлению](#Collections-Pro)

## 27. Какова структура maven-проекта?

Выполнив команду, Maven сгенерирует следующую структуру проекта:

```
my-app

|-- pom.xml

`-- src

    |-- main

    |     `-- java

    |         `-- com

    |             `-- mycompany

    |                 `-- app

    |                     `-- App.java

    `-- test

        `-- java

            `-- com

                `-- mycompany

                    `-- app

                        `-- AppTest.java
```

Исходники нашего проекта будут лежать в папке src/main/java (и сейчас там уже есть автоматически сгенерированный файл), 
но нам сейчас интереснее файл pom.xml в корневом каталоге. Это и есть тот самый файл описания проекта, на основе 
которого осуществляются все операции Maven. Он написан на языке POM, входящим в семейство XML.

[к оглавлению](#Collections-Pro)

## 28. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?

Пример файла pom.xml:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <groupId>com.examclouds</groupId>
    <artifactId>courses</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.39</version>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>1.4.196</version>
        </dependency>
    </dependencies>

    <build>
        <sourceDirectory>src</sourceDirectory>
        <resources>
            <resource>
                <directory>resources</directory>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.0.2</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>2.17</version>
                <configuration>
                    <suppressionsLocation>suppressions.xml</suppressionsLocation>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <reporting>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.0.2</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>2.17</version>
                <configuration>
                    <suppressionsLocation>suppressions.xml</suppressionsLocation>
                </configuration>
                <reportSets>
                    <reportSet>
                        <reports>
                            <report>checkstyle</report>
                        </reports>
                    </reportSet>
                </reportSets>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-pmd-plugin</artifactId>
                <version>3.8</version>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>findbugs-maven-plugin</artifactId>
                <version>3.0.4</version>
                <configuration>
                    <xmlOutput>true</xmlOutput>
                </configuration>
            </plugin>
        </plugins>
    </reporting>
</project>
```

1. Корневой элемент

Корневой элемент _<project>_, в котором прописана схема облегчающая редактирование и проверку, и версия POM.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    ...
</project>
```

2. Заголовок

Внутри тега _project_ содержится основная и обязательная информация о проекте

```xml
<groupId>com.examclouds</groupId>
<artifactId>courses</artifactId>
<version>1.0-SNAPSHOT</version>
```

В Maven каждый проект идентифицируется парой _groupId_, _artifactId_.

Во избежание конфликта имён, _groupId_ - наименование организации или подразделения и обычно действуют такие же правила, 
как и при именовании пакетов в Java - записывают доменное имя организации или сайта проекта.

_artifactId_ - название проекта.

Внутри тега _version_ хранится версия проекта.

Тройкой _groupId_, _artifactId_, _version_ (далее - GAV) можно однозначно идентифицировать _jar_ файл приложения или библиотеки. 
Если состояние кода для проекта не зафиксировано, то в конце к имени версии добавляется _"-SNAPSHOT"_ что обозначает, что
версия в разработке и результирующий jar файл может меняться.

3. Тег _packaging_

Тег _<packaging>_ определяет какого типа файл будет создаваться как результат сборки. Возможные варианты _pom, jar, war, 
ear_.

Тег является необязательным. Если его нет, используется значение по умолчанию - _jar_.

4. Описание проекта

Также добавляется информация, которая не используется самим Maven, но нужна для программиста, чтобы понять, о чём этот 
проект:

```xml
<name>powermock-core</name> название проекта для человека
<description>PowerMock core functionality.</description> Описание проекта
<url>http://www.powermock.org</url> сайт проекта
```

5. Зависимости

Зависимости - следующая очень важная часть _pom.xml_ - тут хранится список всех библиотек (зависимостей) которые 
используются в проекте. Каждая библиотека идентифицируется так же как и сам проект - тройкой _groupId, artifactId, 
version_ (GAV). Объявление зависимостей заключено в теге _<dependencies>...</dependencies>_.

Кроме GAV при описании зависимости может присутствовать тег _<scope>_. Он задаёт, для чего библиотека используется. В 
данном примере говорится, что библиотека с GAV _junit:junit:4.4_ нужна только для выполнения тестов.

```xml
<dependencies>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.39</version>
    </dependency>

    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <version>1.4.196</version>
    </dependency>
</dependencies>
```

6. Тег <build>

Тег _<build>_  не обязательный, так как существуют значения по умолчанию. Этот раздел содержит информацию по самой сборке:

+ где находятся исходные файлы,
+ где ресурсы,
+ какие плагины используются.

```xml
<build>
    <sourceDirectory>src</sourceDirectory>
    <resources>
        <resource>
            <directory>resources</directory>
        </resource>
    </resources>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>2.0.2</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-checkstyle-plugin</artifactId>
            <version>2.17</version>
            <configuration>
                <suppressionsLocation>suppressions.xml</suppressionsLocation>
            </configuration>
        </plugin>
    </plugins>
</build>
```

_<sourceDirectory>_ - определяет, откуда _Maven_ будет брать файлы исходного кода. По умолчанию это _src/main/java_, но 
вы можете определить, где это вам удобно. Директория может быть только одна (без использования специальных плагинов).

_<recources>_ и вложенные в неё теги _<recource>_ определяют, одну или несколько директорий, где хранятся файлы ресурсов. 
Ресурсы в отличие от файлов исходного кода при сборке просто копируются. Директория по умолчанию _src/main/resources_.

_<outputDirectory>_ - определяет, в какую директорию компилятор будет сохранять результаты компиляции - _*.class_ файлы. 
Значение по умолчанию - _target/classes._

_<finalName>_ - имя результирующего _jar (war, ear ...)_ файла с соответствующим типу расширением, который создаётся на фазе 
_package_. Значение по умолчанию — _artifactId-version_.

_Maven_ плагины позволяют задать дополнительные действия, которые будут выполняться при сборке. Например, в приведённом 
примере добавлен плагин, который автоматически делает проверку кода на наличие "плохого" кода и потенциальных ошибок.

[к оглавлению](#Collections-Pro)

## 29. Что такое координаты зависимости?

Maven определяет набор правил для определения уникальности компонентов. Эти элементы включают: GAV (groupId, artifactId, 
version) и, в отдельных случаях, «необязательный» классификатор classifier. Области действия зависимостей scope (compile, 
provided, runtime, test, system, import). Месторасположение зависимости (для области действия зависимости system). Через
эти элементы мы можем найти соответствующие компоненты.

```xml
<dependencies>
  <dependency>
    <groupId>net.sf.json-lib</groupId>
    <artifactId>json-lib</artifactId>
    <version>2.4</version>
    <classifier>jdk15</classifier>
  </dependency>
<dependencies>
```

**Параметры GAV**
+ **groupId** - идентификатор производителя объекта. Часто используется схема принятая в обозначении пакетов Java. Например, 
  если производитель имеет домен domain.com, то в качестве значения groupId удобно использовать значение com.domain. То есть, groupId это по сути имя пакета.
+ **artifactId** - идентификатор объекта. Обычно это имя создаваемого модуля или приложения.
+ **version** - версия описываемого объекта. Для незавершенных проектов принято добавлять суффикс SNAPSHOT. Например 
  1.0.0-SNAPSHOT.
+ Классификатор **classifier** используется в тех случаях, когда деление артефакта по версиям является недостаточным. К 
  примеру, определенная библиотека (артефакт) может быть использована только с определенной JDK (VM), либо разработана 
  под windows или linux. Определять этим библиотекам различные версии – идеологически не верно. Но вот использованием 
  разных классификаторов можно решить данную проблему.

[к оглавлению](#Collections-Pro)

## 30. Что такое транзитивные зависимости?

Начиная со второй версии фреймворка maven были введены транзитивные зависимости, которые позволяет избегать необходимости 
изучения и определения библиотек, которые требуются для самой зависимости. Maven включает их автоматически. В общем случае, 
все зависимости, используемые в проекте, наследуются от родителей. Ограничений по уровню наследований не существует, что, 
в свою очередь, может вызвать их сильный рост. В качестве примера можно рассмотреть создание проекта «A», который зависит 
от проекта «B». Но проект «B», в свою очередь, зависит от проекта «C». Подобная цепочка зависимостей может быть сколь 
угодно длинной. Как в этом случае поступает maven и как связан проект «A» и c проектом «C».

В следующей табличке, позаимствованной с сайта maven, представлен набор правил переноса области scope. К примеру, если
scope артефакта «B» compile, а он, в свою очередь, подключает библиотеку «C» как provided, то наш проект «A» будет 
зависеть от «C» так как указано в ячейке находящейся на пересечении строки «compile» и столбца «provided».

-|Compile|Provided|Runtime|Test
---|---|---|---|---
Compile|Compile|-|Runtime|-
Provided|Provided|Provided|Provided|-
Runtime|Runtime|-|Runtime|-
Test|Test|Test|Test|-

[к оглавлению](#Collections-Pro)

## 31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?

Область действия scope определяет этап жизненного цикла проекта, в котором эта зависимость будет использоваться.

**test**

Если зависимость junit имеет область действия test, то эта зависимость будет использована maven'ом при выполнении 
компиляции той части проекта, которая содержит тесты, а также при запуске тестов на выполнение и построении отчета с 
результатами тестирования кода. Попытка сослаться на какой-либо класс или функцию библиотеки junit в основной части 
приложения (каталог src/main) вызовет ошибку.

**compile**

К наиболее часто используемой зависимости относится compile (используется по умолчанию). Т.е. dependency, помеченная как 
compile, или для которой не указано scope, будет доступна как для компиляции основного приложения и его тестов, так и на
стадиях запуска основного приложения или тестов. Чтобы инициировать запуск тестов из управляемого maven-проекта можно 
выполнив команду "mvn test", а для запуска приложения используется плагин exec.

**provided**

Область действия зависимости provided аналогична compile, за исключением того, что артефакт используется на этапе 
компиляции и тестирования, а в сборку не включается. Предполагается, что среда исполнения (JDK или WEB-контейнер) 
предоставят данный артефакт во время выполнения программы. Наглядным примером подобных артефактов являются такие 
библиотеки, как hibernate или jsf, которые необходимы на этапе разработки приложения.

**runtime**

Область действия зависимости runtime не нужна для компиляции проекта и используется только на стадии выполнения 
приложения.

**system**

Область действия зависимости system аналогична provided за исключением того, что содержащий зависимость артефакт 
указывается явно в виде абсолютного пути к файлу, определенному в теге systemPath. Обычно к таким артефактам относятся 
собственные наработки, и искать их в центральном репозитории, куда Вы его не размещали, не имеет смысла

[к оглавлению](#Collections-Pro)

## 32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?

Основные фазы сборки:

1. **compile** - компилирование проекта;
2. **test** - тестирование с помощью JUnit тестов;
3. **package** - создание jar файла или war, ear в зависимости от типа проекта;
4. **integration-test** - запуск интеграционных тестов;
5. **install** - копирование jar (war, ear) в локальный репозиторий;
6. **deploy** - публикация файла в удалённый репозиторий.

Особняком стоят фазы **clean** и **site**. Они не выполняются, если специально не указаны в строке запуска.

**clean** - удаление всех созданных в процессе сборки артефактов: .class, .jar и др. файлов. В простейшем случае 
результат — просто удаление каталога target.

**site** - предназначена для создания документации.

[к оглавлению](#Collections-Pro)