## Collections Pro

[1. Что такое generic?](#1-Что-такое-generic)

[2. Что такое wild cards?](#2-Что-такое-wild-cards)

[3. Что такое bound wild cards?](#3-Что-такое-bound-wild-cards)

[4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)

[5. Где хранится информация про Generics?](#5-Где-хранится-информация-про-generics)

[6. Как можно получить тип Generics?](#6-Как-можно-получить-тип-generics)

[7. Что такое итератор?](#7-Что-такое-итератор)

[8. Что такое коллекции?](#8-Что-такое-коллекции)

[9. Назовите базовые интерфейсы коллекций?](#9-Назоваите-базовые-интерфейсы-коллекций)

[10. Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-list)

[11. Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-set)

[12. Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-map)

[13. Отличие ArrayList от LinkedList?](#13-Отличие-arraylist--linkedlist)

[14. Отличие Set от List?](#14-Отличие-set-от-list)

[15. Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-object-hashcode-и-equals)

[16. Расскажите про реализации Map?](#16-Расскажите-про-реализации-map)

[17. Расскажите, что такое коллизии в Map? Как с ними бороться?](#17-Расскажите-что-такое-коллизии-в-map-как-с-ними-бороться)

[18. Расскажите, что такое анализ алгоритма?](#18-Расскажите-что-такое-анализ-алгоритма)

[19. Какая временная сложность алгоритмов(O нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#19-Какая-временная-сложность-o-нотация-добавления-замены-и-удаления-в-каждой-из-коллекций-с-чем-связаны-отличия)

[20. Расскажите реализации данных очередей и стеков](#20-Расскажите-реализации-данных-очередей-и-стеков)

[21. Расскажите про реализации деревьев](#21-Расскажите-про-реализации-деревьев)

[22. Что такое loadFactor?](#22-Что-такое-loadfactor)

## 1. Что такое generic?

**Дженерики** (обобщения) - это особые средства языка Java для реализации обобщенного программирования: особого подхода 
к описанию данных и алгоритмов, позволяющего работать с различными типами данных без изменения их описания. Это 
параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.

Начиная с JDK 1.5, в Java появляются новые возможности для программирования. Одним из таких нововведений являются 
Generics. Generics позволяют абстрагировать множество типов. Наиболее распространенными примерами являются Коллекции.
Обычно Generics используют в тех случаях, когда с помощью класса реализуется некоторая "структура" или
"конструкция", которая имеет универсальные характеристики и слабо зависит от конкретного типа данных, с которыми
приходится оперировать. 

В Java дженерики добавили для реализации обобщенных коллекций, безопасных с точки зрения типов. 
Ошибка компиляции - это лучше, чем исключение `ClassCastException` в связи с неправильным приведением типаов во время 
выполнения.

Эффект от Generics особенно проявляется в крупных проектах: он улучшает читаемость и надежность кода в целом.

Свойства дженериков: строгая типизация, единая реализация, отсутствие информации о типе.

[к оглавлению](#Collections-Pro)

## 2. Что такое wild cards?

**Wildcards** - это специальные вопросительные знаки, отмечающие место, где должно оказаться название параметра типа. 
Они являются средством выражения ограничений в условиях неизвестности какого-нибудь типа. Wildcards играют важную роль в 
системе типов. Они позволяют задать границы для семейства типов, определенных каким-нибудь generic-классом. Они 
используются в сочетании с ключевыми словами `extends` и `super`.

Для выбора типа используют принцип PECS (`Producer Extends` `Consumer Super`)
+ `extends` - когда надо только получать данные из объекта. Метод передает данные в аргумент.
+ `super` - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента.
+ не использовать `wildcard`, когда требуется и получать и вставлять данные в структуру.

[к оглавлению](#Collections-Pro)

## 3. Что такое bound wild cards?

**Bound wild cards** - это ограничение сверху или снизу, для `upper bounded wildcard` имеет вид <? extends P> и для 
`lower bounded wildcard` <? super P>. Где `P` представляет собой границу.

`List<? extends Number>` может содержать объекты, класс которых является Number или наследуется от Number. 

`List<? super Number>` может содержать объекты, класс которых Number или у которых Number является наследником.

[к оглавлению](#Collections-Pro)

## 4. Что такое unbounded wild cards?

**Unbounded wild cards** - это дженерики вида <?>, что означает, что тип может быть чем угодно, т.е. он имеет 
соответствие с любым типом. По сути это wildcard с неограниченным символом подстановки.

На самом деле такой "неограниченный" wildcard всё-таки ограничен, сверху. Запись вида Collection<?> равносильна 
Collection<? extends Object>, а значит - коллекция может содержать объекты любого класса, так как все классы в Java 
наследуются от Object - поэтому подстановка называется неограниченной.

[к оглавлению](#Collections-Pro)

## 5. Где хранится информация про Generics?

Только в исходном коде до момента компиляции

[к оглавлению](#Collections-Pro)

## 6. Как можно получить тип Generics?

По сути это невозможно, если речь о runtime'e, т.к. все стирается до Object'a, если речь не идет о классах, которые 
наследовались от дженерик-класса с конкретными типами, то можно через отражение (reflection) получить эту информацию.

```java
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;

public class FloatList extends ArrayList<Float> {
    public static void main(String[] args) {
        ArrayList<Float> list = new FloatList();
        Class actual = list.getClass();
        ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
        System.out.println(type);
        Class parameter = (Class) type.getActualTypeArguments()[0];
        System.out.println(parameter);
    }
}
```

[к оглавлению](#Collections-Pro)

## 7. Что такое итератор?

Шаблон "итератор" позволяет последовательно получить элементы набора данных. Шаблон итератор описывается интерфейсом - 
java.util.Iterator. Шаблон итератор используется в коллекциях, базах данных, чтении файлов.

Основные методы:
`hasNext()` - проверяет, есть ли следующий элемент.
`next()` - возвращает первый элемент ячейки. Второй вызов метода вернет второй элемент и т.д. Сдвигает указатель 
итератора. Указатель - это ссылка на элемент, котрый нужно вернуть.

В стандартной бибилиотеке Java существует 2 интерфейса это `Iterable` и `Iterator`:
+ `Iterable` - вынуждает реализовать метод возвращающий итератор.
+ `Iterator` - вернуть объект итератора.

[к оглавлению](#Collections-Pro)

## 8. Что такое коллекции?

**Коллекции** - это хранилища, поддерживающие различные способы накопения и упорядочивания объектов с целью обеспечения
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#Collections-Pro)

## 9. Назовите базовые интерфейсы коллекций?

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы 
разделяют все коллекции, входящие во фреймфорк на две части по типу хранения данных: простые последовательные наборы
элементов и наборы пар "ключ - значение" соответственно.

Интерфейс `Collection` расширяют интерфейсы:

+ `List` (список) представляет собой коллекцию, в которой допустимы дублирующие значения.
+ `Set` (множество) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов.
+ `Queue` (очередь) предназначена для хранения элементов с предопределенным способом вставки и извлечения FIFO 
  (first-in-first-out).

[к оглавлению](#Collections-Pro)

## 10. Расскажите реализации интерфейса List?

**`ArrayList`** - В основе реализации этого списка лежит массив. Но при этом ArrayList позволяет справиться с самой 
важной проблемой массивов - неизменяемость размера массива. Это значит, что ArrayList может менять свой размер во 
время исполнения программы и при этом нет строгого требования указывать размерность при создании объекта ArrayList.

**`LinkedList`** - класс, который реализует два интерфейса List и Deque. Этим обеспечивает возможность создавать 
двунаправленные(те, которые можно обходить в обоих направлениях) очереди из любых(в том числе и null) элементов. Каждый 
объект помещенный в связанный список, является узлом (для этого используются объекты вложенного класса Node). Каждый 
узел содержит в себе элемент который мы добавили, а также ссылку на предыдущий и следующий узел.

**`Vector`** - реализует динамический массив. Он похож на ArrayList, но с двумя отличиями:

+ Vector синхронизирован.
+ Vector содержит много устаревших методов, который не являются частью структуры коллекций.

**`Stack`** - является подклассом Vector, реализация стека LIFO (last-in-first-out).

[к оглавлению](#Collections-Pro)

## 11. Расскажите реализации интерфейса Set?

**`HashSet`** - HashSet инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом 
ключами в таблице будут значения, которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - будут 
значения null. Для того, чтобы использовать HashSet для хранения объектов, в классах этих объектов необходимо 
переопределять методы hashCode() и equals(). Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс 
хэширования не позволяет сделать в итоге отсортированный набор данных.

**`LinkedHashSet`** - расширяет класс HashSet, гарантирует, что порядок элементов при обходе коллекции будет идентичен 
порядку добавления элементов.

**`TreeSet`** - представляет собой структуру данных в виде дерева, в котором все объекты хранятся в отсортированном по 
возрастанию порядке. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное 
красно-черное дерево для хранения элементов.

[к оглавлению](#Collections-Pro)

## 12. Расскажите реализации интерфейса Map?

**`HashMap`** - реализация карты на основе хеш-таблицы. Поиск и вставка пар занимает небольшое постоянное время. 
Производительность можно настроить, указав в конструкторах особые значения для *емкости* и *коэффициента загрузки*.

**`LinkedHashMap`** - Похожа на HashMap, однако при переборе выдает пары в порядке их добавления, или согласно принципу
LRU("наименее используемые идут первыми", least-recently-used). Лишь немногим медленнее HashMap, за исключением процесса
перечисления элементов, где она быстрее за счет внутреннего связанного списка, отвечающего за хранение порядка 
добавления элементов.

**`TreeMap`** - Реализация карты на базе красно-черного дерева. При просмотре ключей или пар видно, что они соблюдают
определенный порядок (который определяется интерфейсами Comparable или Comparator). Область применения карты TreeMap - 
выдача результатов в отсортированном виде. Карта TreeMap - единственная карта с методом subMap(), который позволяет
выделять из карты некоторую её часть.

**`WeakHashMap`** - Карта, состоящая из "слабых" ключей, которые не препятствуют освобождению объектов, на которые 
ссылается карта. Разработана для решения определенного класса задач. Если за пределами карты ссылок на ключ нет, он 
может быть удален уборщиком мусора.

**`ConcurrentHashMap`** - Потоково-безопасная версия Map, не использующая синхронизационную блокировку.

**`IdentityHashMap`** - Хеш-таблица, использующая для сравнения ключей оператор == вместо метода equals(). Применяется
в особых случаях, не для рядовых целей.

[к оглавлению](#Collections-Pro)

## 13. Отличие ArrayList от LinkedList?

`ArrayList` это список, реализованный на основе массива, а `LinkedList` — это классический двусвязный список, основанный
на объектах с ссылками между ними.

`ArrayList`:
+ доступ к произвольному элементу по индексу за константное время O(1);
+ доступ к элементам по значению за линейное время O(N);
+ вставка в конец в среднем производится за константное время O(1);
+ удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее»
  смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
+ вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся 
  «правее» смещаются на одну ячейку вправо;
+ минимум накладных расходов при хранении.

`LinkedList`:
+ на получение элемента по индексу или значению потребуется линейное время O(N);
+ на добавление и удаление в начало или конец списка потребуется константное O(1);
+ вставка или удаление в/из произвольного место константное O(1);
+ требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще 
  указатели на следующий и предыдущий элементы списка.

В целом, `LinkedList` в абсолютных величинах проигрывает `ArrayList` и по потребляемой памяти, и по скорости выполнения 
операций. `LinkedList` предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда 
необходимо гарантированное время добавления элемента в список.

[к оглавлению](#Collections-Pro)

## 14. Отличие Set от List?

**`List<E>`** - упорядоченная коллекция (также известная как список). Пользователь этого интерфейса имеет полный 
контроль над тем, где в списке каждый элемент вставлен. Пользователь может получить доступ к элементам по их 
целочисленному индексу (позиция в списке) и искать элементы.

**`Set<E>`** - это множество. Коллекция, которая не содержит повторяющихся элементов. 

[к оглавлению](#Collections-Pro)

## 15. Расскажите про методы Object hashCode и equals?

`Equals` и `hashCode` являются фундаментальными методами объявленные в классе `Object` и содержатся в стандартных
библиотеках Java.

Метод `equals()` используется для сравнения объектов, а `hashCode()` - для генерации целочисленного кода объекта.
Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в `HashMap`. Метод
`equals` также используется для обеспечения хранения только уникальных объектов в `HashSet` и других `Set` реализациях,
а также в любых других случаях, когда нужно сравнивать объекты.

Реализация по умолчанию метода `equals()` в классе `java.lang.Object` сравнивает ссылки на адреса в памяти, которые
хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные ссылаются
на один и тот же объект.

Java рекомендует переопределять методы `equals()` и `hashCode()`, если предполагается, что сравнение должно
осуществляться в соответствии с бизнес-логикой.

Так как `HashMap` в Java полагается на методы equals() и hashCode() для сравнения своих `key` и `values`, то Java
предлагает следующие правила для переопределения этих методов:

1. Рефлексивность: Объект должен равняться себе самому.

2. Симметричность: если `a.equals(b)` возвращает `true`, то `b.equals(a)` должен тоже вернуть `true`.

3. Транзитивность: если `a.equals(b)` возвращает `true` и `b.equals(с)` тоже возвращает `true`, то `c.equals(a)` тоже
   должен возвращать `true`.

4. Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение до тех пор, пока какое-либо
   значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их
   свойства остаются неизменными.

5. Сравнение `null`: объект должен быть проверен на `null`. Если объект равен `null`, то метод должен вернуть `false`,
   а не `NullPointerException`. Например `a.equals(null)` должен вернуть `false`.

Соглашение между `equals` и `hashCode` в Java:

1. Если объекты равны по результатам выполнения метода `equals`, тогда их `hashCode` должны быть одинаковыми.

2. Если объекта не равны по результатам выполнения метода `equals`, тогда их `hashCode` могут быть как одинаковыми, так
   и разными. Однако для повышенной производительности, лучше, чтобы разные объекты возвращали разные коды.
   
**Метод `equals()` переопределяется так:**
1. Не равны ли ссылки.
2. Не равен `null`.
3. Проверяем что объекты от одного класса.
4. Не равны ли `hashCode`.
5. Не равны состояния полей.

**Метод `hashCode()` переопределяется так:**
1. Сохраните некоторое ненулевое значение (скажем 17) в целочисленной (int) переменной с названием result.
2. Для каждого значимого поля f в вашем классе (значимое поле - это то, которое учитывает метод equals()) вычислите целое (int) значение хеш-кода c. 

Тип данных | Вычисления
--- | --- 
Boolean | c = (f ? 0 : 1)
byte, char, short или int | c = (int) f
long | c = (int) (f ^ (f >>> 32))
float | c = Float.floatToIntBits(f)
double | long l = Double.doubleToLongBits(f);c = (int) (l ^ (l >>> 32));
Object, где метод equals() вызывает equals() для каждого поля | c = f.hashCode()
Массив | К каждому элементу применяются описанные выше правила

3. Скомбинируйте хеш-коды, полученные по указанным формулам: result 37 * result + c;
4. Возвратите result;

[к оглавлению](#Collections-Pro)

## 16. Расскажите про реализации Map?

[Ответ на данный вопрос раскрывается в ответе на вопрос под №12](#12-Расскажите-реализации-интерфейса-map)

[к оглавлению](#Collections-Pro)

## 17. Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизия - это ситуация, когда не эквивалентные элементы имеют одинаковые хеш-коды. Возникает оттого, что количество
значений хеш-функций меньше (ограничены диапазоном значений типа `int 2^32`), чем вариантов исходных данных.
Вероятность возникновения коллизий оценивает качество хеш-функций.

По простому:

**Коллизия** - это когда для двух объектов вычисляется одинаковый индекс при вычислении хеш-кода и хеша.

Решение: проверить методом `equals()`, что ссылки на объекты не равны.
Для хэш-таблицы в ту же ячейку добавляется еще один объект, за счет того что каждая ячейка - это связанный список.

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине
превышает определенное значение, данная корзина переходит от использования связного списка к использованию
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок.
Т.е. при использовании данных типа `int` или `double` имеет смысл переходить к дереву поиска, а при использовании
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс.
Такой подход позволяет улучшить производительность с `O(n)` до `O(log(n))`.

[к оглавлению](#Collections-Pro)

## 18. Расскажите, что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью.

Временная сложность алгоритма – это функция, позволяющая определить,
как быстро увеличивается время работы алгоритма с увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:
+ `O(1)` – константная сложность (т.е. константное время);
+ `О(n)` – линейная сложность;
+ `О(nа)` – полиномиальная сложность;
+ `О(log(n))` – логарифмическая сложность;
+ `O(n*log(n))` – квазилинейная сложность;
+ `O(2n)` – экспоненциальная сложность;
+ `O(n!)` – факториальная сложность.

[к оглавлению](#Collections-Pro)

## 19. Какая временная сложность алгоритмов(O нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.

+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.

+ **Деревья** для всех операций - `O(log(n))`.

+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.

[Справочник по Java Collections Framework](https://habr.com/ru/post/237043/)

[к оглавлению](#Collections-Pro)

## 20. Расскажите реализации данных очередей и стеков

**`ArrayDeque`** - создает двунаправленную очередь. Реализует интерфейс Deque.

**`LinkedList`** - это двусвязный список. Реализует сразу два интерфейса - List, Deque.

**`PriorityQueue`** - это класс очереди с приоритетом. По умолчанию очередь с приоритетами размещает элементы согласно 
естественному порядку сортировки используя Comparable. Элементу с наименьшим значением присваивается наибольший 
приоритет. Если несколько элементов имеют одинаковый наивысший элемент - связь определяется произвольно. Также можно 
указать специальный порядок размещения, используя Comparator.

**`Stack`** - является подклассом Vector и реализовывает структуру “крайний на вход – первый на выход”.

[к оглавлению](#Collections-Pro)

## 21. Расскажите про реализации деревьев

+ **`TreeMap`** - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в 
  конструкторе. Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты 
  дерева от числа узлов.

+ **`TreeSet`** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию 
  хеш-кодов. Можно управлять порядком при помощи компаратора.

[к оглавлению](#Collections-Pro)

## 22. Что такое loadFactor?

**loadFactor** - это коэффициент загрузки, равен соотношению `(размер коллекции / колличество элементов)`.
При достижении порогового значения размер коллекции увеличивается.

Например, в хеш-таблице поле, которое показывает насколько заполнен массив, на котором эта таблица основана.
Если на 3/4, то создается новый массив с большим размером и данные перераспределяются.

[к оглавлению](#Collections-Pro)