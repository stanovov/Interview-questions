## Garbage Collection

[1. Чем Java отличается от C++?](#1-Чем-java-отличается-от-c)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора.](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-Что-такое-ссылки)

[9. Какие типы ссылок Вы знаете?](#9-Какие-типы-ссылок-Вы-знаете)

[10. Чем эти ссылки отличаются?](#10-Чем-эти-ссылки-отличаются)

[11. Расскажите про String pool и Integer pool (Integer cache).](#11-Расскажите-про-string-pool-и-integer-pool-integer-cache)

[12. Расскажите о методе String.intern().](#12-Расскажите-о-методе-stringintern)

[13. Расскажите, что такое профайлер.](#13-Расскажите-что-такое-профайлер)

[14. Расскажите, как использовать VisualVM.](#14-Расскажите-как-использовать-visualvm)

[15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)](#15-Расскажите-чем-отличается-sampling-от-profiling-Это-типы-аудита-Режим-работы-в-профайлере)

[16. Расскажите о benchmark. Приведите примеры кода.](#16-Расскажите-о-benchmark-Приведите-примеры-кода)

[17. Расскажите о методе finalize().](#17-Расскажите-о-методе-finalize)

[18. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?](#18-Расскажите-о-методе-clone-Что-такое-deep-clone-and-shallow-clone)

[19. Расскажите о Stack, Heap и Metaspace.](#19-Расскажите-о-stack-heap-и-metaspace)

[20. Что такое ClassLoader? Перечислите основные реализации ClassLoader.](#20-Что-такое-classloader-Перечислите-основные-реализации-classloader)

[21. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?](#21-Расскажите-иерархию-штатных-загрузчиков-классов-в-java-Какой-загрузчик-находится-в-корне-иерархии)

[22. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?](#22-Какой-загрузчик-классов-нельзя-получить-методом-getclassloader-Почему)

[23. Расскажите алгоритм поиска и загрузки класса в JVM.](#23-Расскажите-алгоритм-поиска-и-загрузки-класса-в-jvm)

## 1. Чем Java отличается от C++?

В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов `new` и `delete`).

В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой
неиспользуемыми объектами)

Т.е. в отличие от C++ нет явной необходимости уничтожать объект.

[к оглавлению](#garbage-collection)

## 2. Что такое менеджер памяти?

**Менеджер памяти** - часть компьютерной программы (как прикладной, так и операционной), обрабатывающая запросы на 
выделение и освобождение оперативной памяти или (для некоторых архитектур ЭВМ) запросы на включение заданной области 
памяти в адресное пространство процессора.

Основное назначение менеджера памяти в первом смысле - реализация динамической памяти, т.е. выделение оперативной памяти
компьютера для объектов в программе осуществляется во время её выполнения.

Менеджеры памяти часто образуют иерархию, т.е. нижестоящие менеджеры задействуют какие-либо закономерности 
выделения-освобождения памяти и этим снижают нагрузку на вышестоящие. Например:

+ Системный - менеджер памяти, встроенный в ОС.
+ Принадлежащий процессу - менеджер памяти, встроенный в стандартную библиотеку языка программирования, берёт у ОС блоки
  памяти «оптом» и раздаёт их сообразно с нуждами программиста.
+ Специализированные - некоторые динамические структуры данных, например `vector`, также берёт память у стандартной 
  библиотеки с запасом (обычно, блоками экспоненциально увеличивающегося размера).
  
Подобная иерархия приводит к тому, что на каждом из уровней «залёживается» свободная память. Но это оправдано: снижается
фрагментация памяти и повышается скорость.

[к оглавлению](#garbage-collection)

## 3. Какой механизм используется в Java для управления памятью?

В Java используется автоматическое управление памятью, называемое "сборкой мусора".

Все создаваемые программой объекты находятся в области памяти под названием "куча" (heap). JVM использует больше памяти,
чем занимает куча. Для методов Java и стеков потоков выделяется память отдельно от кучи.

Когда объекты занимают в куче много места, происходит очистка её от уже не используемых, "мертвых" объектов - сборка 
мусора.

Сборщик мусора - это отдельный поток, который действует автоматически и в общем случае не требует внимания программиста,
позволяя тому сосредоточиться на бизнес-логике.

[к оглавлению](#garbage-collection)

## 4. Опишите процесс работы сборщика мусора.

Для обнаружения мусора существует два подхода:

+ **Reference counting (учет ссылок)** - у каждого объекта есть счетчик указывающих на него ссылок, при уничтожении 
  ссылки, счетчик уменьшается. Когда он равен нулю, объект считается мусором.
  
Главный недостаток - сложность обеспечения точности счетчика и «невозможность» выявлять циклические зависимости. 
Например, два объекта могут ссылаться друг на друга, но ни на один из них нет внешней ссылки. Это сопровождается 
утечками памяти.

+ **Tracing (трассировка)** - объект считается не мусором, если до него можно добраться с корневых точек (GC Root), а 
  всё, что доступно из «живого» объекта, также является «живым». Если представить все объекты и ссылки между ними как 
  дерево, то необходимо пройти от корневых узлов GC Roots по всем узлам. При этом узлы, до которых нельзя добраться, 
  являются мусором.
  
Трассировка используется в виртуальной машине HotSpot VM.

Типы корневых точек (GC Root):

+ Основной Java поток.
+ Локальные переменные в основном методе.
+ Статические переменные основного класса.

Таким образом, простое java-приложение будет иметь следующие корневые точки:

+ Параметры `main`-метода и локальные переменные внутри `main`-метода.
+ Поток, который выполняет `main`.
+ Статические переменные основного класса, внутри которого находится `main`-метод.

Имеется два подхода к очистке памяти, которые в совокупности определяют принцип функционирования Garbage Collection.

1. *Copying collectors* - в чистом виде в HotSpot VM не используется.

   Область памяти делится на две части: В одной части размещаются объекты, а вторая часть остается чистой. На время 
   очистки мусора приложение останавливает работу и запускается `GC`, который находит в первой области объекты со 
   ссылками и переносит их во вторую (чистую) область. После этого, первая область очищается от оставшихся там объектов
   без ссылок, и области меняются местами.

   Достоинство данного подхода - плотное заполнение памяти. Недостаток - необходимость остановки приложения и размеры 
   двух частей памяти должны быть одинаковыми на случай, когда все объекты остаются «живыми».


2. *Mark-and-sweep* - также в чистом виде в HotSpot VM не используется.

   Все объекты размещаются в одном сегменте памяти. Сборка мусора также приостанавливает приложение, и GC проходит по 
   дереву объектов, помечая занятые ими области памяти, как «живые». После этого, все не помеченные участки памяти 
   сохраняются в «free list», в которой будут, после завершения сборки мусора, размещаться новые объекты.
   
   Недостатки - необходимость приостановки приложения. Кроме этого, время сборки мусора, как и время приостановки 
   приложения, зависит от размера памяти. Кроме этого, время сборки мусора, как и время приостановки приложения, зависит
   от размера памяти. Память становится «решетчатой», и, если не применять «уплотнение», то память будет использоваться 
   неэффективно.

Различные сборщики мусора используют разные подходы к организации памяти и её очистке, но их объединяет общая черта -
все они опираются на слабую гипотезу о поколениях. В общем виде, гипотеза о поколениях гласит, что вероятность смерти
как функция от возраста снижается очень быстро. Подавляющее большинство объектов живут крайне недолго.

Тут и возникает идея разделения объектов на младшее поколение (young generation) и старшее поколение (old generation). 
В соответствии с этим разделением и процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только
младшее поколение, и полную сборку (full GC), которая может затрагивать оба поколения.

При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. 
Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение. В старшем поколении 
объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора.

Малые сборки выполняются, когда объем свободной памяти в области Eden Space становится критичным. В этом случае, Garbage
Collector просто переносит объекты, имеющие ссылки, из области Eden Space в область Survivor Space, а объекты без ссылок
удаляет. Малые сборки выполняются быстро, довольно часто, и удаляют основную часть мертвых объектов.

Полные сборки выполняются, когда памяти в области Survivor Space недостаточно. При этом долгоживущие объекты переносятся
в область Tenured Generation, где они могут храниться до конца работы приложения. Вся остальная куча очищается от 
мусора.

Следует отметить, что сборщик мусора периодически вызывается виртуальной машиной, а не только тогда, когда не хватает 
памяти.

При определении эффективности работы сборщика мусора учитываются следующие факторы:

+ **Максимальная задержка** — максимальное время, на которое сборщик приостанавливает выполнение программы для 
  выполнения одной сборки. Такие остановки называются stop-the-world (или STW).
+ **Пропускная способность** — отношение общего времени работы программы к общему времени простоя, вызванного сборкой 
  мусора, на длительном промежутке времени.
+ **Потребляемые ресурсы** — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

Добиться улучшения всех трёх параметров одновременно практически невозможно. Уменьшение максимального времени задержки
приводит к учащению сборки мусора, уменьшая пропускную способность. Либо приходится использовать более ухищренные 
алгоритмы для сохранения пропускной способности, что чаще всего увеличивает потребление ресурсов.

Поэтому при настройке сборщиков мусора разработчики обычно фокусируются на оптимизации одного или двух параметров, 
стараясь сильно не ухудшать остальные, но жертвуя ими в случае необходимости.

[к оглавлению](#garbage-collection)

## 5. Какие алгоритмы сборщика вы знаете?

Виды сборщиков:

+ **Serial GC**
+ **Parallel GC**
+ **Concurrent Mark Sweep (CMS)**
+ **Garbage-First (G1)**
+ **Z Garbage Collector (ZGC)**

**Serial**

Когда нет места в Eden, запускается GC, живые объекты копируются в S1. Вся область Eden очищается. S1 и S2 меняются 
местами. При последующих циклах в S1 будут записаны живые объекты как из Eden, так и из S2. После нескольких циклов 
обмена S1 и S2 или заполнения области S2, объекты, которые живут достаточно долго перемещаются в Old Generation.

Следует сказать, что не всегда объекты при создании аллоцируются в Eden. Если объект слишком велик, он сразу идёт в Old
Generation.

Когда после очередной сборки мусора места нехватает уже в New Generation, то запускается сбор мусора в Old Generation 
(наряду со сборкой в New Generation). В Old Generation Объекты уплотняются (алгоритм Mark-Sweep-Compact). 

Если после полной сборки мусора места нехватает, то вылетает `Java.lang.OutOfMemoryError`.

Но во время работы VM может запрашивать увеличение памяти и Heap может увеличиваться.

Как правило, Old Generation занимает 2/3 объема Heap.

Эффективность алгоритма сборки мусора считается по параметру STW (Stop-The-World) - время, когда все процессы кроме GC
останавливаются. Serial в этом смысле не слишком эффективен, т.к. делает свою работу не торопясь, в одном потоке.

**Parallel**

То же, что и Serial, но использует для работы несколько потоков. Таким образом STW чуть меньше.

**Concurrent Mark Sweep**

Принцип работы с New Generation такой же, как и в случае алгоритмов Serial и Parallel, отличия в том, что данный 
алгоритм разделяет младшую (New Generation) и старшую (Old Generation) сборку мусора во времени. Причем сборка мусора в 
Old Generation происходит в отдельном потоке, независимо от младшей сборки. При этом сначала приложение останавливается,
сборщик проверяет объекты доступные по ссылкам из этих самых помеченных, и также помечает их как живые. Эта особенность 
создает так называемые плавающие объекты, которые помечены как живые, но таковыми по факту не являющимися. Но они будут
удалены в следующих циклах. Т.е. пропускная способность растет, STW уменьшается, но требуется больше места для хранения
плавающих объектов.

В этом алгоритме уплотнения нет. Т.е. область Old Generation дефрагментированна.

**Garbage-First**

G1 сильно отличается от своих предшественников. Он делит область Heap не физически, а скорее логически на те же области:
Eden, Survivor, Old Generation. Причем дефрагментированно. Физически область Heap делится на регионы одинакового 
размера, каждый из которых может быть Eden, Survivor или Old Generation + область для больших объектов (громадный 
регион).

Над очисткой регионов Eden работает сразу несколько потоков, объекты переносятся в регионы Survivor или регионы старшего
поколения (Tenured). Это знакомый по предыдущим алгоритмам очистки подход. На время очистки работа приложения 
останавливается. Отличие в том, что очистка производится не по всем регионам Eden, а только по некоторым, которые более 
всего в ней нуждаются, таким образом регулируется время очистки. Отсюда название алгоритма - в первую очередь мусор.

А с полной сборкой (точнее, здесь она называется смешанной (mixed)) все немного хитроумнее, чем в рассмотренных ранее 
сборщиках. В G1 существует процесс, называемый циклом пометки (marking cycle), который работает параллельно с основным 
приложением и составляет список живых объектов. За исключением последнего пункта, этот процесс выглядит уже знакомо для 
нас:

+ `Initial mark`. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых 
  сборок.
+ `Concurrent marking`. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного 
  приложения.
+ `Remark`. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).
+ `Cleanup`. Очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно 
  использовать для размещения новых объектов. Первая часть этого шага выполняется при остановленном основном приложении.
  После окончания цикла пометки, G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к 
  набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения.
  Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика
  статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил
  достаточно памяти, он переключается обратно в режим малых сборок. 
  
Очередной цикл пометки и, как следствие, очередные смешанные сборки будут запущены тогда, когда заполненность кучи 
превысит определенный порог.

Опираясь на уже упомянутую статистику о предыдущих сборках, G1 может менять количество регионов, закрепленных за 
определенным поколением, для оптимизации будущих сборок.

Громадные регионы. С точки зрения JVM объекты которые превышают размер половины региона являются громадными. 
Особенности:

+ никогда не перемещается между регионами
+ может удаляться в рамках цикла пометки или полной сборки мусора
+ в регионе, занятом громадным объектом, может находиться только он сам.

Громадные объекты в силу небольшого размера региона могут порождать проблемы с точки зрения STW.

G1 выигрывает по времени STW, но расплатой является меньшая пропускная способность (около 90%, ср., например у Parallel 
ок. 99%) т.е. большие затраты ресурсов процессора.

**Z Garbage Collector (ZGC)**

ZGC - это масштабируемый сборщик мусора с малой задержкой, выполняет всю дорогостоящую работу одновременно, не 
останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу
(мульти-терабайты).

ZGC доступен в качестве экспериментальной функции, начиная с JDK 11.

[к оглавлению](#garbage-collection)

## 6. Чем отличаются сборщики мусора?

**Serial (последовательный)** - самый простой вариант для приложений, которым не требуется большой размер кучи для 
работы (Oracle указывает условную границу 100 МБ), которые не очень чувствительны к коротким остановкам и им для работы 
доступно только одно ядро процессора. Редко когда используются, но на слабых компьютерах может быть выбран виртуальной
машиной в качестве сборщика по умолчанию.

**+** Непритязательность по части ресурсов компьютера. Т.к. всю работу он выполняет последовательно в одном потоке, 
никаких заметных оверхедов и негативных побочных эффектов у него нет.

**-** Долгие паузы на сборку мусора при заметных объемах данных.

**-** Все настройки Serial GC крутятся вокруг размеров различных регионов кучи, т.е. для тонкой настройки требуется 
вручную что-то изучать, настраивать, эксперементировать и т.д.

**Parallel (параллельный)** - наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в
некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. В
целом, Parallel GC - это простой, понятный и эффективный сборщик, подходящий для большинства приложений. У него нет 
скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

**+** в сравнении с Serial GC есть возможность автоматической подстройки под требуемые параметры производительности и
меньшие паузы на время сборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех 
приложениях.

**-** Определенная фрагментация памяти, но вряд ли она будет существенной для большинства приложений, т.к. сборщиком 
используется относительно небольшое количество потоков.

**Concurrent Mark Sweep (CMS)** - нацелен на снижение максимальных задержек путем выполнения части работ по сборке 
мусора параллельно с основными потоками приложения. Более требователен к ресурсам процессора. Подходит для работы в 
приложениях с относительно большими объемами долгоживущих данных, для приложений, имеющих доступ к нескольким ядрам
процессора и чувствительных к паузам STW.

**+** по сравнению с рассмотренными ранее Serial/Parallel GC ориентирован на минимизацию времени простоя, что является
критическим фактором для многих приложений. Но для выполнения этой задачи приходится жертвовать ресурсами процессора и
зачастую общей пропускной способностью.

**-** не уплотняет объекты в старшем поколении, что приводит к фрагментации области Tenured. Этот факт в совокупности с
наличием плавающего мусора приводит к необходимости выделять приложению (конкретно - старшему поколению) больше памяти,
чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

**-** долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. Хотя они не 
частые, и при наличии достаточного объема памяти сборщику CMS удается их полностью избегать.

**Garbage-First (G1)** - создан для замены CMS, но не является явным продолжением линейки Serial/Parallel/CMS.
Используется в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных
(размер кучи от 4 ГБ и выше), для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет
уменьшения пропускной способности.

**+** G1 более точно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, чтобы не допустить
длительных остановок приложения, особенно при больших размерах кучи.

**+** В отличие от CMS, например, он не фрагментирует память.

**-** Тратит ресурсы процессора, которые использует для выполнения достаточно большой части своей работы параллельно с
основной программой. В результате страдает пропускная способность приложения. Целевым значением пропускной способности
по умолчанию для G1 равно 90%, для Parallel GC составляет 99%. Это не значит, что пропускная способность с G1 всегда 
будет почти на 10% меньше, но данную особенность следует учитывать.

**Z Garbage Collector (ZGC)** - это масштабируемый сборщик мусора с малой задержкой. ZGC выполняет всю дорогостоящую
работу одновременно, не останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу
(мульти-терабайты). Доступен, начиная с JDK 11.

[к оглавлению](#garbage-collection)

## 7. Расскажите про утилиты для анализа памяти?

встроенные в JDK утилиты: jps, jmap, jstat, jconsole, visualvm до java 9.

внешние: VisualVM с java 9 и утилита от NetBeans - YourKit Java Profiler.

jconsole, visualvm и yourkit profiler предоставляют удобный визуальный интерфейс.

**jps** - выводит pid-ы процессов, которые использует VM

Команда: `jps`

**jmap** - позволяет увидеть как объекты создаются, какие ожидают удаления, т.е. объекты имеющие непосредственное 
отношение к памяти. Также можно сделать дамп памяти.

Команда: `jmap -histo <pid>`

**jstat** - предоставляет свободную информацию о состоянии памяти программы. Она периодически получает данные о 
состоянии разных участков памяти и их обобщает.

Команда: `jstat -gc pid 1s 10`

**jconsole** - это наиболее удобная программа для профилирования, т.к. она обладает графическим интерфейсом.

Команда: `jconsole`

**VisualVM** - это инструмент, который предоставляет визуальный интерфейс для просмотра подробной информации о 
приложениях Java во время её работы.

**YourKit Profiler** - универсальный расширенный профилировщик, используется не только для анализа памяти,
но и, например, для поиска узких мест в коде (повторения и тп)

[к оглавлению](#garbage-collection)

## 8. Что такое ссылки?

Ссылки в Java - это указатели на объекты. Другими словами, ссылка - это переменная, содержащая адрес ячейки памяти, в 
которой хранится объект. Кроме того, ссылка может быть инициализирована как `null` - нулевая ссылка, не указывающая ни
на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом контексте
также может быть использована ссылка `this`, указывающая на текущий объект, и ссылка `super`, указывающая на текущий 
объект суперкласса.

Абстрактный класс `java.lang.ref.Reference` предоставляет базу для ссылочных классов. В нём определены следующие методы:

+ `get` - метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
+ `clear` - очищает ссылку.
+ `isEnueued` и `enqueue`, отвечающие за взаимодействие ссылки и объекта `ReferenceQueue`.

[к оглавлению](#garbage-collection)

## 9. Какие типы ссылок Вы знаете?

В Java существует четыре типа ссылок, различающихся по способу сбора мусора и предоставляющие пользователю возможность
более гибко работать с памятью:

+ **Сильные ссылки (Strong References)** - стандартные ссылки, создаются каждый раз, когда аллоцируем место в памяти 
  через оператор new. Если на объект есть хотя бы одна сильная ссылка, то данный объект не будет утилизирован при сборке
  мусора.
  
```java
StringBuilder builder = new StringBuilder();
```

+ **Слабые ссылки (WeakReferences)** - создаются с помощью вызова `new WeakReference<T>(T obj, ReferenceQueue<T> queue)`
  или `new WeakReference<T>(T obj)`. Если на объект есть только слабая ссылка, то будет выполнена попытка утилизации 
  данного объекта при сборке мусора.
  
```java
StringBuilder AAA = new StringBuilder();
WeakReference<StringBuilder> weakAAA = new WeakReference<StringBuilder>(AAA);
AAA = null;
```

+ **Мягкие ссылки (Soft References)** - создаются с помощью вызова `new SoftReference<T>(T obj, ReferenceQueue<T> queue)` 
  или `new SoftReference<T>(T obj)`. Если на объект есть только мягкая ссылка, то будет выполнена попытка утилизации 
  данного объекта при сборке мусора в случае, если приложению не хватает памяти.
  
```java
StringBuilder AAA = new StringBuilder();
SoftReference<StringBuilder> weakAAA = new SoftReference<StringBuilder>(AAA);
AAA = null;
```

+ **Фантомные ссылки (Phantom References)** - создаются с помощью вызова `new PhantomReference<T>(T obj, ReferenceQueue<T> queue)`. 
  Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора.
  Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная 
  фантомная ссылка не очищена с помощью вызова метода `clear()`. Так же стоит заметить, что метод `get()` фантомной 
  ссылки всегда возвращает `null`.
  
```java
StringBuilder AAA = new StringBuilder();
PhantomReference<StringBuilder> weakAAA = new PhantomReference<StringBuilder>(AAA);
AAA = null;
```

[к оглавлению](#garbage-collection)

## 10. Чем эти ссылки отличаются?

Сначала общее правило: политика зачистки для некоего объекта и очистки ссылок на него определяется самыми жёсткими из 
всех ссылок, что на него указывают.

Различие между всеми типами ссылок только одно - поведение GC с объектами, на которые они ссылаются:

+ **StrongReference** нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, что 
  эти ссылки на него существуют. Объект будет уничтожен только в том случае, если мы явно назначим ссылке `null`, либо
  потеряем доступ к ссылке через класс родитель (например класс родитель обнулится и объект также обнулится. Обнулится,
  т.е. его будет обрабатывать GC и высвобождать память из этого объекта)
  
+ **WeakReference** - если GC видит, что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.

Пример использования: `WeakHashMap` - это реализация которая хранит ключ, используя weak-ссылку. Когда сильная ссылка на 
фактический объект удалена и затем GC удаляет ключ из памяти, то удаляется вся запись из Map: при добавлении новой пары
<ключ, значение>, создается WeakReference для ключа и в конструктор передается ReferenceQueue. Когда GC удаляет ключ из
памяти, то ReferenceQueue возвращает соответствующий WeakReference для этого ключа. После этого соответствующий Entry
удаляется с Map.

`WeakHashMap` не предназначена для использования в качестве кэша. WeakReference создается для ключа, а не для значения.
И данные будут удалены только после того, как в программе не останется strong-ссылок на ключ, а не на значение. В 
большинстве случаев это не то, чего вы хотите достичь кэшированием. Данные с `WeakHashMap` будут удалены не сразу после
того как GC обнаружит, что ключ доступен только через weak-ссылки. Фактически очистка произойдет при следующем обращении
к `WeakHashMap`. В первую очередь `WeakHashMap` предназначен для использования с ключами, у которых метод `equals` 
проверяет идентичность объектов (использует оператор `==`). Как только доступ к ключу потерян, его уже нельзя создать 
заново.

+ **SoftReference** - если GC видит, что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти 
  только в случае необходимости. По сути SoftReference - это механизм кэширования объектов в памяти, но в критической 
  ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует 
  спасти JVM от завершения работы.
  
Общий контракт звучит следующим образом: GC гарантированно удалит из кучи все объекты, доступные только по soft-ссылке,
перед тем как бросит `OutOfMemoryError`.

Например, если нужно создать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и замедлить работу,
чем уронить процесс напрочь.

*Основная разница между SoftReference и WeakReference, в том, что SoftReference являются более подходящими для кэшей, а 
WeakReference для хранения метаданных.*

+ **PhantomReference** - если GC видит, что объект доступен только через цепочку phantom-ссылок, то он его удалит из 
  памяти, когда это ему "понравится" (зависит от реализации GC, возможно после нескольких запусков)

[к оглавлению](#garbage-collection)

## 11. Расскажите про String pool и Integer pool (Integer cache).

**String pool**:

Класс *String* отвечает за создание строк, состоящих из символов. А если быть точнее, заглянув в реализацию и посмотрев
способ их хранения, то строки представляют собой массив символов (до Java 9) и массив байт (с Java 9). Строки в Java 
являются immutable, т.е. неизменными.

Экземпляр класса *String* хранится в памяти, именуемой куча (heap), но есть некоторые нюансы. Если строка, созданная при
помощи конструктора хранится непосредственно в куче, то строка, созданная как строковый литерал, уже хранится в 
специальном месте кучи - в пуле строк (string pool). В нём сохраняются исключительно уникальные значения строковых 
литералов. Процесс помещения строк в пул называется *итернирование (от англ. interning)*.

Когда мы объявляем переменную типа *String* и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там
такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий 
адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а 
ссылка на неё возвращена и присвоена переменной.

Когда мы создаем экземпляр класса *String* с помощью оператора *new*, компилятор размещает строки в куче. При этом 
каждая строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть
в куче или в пуле строк.

В Java существует возможность вручную выполнить интернирование строки в пул путем вызова метода *intern()* у объекта 
типа *String*.

«Почему бы все строки сразу после их создания не добавлять в пул строк? Ведь это приведет к экономии памяти…». Да, среди
достаточно большого количества программистов такое заблуждение присутствует. Именно заблуждение, поскольку не все 
учитывают дополнительные затраты виртуальной машины на процесс интернирования, а также падение производительности в 
целом. Интернирование не рекомендуется вообще использовать (в виде применения метода intern()).

До Java версии 7 виртуальная машина размещала пул строк в области памяти под названием *PermGen*, которая имеет 
фиксированный размер и не может быть расширена во время выполнения приложения. Также следует отметить, что на эту 
область памяти не распространяется действие сборщика мусора. Риск интернирования строк в область PermGen (вместо кучи) 
заключается в том, что мы можем получить от JVM ошибку`OutOfMemoryError`, если будем интернировать слишком много строк 
(PermGen имеет фиксированный размер). Однажды интернированную строку в версии Java ниже 7й нельзя деинтернировать: она 
будет занимать память программы даже тогда, когда перестанет быть нужна. Из этого следует, что чрезмерное интернирование 
строк может оказать негативный эффект, связанный с утечками памяти.

Начиная с Java 8 пул строк размещается в куче, на которую распространяется процесс сборки мусора. Преимуществом данного
подхода является снижение вероятности появления ошибки `OutOfMemoryError`, так как строки, на которые не будут ссылаться
ни одна переменная в выполняемой программе, будут удалены сборщиком мусора из пула, что приведет к освобождению памяти.

Дедупликация представляет собой не что иное, как переприсваивание виртуальной машиной адресов поля value. Т.е. 
выполняется дедупликация не объектов *String*, а массивов их байт. Поля *value* нескольких объектов типа String с 
одинаковым значением текста изначально ссылаются на разные участки памяти (разные массивы байт), а после дедупликации 
будут ссылаться на один и тот же участок памяти, содержащий массив байт.

Ключевые моменты:
+ Депуликация строк доступна с Java 8
+ Она активируется параметром для виртуальной машины: -XX:+UseStringDeduplication
+ Дедупликация строк работает только со сборщиком мусора G1.
+ Опыты показывают, что применение дедупликации строк сокращает расходы кучи примерно на 10%, что в принципе неплохо, 
  учитывая, что нам не нужно вносить изменения в код.
+ Дедупликация строк работает в фоновом режиме без приостановления работы приложения
+ В отличие от пула строк, который применим только для строк, интернированных командой *intern()*, или строковых 
  литералов, но не применим для строк, созданных динамически во время жизни приложения, дедупликация строк, применима 
  для строк, созданных всеми этими способами.
  
**Int pool**:

В Java есть пул(pool) целых чисел в промежутке [-128;127]. Т.е. если мы создаем Integer в этом промежутке, то вместо 
того, чтобы каждый раз создавать новый объект, JVM берёт их из пула. 

[к оглавлению](#garbage-collection)

## 12. Расскажите о методе String.intern().

Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится 
в пуле.

[к оглавлению](#garbage-collection)

## 13. Расскажите, что такое профайлер.

Профайлер Java - Это инструмент, который отслеживает конструкции и операции байт-кода Java на уровне JVM. Эти 
конструкции кода и операции включают создание объекта, итеративное выполнение (включая рекурсивные вызова), выполнение 
методов, выполнение потоков и сборку мусора.

Основные профайлеры:

+ **JProfiler** - лучший выбор для многих разработчиков. Благодаря интуитивно понятному пользовательскому интерфейсу 
  JProfiler предоставляет интерфейсы для просмотра производительности системы, использования памяти, потенциальных утечек 
  памяти и профилирования потоков.

  Обладая этой информацией, можно легко узнать, что нам нужно оптимизировать, исключить или изменить в базовой системе.

  Как и большинство профайлеров, мы можем использовать этот инструмент как для локальных, так и для удаленных приложений.
  Это означает, что можно профилировать приложения Java работающие на удаленных машинах, без необходимости устанавливать 
  на них что-либо.

  JProfiler также обеспечивает расширенное профилирование как для баз данных SQL, так и для NoSQL. Он обеспечивает
  специальную поддержку для профилирования баз данных JDBC, JPA / Hibernate, MongoDB, Casandra и HBase.


+ **YourKit** Java Profiler работает на многих различных платформах и обеспечивает отдельные инсталляторы для каждой 
  поддерживаемой операционной системы.

  Как и JProfiler, YourKit имеет основные функции для визуализации потоков, сборок мусора, использования памяти и утечек 
  памяти с поддержкой локального и удаленного профилирования через туннелирование ssh.

  YourKit также пригодится в тех случаях, когда мы хотим профилировать созданные исключения. Мы можем легко узнать, какие 
  типы исключений были сгенерированы и сколько раз возникло каждое исключение.

  YourKit имеет интересную функцию профилирования ЦП, которая позволяет целенаправленно профилировать определенные области
  нашего кода.


+ **VisualVM** - это упрощенный, но надежный инструмент профилирования для приложений Java. Его работа зависит от других 
  автономных инструментов, предоставляемых в JDK, таких как jconsol, jstat, jstack, jinfo и jmap.

  Одним из интересных преимуществ Java VisualVM является то, что мы можем расширить его для разработки новых функций в 
  виде подключаемых модулей. Затем, мы можем добавить эти плагины во встроенный центр обновлений Java VisualVM.
  
  VisualVM поддерживает локальное и удаленное профилирование, а также профилирование памяти и ЦП. Для подключения к 
  удаленным приложениям требуется предоставить учетные данные. Также можно включить профилирование в реальном времени с
  мгновенными обновлениями.
  
  С помощью функции моментальных снимков Java VisualVM мы можем делать снимки сеансов прифилирования для последующего 
  анализа.
  

+ **NetBeans Profiler** - профайлер NetBeans входит в состав IDE NEtBeans от Oracle с открытым исходным кодом.

  Хотя этот профайлер во многом похож на VisualVM, это хороший выбор, когда мы хотим, чтобы все было в одной программе 
  (IDE + Profiler).

[к оглавлению](#garbage-collection)

## 14. Расскажите, как использовать VisualVM.

Для того, чтобы использовать VisualVM, его будет необходимо скачать по ссылке: https://visualvm.github.io. 
После чего необходимо запустить исполняемый файл - `visualvm.exe`

Всё, что вам нужно сделать для анализа программы в **VisualVM** - это запустить программу, написанную на Java, пока 
VisualVM открыта. 

Программа, которую вы запустили, автоматически появится в левой вкладке `Applications`. Как только вы увидите её, просто
дважды щёлкните по ней.

Раздел `Monitior` отображает нагрузку процессора приложением, заполненность кучи, количество выделенных потоков и классы.
Также в данном разделе имеются кнопки: `Perform GC` и `Heap Dump`. Первая выполняет команду очистки уборщиком мусора, а 
вторая соответственно делает дамп всех текущего состояния программы. Количество созданных объектов, классы этих объектов,
сколько какие объекты занимают памяти. Эту информацию можно сохранить в файл, для дальнейшего анализа.

На вкладке `Threads` показаны все потоки, которые выполняются в данный момент в программе. Тут можно проанализировать
сколько какой поток выполняется по времени, в каком статусе он находится (running, sleeping, wait, park, monitor).

На вкладке `Sampler` можно увидеть детализированную информацию по загрузке процессора и памяти компьютера. Можно 
посмотреть сколько времени процессор тратит на какой метод. Тоже самое касается и памяти.

[к оглавлению](#garbage-collection)

## 15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

**Simpling** - означает взятие большого количества дампов потока и анализ трассировки стека. Обычно это быстрее, не 
требует изменений времени исполнения в вашем байт-коде (которые могут его сломать), но также менее точен.

**Profiling (Профилирование)** - означает инструментарий ваших классов и методов, поэтому они «отчитываются» при каждом
запуске. Это более точно, так как он учитывает все вызовы инструментального метода, а не только те, которые были 
получены при завершении дампа. Однако инструментарий означает, что байт-код ваших классов изменяется, и это может 
нарушить вашу программу. Фактически по этой причине использование профилирования на больших серверах приложений (таких
как JBoss или WebLogic) часто приводит к тому, что все умирает или зависает.

[к оглавлению](#garbage-collection)

## 16. Расскажите о benchmark. Приведите примеры кода.

Самый простой способ *по-настоящему* проверить свой код - это **Java Microbenchmark Harness** (JMH). Он помогает оценить
фактическую производительность, принимая во внимание прогрев JVM и оптимизацию коду, которые могут сделать результат 
некорректным.

Для начала работы необходимо добавить зависимости:
```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.28</version>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.28</version>
</dependency>
```

Далее необходимо создать класс с основной точкой входа (мейн-класс):
```java
public class Main {
    public static void main(String[] args) throws IOException {
        org.openjdk.jmh.Main.main(args);
    }
}
```

Добавить новый пакет для классов-тестов бенчмарка и добавить в этот пакет собственно сам класс. В класс добавить метод
и пометить его аннотацией `@Benchmark`.

**Типы бенчмарков**:
+ `Mode.AverageTime` - Среднее время на операцию
+ `Mode.SampleTime` - Время на каждую операцию, включая минимальное и максимальное
+ `Mode.SingleShotTime` - Время на единичную операцию
+ `Mode.Throughput` - Число операций на единицу времени
+ `Mode.All` - Всё вышеперечисленное

Мы можем установить нужные режимы с помощью аннотации `@BenchmarkMode(...)`. Режим по умолчанию - `Mode.Throughput`

**Работа с JVM**

Для прогрева JVM мы можем добавить аннотацию `@Warmup(iterations = <int>`. Наши тесты производительности будут запущены
в указанное время, и результаты будут отброшены. После этого JVM будет уже достаточно "нагрета", а JMH запустит 
действительные тесты и предоставит нам результаты.

**Сколько времени?**

Мы можем указать, за какую единицу времени нужно выводить результаты, добавив аннотацию 
`@OutputTimeUnit(<java.util.concurrent.TimeUnit>)`:
+ `TimeUnit.NANOSECONDS`;
+ `TimeUnit.MICROSECONDS`;
+ `TimeUnit.MILLISECONDS`;
+ `TimeUnit.SECONDS`;
+ `TimeUnit.MINUTES`;
+ `TimeUnit.HOURS`;
+ `TimeUnit.DAYS`;

**Управление состоянием**

Предоставление состояния позволяет нам упростить код тестов производительности. Создав вспомогательный класс со 
`@Scope(...)`, мы можем указать параметры, которые нужно замерить:
```java
@State(Scope.Benchmark)
public class MyBenchmarkState {
    
    @Param({ "1", "10", "100", "1000", "10000" })
    public int value;
}
```

Если мы используем класс состояния в методе бенчмарка, JMH установит параметры соответственно и запустит тест для 
каждого значения:
```java
package bk;

import org.openjdk.jmh.annotations.Benchmark;

public class MyBenchmark {
    @Benchmark
    public void benchmark1(MyBenchmarkState state) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < state.value; i++) {
            builder.append("abc");
        }
    }
}
```

**Мертвый код**

JVM способна определить, присутствует ли у вас мертвый код, и удалить его:
```java
@Benchmark
public void benchmark1() {
    long lhs = 123L;
    long rhs = 321L;
    long result = lhs + rhs;
}
```
Переменная `result` ни разу не используется в коде, поэтому это по факту - мертвый код, и все три строки внутри 
бенчмарка будут удалены.

Есть два варианта, чтобы заставить JVM не убирать мертвый код:

+ Не используйте возвращаемый тип `void`. Напротив, если вы примените в методе `return result`, JVM не может быть на 
  100% уверена, что это мертвый код, поэтому он не будет удален.
+ Используйте `Blackhole`. Класс `org.opendjdk.jmh.infra.Blackhole` может быть передан в качестве аргумента и 
  предоставляет методы `consume(...)`, так что результат не будет мертвым кодом.
  
Пример класса для бенчмарк-тестов:
```java
package com.avenuecode.snippet;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;

import java.util.List;
import java.util.Random;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;
import java.util.stream.Collectors;

public class MyBenchmark {

    @State(Scope.Benchmark)
    public static class BenchmarkState {
        @Param({"1000000", "10000000", "100000000"})
        public int listSize;

        public List<Integer> testList;

        @Setup(Level.Trial)
        public void setUp() {
            testList = new Random()
                    .ints()
                    .limit(listSize)
                    .boxed()
                    .collect(Collectors.toList());
        }
    }

    public static class VolatileLong {
        private volatile long value = 0;

        public synchronized void add(long amount) {
            this.value += amount;
        }

        public long getValue() {
            return this.value;
        }
    }

    @Fork(value = 1, warmups = 1)
    @Warmup(iterations = 1)
    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void longAdder(Blackhole blackhole, BenchmarkState state) {
        LongAdder adder = new LongAdder();
        state.testList.parallelStream().forEach(adder::add);
        blackhole.consume(adder.sum());
    }

    @Fork(value = 1, warmups = 1)
    @Warmup(iterations = 1)
    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void atomicLong(Blackhole blackhole, BenchmarkState state) {
        AtomicLong atomicLong = new AtomicLong();
        state.testList.parallelStream().forEach(atomicLong::addAndGet);
        blackhole.consume(atomicLong.get());
    }

    @Fork(value = 1, warmups = 1)
    @Warmup(iterations = 1)
    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void volatileLong(Blackhole blackHole, BenchmarkState state) {
        VolatileLong volatileLong = new VolatileLong();
        state.testList.parallelStream().forEach(volatileLong::add);
        blackHole.consume(volatileLong.getValue());
    }

    @Fork(value = 1, warmups = 1)
    @Warmup(iterations = 1)
    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void longStreamSum(Blackhole blackHole, BenchmarkState state) {
        long sum = state.testList.parallelStream().mapToLong(s -> s).sum();
        blackHole.consume(sum);
    }

}
```

[к оглавлению](#garbage-collection)

## 17. Расскажите о методе finalize().

Через вызов метода `finalize()` (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная
функциональности деструкторов в C++, используемых для очистки памяти перед возвращением управления операционной системе.
Данный метод вызывается при уничтожении объекта сборщиком мусора (*garbage collector*) и переопределяя `finalize()`
можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых 
соединений, соединений с базой данных, снятие блокировок на файлы и т.д.

После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой 
метода `finalize()`, т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. 
приложение может быть завершено до того, как будет запущена сборка мусора.

Объект не обязательно будет доступен для сборки сразу же - метод `finalize()` может сохранить куда-нибудь ссылку на 
объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в
том, что «возродить» объект можно только 1 раз.

```java
public class MainClass {
    public static void main(String[] args) {
        TestClass a = new TestClass();
        a.a();
        a = null;
        a = new TestClass();
        a.a();
        System.out.println("!!! done");
    }
}
```

```java
public class TestClass {
    public void a() {
        System.out.println("!!! a() called");
    }
    
    @Override
    protected void finalize() throws Throwable {
        System.out.println("!!! finalize() called");
        super.finalize();
    }
}
```

Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), то результат выполнения 
программы с большой вероятностью будет следующий:

```text
!!! a() called
!!! a() called
!!! done
```

Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:
```java
public class MainClass {
	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}
}
```

Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат выполнения может 
разниться от запуска к запуску:

```text
!!! a() called
!!! a() called
!!! done
!!! finalize() called
```

```text
!!! a() called
!!! a() called
!!! finalize() called
!!! done
```

[к оглавлению](#garbage-collection)

## 18. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

Класс *Object* определяет метод *clone()*, который создает копию объекта. Если вы хотите чтобы экземпляр вашего класса
можно было клонировать, необходимо переопределить этот метод и реализовать интерфейс *Cloneable*. Интерфейс *Cloneable* -
это интерфейс-маркер, он не содержит ни методов, ни переменных. Интерфейсы маркеры просто определяют поведение классов.

*Object.clone()* выбрасывает исключение *CloneNotSupportedException* при попытке клонировать объект не реализующий 
интерфейс *Cloneable*.

Метод *clone()* в родительском классе *Object* является *protected*, поэтому желательно переопределить его как *public*.
Реализация по умолчанию метода *Object.clone()* выполняет неполное/поверхностное (shallow) копирование.

Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование 
в Java является поверхностным, т.е. `Object class` не знает о структуре класса, которого он копирует. При клонировании,
JVM делает такие вещи:

1. Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка 
   на этот объект.
2. Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на 
   объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.
   
Глубокое копирование дублирует всё и требует выполнения следующих правил:

1. Нет необходимости копировать отдельно примитивные данные.
2. Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться 
   `super.clone()` при переопределении метода `clone()`.
3. Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр 
   этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

Пример переопределения метода *clone()* при глубоком копировании:
```java
@Override
public Car clone() throws CloneNotSupportedException {
    Car newCar = (Car) super.clone();
    Driver driver = this.getDriver().clone();
    newCar.setDriver(driver);
    return newCar;
}
```

[к оглавлению](#garbage-collection)

## 19. Расскажите о Stack, Heap и Metaspace.

**Heap (куча)** используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также 
происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный 
доступ и на него могут ссылаться из любой части приложения.

**Stack (стек)** это область хранения данных также находящееся в общей оперативной памяти (RAM). Всякий раз, когда 
вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе.
Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего 
метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO 
(Последний-зашел-Первый-вышел).

Различия между *Heap* и *Stack* памятью:

+ Куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы.
+ Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память 
  стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
+ Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других 
  потоков.
+ Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы
  программы.
+ Если память стека полностью занята, то Java Runtime бросает исключение `java.lang.StackOverFlowError`. Если заполнена
  память кучи, то бросает исключение `java.lang.OutOfMemoryError: Java Heap Space`.
+ Размер памяти стека намного меньше памяти в куче.
+ Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.

Для определения начального и максимального размера памяти в куче используются `-Xms` и `-Xmx` опции JVM. Для стека 
определить размер памяти можно с помощью опции `-Xss`.

**Metaspace (с JDK 8)** - это отдельная область памяти, выделенная под хранение статической информации приложения. 
Например, метаданные загруженных классов. Metaspace автоматически расширяется при заполнении. Эта область так же доступна 
для сборщика мусора, как и heap. Сборщик удаляет ненужные классы из памяти, когда область для хранения метаданных заполнена.

До JDK 8 функции Metaspace выполнял PermGen (PermanentGeneration), который был отдельной областью памяти в составе heap. 
PermGen имел трудности со своевременной очисткой его пространства от неиспользуемых объектов и часто являлся источником 
утечки памяти, поэтому в JDK 8 был заменен на улучшенный аналог - Metaspace.

[к оглавлению](#garbage-collection)

## 20. Что такое ClassLoader? Перечислите основные реализации ClassLoader.

JVM читает команды в виде байт-кода из class-файлов (или других ресурсов) и передаёт их процессору в виде инструкций. 
Скомпилированный байт-код загружает в JVM загрузчик классов.

Загрузка классов - это динамические поиск и загрузка классов или интерфейсов в рантайме.

**Этапы загрузки классов.**

Для корректной работы загруженного в JVM кода процесс загрузки проходит 3 этапа:

1) _Загрузка байт-кода из class-файлов_. Байт-код также может быть загружен, например, из сети или взят из другого ресурса. 
   Также он может быть сгенерирован самим приложением.
   На этом этапе выполняются следующие действия:
   - Поиск запрошенного класса среди ранее загруженных классов
   - Получение и проверка байт-кода запрошенного класса
   - Создание экземпляра класса запрошенного класса
   - Загрузка классов-родителей. Запрошенный класс не будет считаться загруженным, если еще не загружены его классы-родители 
     или интерфейсы.
2) _Линковка (связывание)_. Этот этап имеет 3 подэтапа:
   - Верификация (Verification) - проверяет байт-код на корректность импортируемого типа.
   - Подготовка (Preparation) - выделяется память по статические переменные. На этом подэтапе все переменные 
     инициализируются либо значением по умолчанию, либо явно заданными значениями.
   - Разрешение (Resolution) - здесь происходит преобразование полей, методов и символьных ссылок типов в прямые ссылки. 
     Разрешение - это процесс динамического определения значений из символических ссылок в пуле констант рантайма.
3) _Инициализация_. Инициализация класса или интерфейса происходит путем выполнения метода их инициализации. То есть 
   вызывается код, инициализирующий переменные класса корректными стартовыми значениями. Класс или интерфейс могут быть
   инициализированы разными путями, но это не относится к теме урока, поэтому подробно разбирать мы это сейчас не будем.
   Процесс загрузки классов в JVM должен отвечать следующим требованиям:
   - Загрузка класса должна быть закончена до линковки.
   - Сначала выполняется верификация, а только потом инициализация.
   - Если на каком-либо этапе возникли ошибки ссылок, то разрешение этих проблем будет происходить только в рантайме. 
     Сделано это из-за того, что в JVM может быть реализована не только ленивая загрузка классов, при которой загрузка 
     классов, хранящихся в ссылочных полях, производится только при непосредственном обращении к этим полям, но и 
     активная загрузка, при которой данные во всех символических ссылках загружаются сразу (все символические ссылки 
     превращаются в прямые). По умолчанию разрешение происходит уже после окончания загрузки класса, как было показано в
     плане выше. Стандартный системный загрузчик работает таким образом: при ленивой загрузке сначала загружается только
     класс, в котором находится метод main(), далее при обращении из кода метода main() к других классам, происходит их
     загрузка, и так далее до конца кода программы. Классы загружаются только при обращении к ним из какой-либо части 
     кода. В этом суть ленивой загрузки по умолчанию.

**Виды загрузчиков.**

В Java есть 3 штатных загрузчика. Каждый из них загружает классы из определённого места. Далее перечислены загрузчики, 
которые были до Java 9:

- Bootstrap class loader - базовый загрузчик, загружает базовые классы из архива rt.jar. В данном архиве находятся все 
  ресурсы, необходимые для работы программ в Java - все классы из Core Java API. Данный загрузчик реализован в самой JVM
  и обратная связь с исполняющей средой у него отсутствует.
- Extension class loader - загрузчик расширений, загружает классы расширений из директории jre/lib/ext.
- System class loader - системный загрузчик классов, загружает классы из переменной окружения CLASSPATH. Является 
  стандартным загрузчиком классов в приложении (Он же Application class loader).
- Обособленно можно отметить ещё одну реализацию ClassLoader - UrlClassLoader. Данный загрузчик позволяет загружать 
  классы и ресурсы по URL-ссылке.

Обновления, которые произошли в загрузчиках классов в Java 9:

- Extension class loader преобразован в Platform class loader. Extension class loader применялся только для загрузки 
  дополнений к jdk и использовался мало. Начиная с Java 9 Platform class loader выполняет те же функции, что и Extension
  class loader, но ему добавили некоторые не очень важные функции, которые раньше выполнял Bootstrap class loader, тем 
  самым отбалансировав нагрузку на загрузчики.
- Application class loader являлся экземпляром UrlClassLoader. Начиная с Java 9 Application class loader создаётся в 
  виде экземпляра некоего внутреннего класса.

Узнать с помощью какого загрузчика был загружен класс можно с помощью метода getClassLoader():
```java
package ru.job4j;

public class Loader {
    public static void main(String[] args) throws ClassNotFoundException {
        Class loader = Loader.class;
        System.out.println("Класс переменной loader: " + loader);
        System.out.println("Загрузчик класса переменной loader:  " + loader.getClassLoader());
    }
}
```

[к оглавлению](#garbage-collection)

## 21. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?

Модель делегирования нагрузки представлена в виде иерархии. Загрузчики классов составляют иерархию, где корнем является
базовый загрузчик Bootstrap, далее идет его наследник - загрузчик расширений Extension (Platform с Java 9), далее 
наследник Extension/Platform - системный загрузчик System (Application). Каждый загрузчик хранит информацию о своём 
предке (у базового загрузчика предка нет, он корневой).  

**Абстрактный класс ClassLoader**
Каждый загрузчик, за исключением базового, является  потомком абстрактного класса `java.lang.ClassLoader`. Например, 
реализацией загрузчика расширений является класс `sun.misc.Launcher$ExtClassLoader`, а системного загрузчика – 
`sun.misc.Launcher$AppClassLoader`. Базовый загрузчик является нативным и его реализация включена в JVM.

Любой класс, который расширяет `java.lang.ClassLoader`, может предоставить свой способ загрузки классов Для этого 
необходимо переопределить соответствующие методы, которые на данный момент я могу рассмотреть только поверхностно, т.к. 
не разбирался детально в этом вопросе.

[к оглавлению](#garbage-collection)

## 22. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?

Попытка получения загрузчика у классов java.* всегда заканчивается null'ом. Это объясняется тем, что все базовые классы
загружены базовым загрузчиком, доступа к которому из управляемой среды нет.

[к оглавлению](#garbage-collection)

## 23. Расскажите алгоритм поиска и загрузки класса в JVM.

Попытка загрузки класса производится начиная с самого нижнего уровня иерархии к самому верхнему. Точнее будет сказать, 
что поиск начинается с текущего загрузчика. Текущий загрузчик - это загрузчик, который загружал класс, откуда происходит
вызов следующего класса. Как уже говорилось ранее, скорее всего текущим будет загрузчик System / Application.

Непосредственная попытка загрузки класса происходит таким образом: у каждого загрузчика есть список классов, который он
уже загружал (кэш). Сначала производится проверка, есть ли в кэше загрузчика System / Application (в текущем) требуемый 
класс. Если его там нет, задача делегируется родителю текущего загрузчика, то есть загрузчику Extension / Platform. Если
в нём тоже нет, то задача делегируется дальше родителю текущего загрузчика - в загрузчик Bootstrap. Если в кэше какого-либо 
из этих загрузчиков есть запрашиваемый класс (класс уже был загружен ранее), то возвращается объект Class данного класса, 
и поиск завершается. Если ни у одного из этих загрузчиков в кэше нет запрашиваемого класса (то есть этот класс еще не 
загружался), то начинается попытка загрузки запрашиваемого класса в обратном порядке от корневого до текущего. Сначала 
загрузчик Bootstrap пытается загрузить запрашиваемый класс. Если в нём его нет, то этот класс пытается загрузить загрузчик
Extension / Platform, далее System / Application, и если ни один из загрузчиков не загрузил запрашиваемый класс, то 
выбрасывается исключение ClassNotFoundException. Если же класс удалось загрузить какому-либо из загрузчиков, то на этом 
работа по загрузке этого класса прекращается.

[к оглавлению](#garbage-collection)