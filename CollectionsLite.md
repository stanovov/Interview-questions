## Collections Lite

[1. Что такое "коллекция"?](#1-Что-такое-коллекция)

[2. Перечислите основные методы из интерфейса java.util.Collection.](#2-Перечислите-основные-методы-из-интерфейса-javautilcollection)

[3. Назовите преимущества использования коллекций по сравнению с массивами](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)

[4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)

[5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций-List-Set-Map)

[6. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.](#6-Назовите-основные-классы-которые-имплементируютреализуют-интерфейсы-List-Set-Map)

[7. В чём отличие ArrayList от LinkedList?](#7-В-чём-отличие-ArrayList-от-LinkedList)

[8. В чём отличие HashSet от TreeSet?](#8-В-чём-отличие-HashSet-от-TreeSet)

[9. В чём отличие Set от Map?](#9-В-чём-отличие-Set-от-Map)

[10. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#10-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)

[11. Чем отличается Comparable от Comparator?](#11-Чем-отличается-Comparable-от-Comparator)

[12. Что такое сортировка по принципу Natural Order?](#12-Что-такое-сортировка-по-принципу-Natural-Order)

[13. Что такое equals и hashcode?](#13-Что-такое-equals-и-hashcode)

[14. Какие есть способы перебора всех элементов List?](#14-Какие-есть-способы-перебора-всех-элементов-List)

[15. Расскажите о методах Map.](#15-Расскажите-о-методах-map)

[16. Расскажите, какие классы реализовывают интерфейс Map?](#16-Расскажите-какие-классы-реализуют-интерфейс-map)

[17. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#17-Расскажите-о-методах-mapkeyset-и-mapentryset-Что-такое-entry)

[18. Что будет если вызвать метод map.put несколько раз с одинаковым ключом?](#18-Что-будет-если-вызвать-метод-mapput-несколько-раз-с-одинаковым-ключом)

[19. Как реализован цикл foreach?](#19-Как-реализован-цикл-foreach)

[20. В чем разница между Iterator и Iterable?](#20-В-чем-разница-между-iterator-и-iterable)

[21. В чем разница между Iterator и ListIterator?](#21-В-чем-разница-между-Iterator-и-ListIterator)

[22. Как происходит удаление элементов из ArrayList?](#22-Как-происходит-удаление-элементов-из-ArrayList)

[23. Как происходит удаление элементов из LinkedList?](#23-Как-происходит-удаление-элементов-из-LinkedList)

[24. Что такое автоупаковка и распаковка? Зачем они нужны?](#24-Что-такое-автоупаковка-и-распоковка-Зачем-они-нужны)

[25. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#25-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)

[26. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#26-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)

[27. Что такое очередь? Расскажите принцип работы и для чего она используется](#27-Что-такое-очередерь-Расскажите-принцип-работы-и-для-чего-она-используется)

[28. Расскажите про интерфейсы Queue, Deque и их иерархию.](#28-Расскажите-про-интерфейсы-queue-deque-и-их-иерархию)

[29. В чем отличие метода poll() от remove()?](#29-В-чем-отличие-метода-poll-от-remove)

[30. В чем отличие метода element() от peek()?](#30-В-чем-отличие-метода-element-от-peek)

[31. В чем отличие метода element() от poll()?](#31-В-чем-отличие-метода-element-от-poll)

[32. Перечислите наиболее часто используемые реализации интерфейса Queue.](#32-Перечислите-наиболее-часто-используемые-реализации-интерфейса-queue)

[33. Что такое ограниченные и неограниченные очереди?](#33-Что-такое-ограниченные-и-неограниченные-очереди)

[34. Что такое односторонние и двусторонние очереди?](#34-Что-такое-односторонние-и-двусторонник-очереди)

[35. В чём отличие Deque от Queue?](#35-В-чём-отличие-deque-от-queue)

[36. В чём отличие методов removeLast() и pollLast()?](#36-В-чём-отличие-методов-removelast-и-polllast)

[37. Назовите самую распространенную реализацию Deque.](#37-Назовите-самую-распространенную-реализацию-deque)

[38. Расскажите иерархию интерфейсов Collections framework?](#38-Расскажите-иерархию-интерфейсов-Collections-framework)

[39. Может ли null использоваться в качестве ключа в Map?](#39-Может-ли-null-использоваться-в-качестве-ключа-в-Map)

[40. Может ли Set содержать null?](#40-Может-ли-Set-содержать-null)

[41. Как преобразовать массив строк в ArrayList?](#41-Как-преобразовать-массив-строк-в-ArrayList)

[42. Как отсортировать список в обратном порядке?](#42-Как-отсортировать-список-в-обратном-порядке)

[43. Какие реализации SortedSet вы знаете и в чем их особенность?](#43-Какие-реализации-SortedSet-вы-знаете-и-в-чем-их-особенность)

[44. В каких случаях разумно использовать массив, а не ArrayList?](#44-В-каких-случаях-разумно-использовать-массив-а-не-ArrayList)

[45. Какие коллекции синхронизированы?](#45-Какие-коллекции-синхронизированы)

## 1. Что такое "коллекция"?

**Коллекции** - это хранилища, поддерживающие различные способы накопения и упорядочивания объектов с целью обеспечения 
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#collections-lite)

## 2. Перечислите основные методы из интерфейса java.util.Collection.

+ Возвращает число элементов в коллекции:
```java
    int size()
```

+ Возвращает `true`, если коллекция пуста, иначе возвращает `false`
```java
    boolean isEmpty()
```

+ Возвращает `true`, если объект item содержится в коллекции, иначе возвращает `false`:
```java
    boolean contains(Object item)
```

+ Возвращает объект `Iterator` для обхода элементов коллекции:
```java
    Iterator<E> iterator()
```

+ Возвращает массив, содержащий все элементы коллекции:
```java
    Object[] toArray()
```

+ Добавляет в коллекцию объект `item`. При удачном добавлении возвращает `true`, при неудачном - `false`:
```java
    boolean add(E item)
```

+ Возвращает `true`, если объект `item` удачно удален из коллекции, иначе возвращается `false`:
```java
    boolean remove(Object item)
```

+ Удаляет все элементы из коллекции:
```java
    void clear()
```

+ Возвращает `true`, если эта коллекция содержит все элементы указанной коллекции:
```java
    boolean containsAll(Collection<?> c)
```

+ Добавляет в коллекцию все элементы из коллекции `col`. При удачном добавлении возвращает `true`, при неудачном - `false`:
```java
    boolean addAll(Collection<? extends E> col)
```

+ Удаляет все объекты коллекции `col` из текущей коллекции. Если текущая коллекция изменилась, возвращает `true`, иначе
возвращает `false`:
```java
    boolean removeAll(Collection<?> col)
```

+ Удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции `col`. Если текущая коллекция после 
удаления изменилась, возвращает `true`, иначе возвращает `false`:
```java
    boolean retainAll(Collection<?> col)
```

+ Возвращает параллельный `Stream` с этой коллекцией в качестве источника.
```java
    Stream<E> parallelStream()
```

+ Удаляет все элементы этой коллекции, удовлетворяющие заданному предикату.
```java
    boolean removeIf(Predicate<? super E> filter)
```

+ Возвращает объект `Spliterator` для обхода элементов коллекции:
```java
    Spliterator<E> spliterator()
```

+ Возвращает последовательный `Stream` с этой коллекцией в качестве источника.
```java
    Stream<E> stream()
```

[к оглавлению](#collections-lite)

## 3. Назовите преимущества использования коллекций по сравнению с массивами

+ отсутствует необходимость следить за размерами коллекции (в отличие от массива);
  
+ позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано 
много методов по добавлению, удалению, сортировке элементов и т.п.;

+ если правильно подобрать коллекцию, то можно увеличить производительность программы;

+ упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

[к оглавлению](#collections-lite)

## 4. Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных.

[к оглавлению](#collections-lite)

## 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы разделяют 
все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и 
наборы пар «ключ — значение» (словари).

**Collection** — этот интерфейс находится в составе JDK c версии 1.2 и определяет основные методы работы с простыми наборами 
элементов, которые будут общими для всех его реализаций (например `size()`, `isEmpty()`, `add(E e)` и др.). Интерфейс был слегка 
доработан с приходом дженериков в Java 1.5. Также, в версии Java 8, было добавлено несколько новых методов для работы с 
лямбдами (такие как `stream()`, `parallelStream()`, `removeIf(Predicate<? super E> filter)` и др.).

+ **List** - упорядоченный список. В какой последовательности данные положили, в такой они и хранятся.
  Допускаются дубликаты. Доступ к элементам списка осуществляется по индексу.

+ **Set** - используется для хранения множеств уникальных объектов. В коллекции этого типа разрешено наличие только одной
  ссылки типа `null`.

+ **Queue** (Deque) - представляет функционал для структур данных в виде очереди (FIFO первый вошел, первый вышел). Эта
  коллекция предназначена для хранения элементов в порядке, нужном для их обработки. Реализует LinkedList.

**Map**. Данный интерфейс также находится в составе JDK c версии 1.2 и предоставляет разработчику базовые методы для работы 
с данными вида «ключ — значение». Также как и `Collection`, он был дополнен дженериками в версии Java 1.5 и в версии Java 8 
появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения 
(`getOrDefault(Object key, V defaultValue)`, `putIfAbsent(K key, V value)`).

[Справочник по Java Collections Framework](https://habr.com/ru/post/237043/)

[к оглавлению](#collections-lite)

## 6. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.

+ **List:**

1. ArrayList - простой список объектов
2. LinkedList - представляет связанный список

+ **Set:** 

1. HashSet - набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код.
2. TreeSet - набор отсортированных объектов в виде дерева.
3. LinkedHashSet - расширяет класс HashSet. Класс поддерживает связный список элементов набора в том порядке, в котором 
они вставлялись.

+ **Map:** 

1. HashMap - структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение.
2. TreeMap - структура данных в виде дерева, где каждый элемент имеет уникальный ключи и некоторое значение.
3. LinkedHashMap - отображение с запоминанием порядка, в котором добавлялись элементы.

[к оглавлению](#collections-lite)

## 7. В чём отличие ArrayList от LinkedList?

**ArrayList - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**LinkedList - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же `ArrayList` предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#collections-lite)

## 8. В чём отличие HashSet от TreeSet?

Класс `Object` имеет метод `hashCode()`, который используется классом `HashSet` для эффективного размещения объектов, 
заносимых в коллекцию. В классах объектов, заносимых в `HashSet`, этот метод должен быть переопределен `@Override`.

`HashSet` реализован на основе хеш-таблицы, а `TreeSet` - на основе бинарного дерева.

`HashSet` гораздо быстрее чем `TreeSet` (константное время против логарифмического для большинства операций, таких как,
add, remove, contains), но `TreeSet` гарантирует упорядоченность объектов.

[к оглавлению](#collections-lite)

## 9. В чём отличие Set от Map?

`Set` - это интерфейс в иерархии Коллекции, который не может содержать повторяющиеся элементы, тогда как `Map` - это 
интерфейс, который хранит пару ключ и значение. `Set` - это интерфейс, расширяющий интерфейс `Collection`, а `Map` - 
отдельный интерфейс.

[к оглавлению](#Collections-Lite)

## 10. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у коллекции вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

[к оглавлению](#collections-lite)

## 11. Чем отличается Comparable от Comparator?

**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволяет определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

[Comparable и Comparator](http://java-online.ru/blog-comparator.xhtml)

[к оглавлению](#collections-lite)

## 12. Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок `natural order` для сортировки:

+ строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологический (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

В остальных классах сортировку нужно определять в ручном режиме через `Comparable` или `Comparator`.

[к оглавлению](#collections-lite)

## 13. Что такое equals и hashcode?

`Equals` и `hashCode` являются фундаментальными методами объявленные в классе `Object` и содержатся в стандартных 
библиотеках Java.

Метод `equals()` используется для сравнения объектов, а `hashCode()` - для генерации целочисленного кода объекта.
Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в `HashMap`. Метод 
`equals` также используется для обеспечения хранения только уникальных объектов в `HashSet` и других `Set` реализациях, 
а также в любых других случаях, когда нужно сравнивать объекты.

Реализация по умолчанию метода `equals()` в классе `java.lang.Object` сравнивает ссылки на адреса в памяти, которые 
хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные ссылаются 
на один и тот же объект.

Java рекомендует переопределять методы `equals()` и `hashCode()`, если предполагается, что сравнение должно 
осуществляться в соответствии с бизнес-логикой.

Так как `HashMap` в Java полагается на методы equals() и hashCode() для сравнения своих `key` и `values`, то Java 
предлагает следующие правила для переопределения этих методов:

1. Рефлексивность: Объект должен равняться себе самому.
   
2. Симметричность: если `a.equals(b)` возвращает `true`, то `b.equals(a)` должен тоже вернуть `true`.

3. Транзитивность: если `a.equals(b)` возвращает `true` и `b.equals(с)` тоже возвращает `true`, то `c.equals(a)` тоже 
   должен возвращать `true`.
   
4. Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение до тех пор, пока какое-либо 
   значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их 
   свойства остаются неизменными.
   
5. Сравнение `null`: объект должен быть проверен на `null`. Если объект равен `null`, то метод должен вернуть `false`, 
    а не `NullPointerException`. Например `a.equals(null)` должен вернуть `false`.

Соглашение между `equals` и `hashCode` в Java:

1. Если объекты равны по результатам выполнения метода `equals`, тогда их `hashCode` должны быть одинаковыми.

2. Если объекта не равны по результатам выполнения метода `equals`, тогда их `hashCode` могут быть как одинаковыми, так 
   и разными. Однако для повышенной производительности, лучше, чтобы разные объекты возвращали разные коды.

[к оглавлению](#collections-lite)

## 14. Какие есть способы перебора всех элементов List?

+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
[Способы перебора списка](https://www.codeflow.site/ru/article/java-iterate-list)    

[к оглавлению](#collections-lite)

## 15. Расскажите о методах Map.

+ очищает коллекцию
```java
    void clear()
```

+ Для указанного ключа `key` этот метод устанавливает в качестве value результат выполнения функции `remappingFunction`
```java
    V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
```

+ Метод добавит новый элемент в **Map**, но только в том случае, если элемент с таким ключом там отсутствует. В качестве 
  value ему будет присвоен результат выполнения функции `mappingFunction`. Если же элемент с таким ключом уже есть — он не 
  будет перезаписан, а останется на месте.
```java
    V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)
```

+ Тот же принцип, что и у `Map.compute()`, но все вычисления будут выполнены только в случае, если элемент с ключом key 
  уже существует.
```java
    V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)
```

+ возвращает true, если коллекция содержит ключ `key`
```java
    boolean containsKey(Object key)
```

+ возвращает true, если коллекция содержит значение `value`
```java
    boolean containsValue(Object value)
```

+ возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
```java
    Set<Map.Entry<K,V>> entrySet()
```

+  возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj
```java
    boolean equals(Object o)
```

+ Метод `forEach` работает не только для классов, реализующих интерфейс `Collection`, но и для `Map`
```java
    void forEach(BiConsumer<? super K,? super V> action)
```

+ возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null
```java
    V get(Object key)
```

+ возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение defaultVlue
```java
    V getOrDefault(Object key, V defaultValue)
```

+ возвращает true, если коллекция пуста
```java
    boolean isEmpty()
```

+ возвращает набор всех ключей отображения
```java
    Set<K> keySet()
```

+ Если в вашей `Map` ключ `key` не существует, или `value` для этого ключа равно `null` — метод добавляет в `Map` 
  переданную пару `key-value`.
+ Если ключ `Key` существует и его `value != null` — метод меняет его `value` на результат выполнения переданной функции 
  `remappingFunction`
+ Если `remappingFunction` возвращает `null` - `key` удаляется из коллекции.
```java
    V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)
```

+ Помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он 
  перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же 
  ключа еще не было в коллекции, то возвращается значение null
```java
    V put(K key, V value)
```

+ добавляет в коллекцию все объекты из переданного отображения `m`
```java
    void putAll(Map<? extends K,? extends V> m)
```

+ помещает в коллекцию новый объект с ключом `key` и значением `value`, если в коллекции еще нет элемента с подобным ключом.
```java
    V putIfAbsent(K key, V value)
```

+  удаляет объект с ключом `key`
```java
    V remove(Object key)
```

+ удаляет запись для указанного ключа, только если она в данный момент сопоставлена с указанным значением.
```java
    boolean remove(Object key, Object value)
```

+ заменяет значение ключа `key` на `value`, если такой ключ существует. Если нет — ничего не происходит.
```java
    V replace(K key, V value)
```

+ делает то же самое, но только если текущее значение `key` равно `oldValue`.
```java
    boolean replace(K key, V oldValue, V newValue)
```

+ заменяет все значения `value` на результат выполнения функции `function`.
```java
    void replaceAll(BiFunction<? super K,? super V,? extends V> function)
```

+ возвращает количество элементов коллекции
```java
    int size()
```

+ возвращает набор всех значений отображения
```java
    Collection<V> values()
```

[к оглавлению](#collections-lite)

## 16. Расскажите, какие классы реализовывают интерфейс Map?

**Hashtable** — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать `null` в качестве 
значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена 
в его состав. Как и другие коллекции из Java 1.0, `Hashtable` является синхронизированной (почти все методы помечены как 
`synchronized`). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, 
в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.

**HashMap** — коллекция является альтернативой `Hashtable`. Двумя основными отличиями от `Hashtable` являются то, что 
`HashMap` не синхронизирована и `HashMap` позволяет использовать `null` как в качестве ключа, так и значения. Так же как 
и `Hashtable`, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление 
элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В
идеале является константным, но может быть и линейным O(n).

**LinkedHashMap** — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от `HashMap`, порядок итерирования равен 
порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами 
(аналогично `LinkedList`). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимает коллекция.

**TreeMap** — реализация `Map` основанная на красно-чёрных деревьях. Как и `LinkedHashMap` является упорядоченной. 
По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть 
настроено под конкретную задачу при помощи объекта `Comparator`, который указывается в качестве параметра при создании 
объекта `TreeMap`.

**WeakHashMap** — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage 
Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких 
ссылок.

**`ConcurrentHashMap`** - Потоково-безопасная версия Map, не использующая синхронизационную блокировку.

**`IdentityHashMap`** - Хеш-таблица, использующая для сравнения ключей оператор == вместо метода equals(). Применяется
в особых случаях, не для рядовых целей.

[к оглавлению](#collections-lite)

## 17. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?

**Интерфейс Map.Entry** в Java позволяет работать с записями Map.

Метод `keySet()`, объявленный интерфейсом `Map`, возвращает `Set`, содержащий ключи `Map`.

Метод `entrySet()`, объявленный интерфейсом `Map`, возвращает `Set`, содержащий записи `Map`. Каждый из этих элементов 
является объектом `Map.Entry`.

### Методы:

+ Возвращает true, если obj - это Map.Entry, чей ключ и значение равны значению вызывающего объекта.
```java
    boolean equals(Object obj)
```

+ Возвращает ключ для этой записи в Map.
```java
    Object getKey( )
```

+ Возвращает значение для этой записи в Map.
```java
    Object getValue( )
```

+ Возвращает хэш-код для этой записи в Map.
```java
    int hashCode( )
```

+ Устанавливает значение `v` для этой записи Map. Вызывается `ClassCastException`, если `v` не является правильным типом 
  для `Map`. A Исключение `NullPointerException` выдается, если `v` является нулём, а `Map` не разрешает нулевые ключи.
  Исключение `UnsupportedOperationException` возникает, если карта не может быть изменена.
```java
    Object setValue(Object v)
```

[к оглавлению](#collections-lite)

## 18. Что будет если вызвать метод map.put несколько раз с одинаковым ключом?

Если в Map положить два значения с одинаковым ключом, то первое значение будет заменено вторым. При этом, если метод 
`put()` будет вызван второй раз с тем же ключом, то ключ будет обновлен со значением, переданным вторым аргументом.

[к оглавлению](#collections-lite)

## 19. Как реализован цикл foreach?

`foreach` реализован на основе `Iterator`, т.е. он работает для классов, реализующих интерфейс `Iterable`.

[к оглавлению](#collections-lite)

## 20. В чем разница между Iterator и Iterable?

**Iterable** представляет собой простое представление ряда однородных элементов, которые могут повторяться определенное 
количество раз. Он не имеет никакого итерационного состояния, такого как "текущий элемент". Вместо этого он имеет один 
метод, который создает `Iterator`.

**Iterator** - объект с итерационным состоянием. Он позволяет вам проверить, есть ли у него больше элементов с помощью 
метода `hasNext()` и перейти к следующему элементу (если он есть) с помощью метода `next()`

Как правило, `Iterable` должен иметь возможность выдавать любое количество допустимых Iterator-ов.

Реализация `Iterable` - это та, которая сама предоставляет `Iterator`:
```java
public interface Iterable<T> {
  Iterator<T> iterator();
}
```

**Итератор** - это простой способ разрешить некоторым циклическим путем собирать данные без возможности изменения 
элементов коллекции (хотя и с возможностью их удаления).
```java
public interface Iterator<E> {
  boolean hasNext();
  E next();
  void remove();
}
```
Можно рассмотреть эти 2 интерфейса еще с одной стороны:
+ **Итерируемый** (`Iterable`): Класс, который можно повторить. То есть тот, у которого есть понятие "принесите мне 
  первое, теперь следующее, и так далее, пока мы не закончим".
+ **Итератор** (`Iterable`): Класс, который управляет итерацией по итерируемому. То есть, он отслеживает, где мы 
  находимся в текущей итерации, и знает, что представляет собой следующий элемент и как его получить.

Чтобы сделать объект итерабельным, он должен возвращать объект `Iterator`. Чтобы обеспечить выполнение этого контракта, 
необходимо использовать интерфейс `Iterable`. Он содержит метод с именем `iterator()` и возвращает `Iterator`. Следовательно,
любой класс, реализующий `Iterable`, может вернуть `Iterator`.

[к оглавлению](#collections-lite)

## 21. В чем разница между Iterator и ListIterator?

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. 
`ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. 
`ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
`remove()`. Iterator не поддерживает данного функционала.

[к оглавлению](#collections-lite)

## 22. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

[к оглавлению](#collections-lite)

## 23. Как происходит удаление элементов из LinkedList?

Находится заданный элемент.
Далее заменяются ссылки `previous` и `next` у соседних элементов и таким образом удаляемый элемент выпадает из цепочки.

[к оглавлению](#collections-lite)

## 24. Что такое автоупаковка и распаковка? Зачем они нужны?

Примитивные типы не являются ссылочными типами (объектами), поэтому если нам требуется объект примитивного типа, его 
значение должно быть упаковано в соответствующий класс-обёртку. Например, int в Integer или long в Long. Начиная с Java 
5 такие преобразования выполняются компилятором автоматически и называются автоупаковкой и распаковкой.

Распаковка и упаковка касается только единичных элементов. Например, нельзя упаковать/распаковать таким образом массив 
int в лист Integer или распаковать лист в массив.

Помните, что значения примитивных типов (int, long, char и т.д.) - это чистые данные. А соответствующие им ссылочные 
типы Integer, Long, Character и т.д. - это обёртки для этих чистых данных.

[к оглавлению](#collections-lite)

## 25. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

Появление классов-обёрток обусловлено тем, что Java - это объектно-ориентированный язык, и все сущности в идеале должны 
быть объектами. Но отказавшись от примитивных типов, упала бы производительность, поэтому к существующим примитивным 
типам добавили соответствующие классы-обертки, тем самым обеспечив гибкость работы с примитивными значениями.

Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Следующий код будет приводить 
в постоянному пересозданию новых объектов и чрезмерному расходу памяти:

```java
Integer sum = 0;
for (int i = 128; i < 300; i++) {
    sum += i;
}
System.out.println(sum);
```

При перезаписи переменной sum каждый раз будет создаваться новый объект в памяти. Исключением являются только 
кэшированные значения из пула Integer от -128 до 127 включительно. Эти значения будут браться из него (переменная sum
будет ссылаться на соответствующее значение в пуле Integer).

Автоупаковка и распаковка очень часто происходит при работе с коллекциями, так как они не могут хранить примитивные типы 
данных.

Для очень трудоёмких вычислений, где производительность критически важна, следует использовать примитивные типы. Для 
остальных программ на Java это скорее всего будет не так критично, но знать и помнить об автоупаковке и распаковке нужно,
чтобы понимать, как будет работать код, который вы пишете, и избежать возможных проблем заранее.

[к оглавлению](#collections-lite)

## 26. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.

- При работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит
  дополнительное время.
- Примитивные типы занимают меньше места в памяти.
- Если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя,
  понадобится упаковка.
- Обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа со
  значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для Integer
  это parseInt(), valueOf(), compareTo() и т.д.).

[к оглавлению](#collections-lite)

## 27. Что такое очередь? Расскажите принцип работы и для чего она используется

Структура данных, которая в программировании называется очередью, представляет из себя хранилище однотипных элементов, в 
котором первым будет извлекаться тот элемент, который был туда и вставлен первым. Такой способ организации хранения 
данных называется FIFO, по первым буквам фразы, описывающей этот способ хранения – First-In-First-Out).

Очередь работает по тому же принципу, как и любая очередь в реальной жизни – например очередь за билетами в кино 
(человек, который первым встал в очередь первым дойдет до кассы и купит билет). Следовательно, тот, кто станет в очередь 
последним – и купит билет последним.

Очередь – очень удобный инструмент, который используется для моделирования реальных ситуаций ожидания клиентов в банке,
вылета самолетов или передачи данных по Интернету.

[к оглавлению](#collections-lite)

## 28. Расскажите про интерфейсы Queue, Deque и их иерархию.

Интерфейс **Queue** описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно —
используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO 
(first-in-first-out). Расширяет интерфейс Collection. Помимо методов, определённых в интерфейсе Collection, определяет 
дополнительные методы для извлечения и добавления элементов в очередь. Такая очередь позволяет поместить элементы в один
конец очереди, а извлекать их – из другого. Поэтому такие очереди называются односторонними.

**PriorityQueue** — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в 
Java 1.5). Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы 
сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта 
Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.

---

Интерфейс **Deque** также является очередью, но ее отличительной особенностью то, что эта очередь является двухсторонней, 
т.е. она поддерживает удаление и добавление элементов с обоих концов очереди. Расширяет интерфейс Queue. Таким 
образом, в отличие от Queue, здесь также можно организовать способ хранения элементов по принципу как и FIFO, так и LIFO (сокращение по 
первой букве от описания этого принципа на английском языке Last In First Out – последний пришел, первый вышел). Такую 
структуру данных в программировании называют стеком. Пример аналогии из жизни – стопка тетрадей на проверку у учителя, 
учитель проверяет их по порядку и та тетрадь, которая была положена в эту стопку первой будет проверена последней.
Необходимо быть предельно аккуратными при использовании методов, которые при своей работе генерируют непроверяемое
исключение. Предпочитайте использовать методы poll(), pollFirst(), pollLast, peekFirst(), peekLast(), peek().

**ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать 
конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта 
коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к 
элементам по индексу и хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если 
используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.

---

Остальные типы очередей предназначены для многопоточного использования, это BlockingQueue, TransferQueue, 
ConcurrentLinkedQueue и ConcurrentLinkedDeque.

Реализации BlockingQueue (ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue) — это своего рода 
синхронизированные версии их оригиналов, т.е. почти каждая операция выполняется синхронно (блокируется).
Сюда же можно отнести и DelayQueue — также синхронизированная, внутри использует PriorityQueue.

[к оглавлению](#collections-lite)

## 29. В чем отличие метода poll() от remove()?

Методы `remove()` и `poll()` удаляют верхушку очереди и возвращают ее. Какой элемент будет удален (первый или последний)
зависит от реализации очереди. Методы `remove()` и `poll()` отличаются лишь поведением, когда очередь пустая: метод `remove()` 
генерирует исключение, а метод `poll()` возвращает `null`.

[к оглавлению](#collections-lite)

## 30. В чем отличие метода element() от peek()?

Методы `element()` и `peek()` возвращают элемент из начала очереди. Методы `element()` и `peek()` отличаются лишь 
поведением, когда очередь пустая: метод `element()` генерирует исключение, а метод `peek()` возвращает `null`.

[к оглавлению](#collections-lite)

## 31. В чем отличие метода element() от poll()?

Оба метода возвращают элемент из начала очереди. Но в отличие от `element()`, `poll()` удаляет этот элемент из очереди.
Также если очередь пустая, то `element()` генерирует исключение, а `poll()` возвращает значение `null`.

[к оглавлению](#collections-lite)

## 32. Перечислите наиболее часто используемые реализации интерфейса Queue.

Наиболее часто используемые реализации интерфейса `Queue`: `LinkedList`, `ArrayDeque`, `PriorityQueue` и 
`ArrayBlockingQueue`. `LinkedList` и `ArrayDeque` наследует напрямую не от `Queue`, а от `Deque`.

[к оглавлению](#collections-lite)

## 33. Что такое ограниченные и неограниченные очереди?

Все очереди, доступные в пакете java.util, являются неограниченными очередями, а очереди, доступные в пакете 
`java.util.concurrent`, являются ограниченными очередями.

[к оглавлению](#collections-lite)

## 34. Что такое односторонние и двусторонние очереди?

**Односторонняя** очередь позволяет поместить элементы в один конец очереди, а извлекать их - из другого.

Очередь является **двухсторонней**, если она поддерживает удаление и добавление элементов с обоих концов очереди.

[к оглавлению](#collections-lite)

## 35. В чём отличие Deque от Queue?

Основное отличие между `Queue` и `Deque` заключается в способе доступа к элементам. В queue элементы добавляются в конец 
и удаляются с начала, что соответствует принципу «первым пришел — первым ушел». В `Deque` можно добавлять элементы как в 
начало, так и в конец, а удаление элементов может производиться с обоих концов.

[к оглавлению](#collections-lite)

## 36. В чём отличие методов removeLast() и pollLast()?

Методы `removeLast()` и `pollLast()` возвращают с удалением элемент из конца очереди. Методы `removeLast()` и 
`pollLast()` отличаются лишь поведением, когда очередь пустая: метод `removeLast()`генерирует исключение, а метод 
`pollLast()` возвращает `null`.

[к оглавлению](#collections-lite)

## 37. Назовите самую распространенную реализацию Deque.

Наиболее часто используемой реализацией интерфейса `Deque` является `LinkedList`.

### Но:

`LinkedList`, возможно, являются худшей структурой для итерации каждого элемента. Кроме того, они потребляют гораздо 
больше памяти. Если вам нужно добавить/удалить оба конца, `ArrayDeque` значительно лучше, чем `LinkedList`. Произвольный 
доступ к каждому элементу также равен O(1) для циклической очереди. Единственная лучшая операция `LinkedList` — удаление 
текущего элемента во время итерации.

### Почему LinkedList самая используемая реализация:

Существует много кода, написанного с использованием `LinkedList`, поэтому будьте осторожны при принятии решения об 
использовании, `ArrayDeque` особенно потому, что оно НЕ реализует `List` интерфейс (я думаю, что это достаточно 
серьезная причина).

[к оглавлению](#collections-lite)

## 38. Расскажите иерархию интерфейсов Collections framework?

+ interface **`Collections`** extends **`Iterable`**.
    + interface `Set` (коллекция без дублирования)
        + `HashSet` базирующаяся на `HashMap` В качестве ключа используется добавляемый элемент, 
        а в качестве значения — объект-пустышка (new Object())
        + `LinkedHashSet` в основе лежит `LinkedHashMap`
    + interface `SortedSet` Методы: `first()`, `last()`
        + `TreeSet` (отсортированный список) содержит в себе объект `NavigableMap`.
    + interface `Queue` очередь Методы: `offer()`, `element()`, `peek()`, `poll()`, `remove()`.
    + interface `Deque` двусторонняя очередь `addFirst()`, `addLast()`, `getFist()`, `getLast()`, 
    (`push()`, `pop()` -> использовать как стек)
    + interface `List` упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно 
    повторяющиеся, можно по значению первый найденный)
    + `Vector` @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая `null` 
    в качестве элемента
        + `Stack` - данная коллекция является расширением коллекции `Vector`. реализация стека `LIFO`.
        + `ArrayList` динамический массив, можно хранить `null`
        + `LinkedList` связный список (implementation `List` & `Deque`)
+ interface **`Map`** (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) 
`get()`, `put()`, `entrySet()`, `keySet()`, `values()`.
    + interface `SortedMap` (по порядку нарастания ключей)
    + interface `NavigableMap`
        + `TreeMap` реализация `Map` основанная на красно-чёрных деревьях (отсортированная по умолчанию `natural odering`, 
        можно задать свой компаратор)
    + `AbstractMap`
    + `HashMap` позволяет использовать `null` как в качестве ключа, так и значения
        + LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично `LinkedList`
    + `WeekHashMap` - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, `Garbage Collector` автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ 
этого элеметна нет жёстких ссылок

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Lite)

## 39. Может ли null использоваться в качестве ключа в Map?

`HashMap` оперирует с `null`-ключом без каких-либо проблем. Его `hash` всегда равен `0`. 

В пустой `TreeMap` можно положить единственный `null`-ключ, 
все остальные операции (кроме `size()` и `clear()`, кстати) после этого не работают. 

В непустой `TreeMap` положить `null`-ключ нельзя из-за обязательного вызова `compareTo()`.

[к оглавлению](#Collections-Lite)

## 40. Может ли Set содержать null?

для `HashSet` работает. `TreeSet` — только для первого элемента.

[к оглавлению](#Collections-Lite)

## 41. Как преобразовать массив строк в ArrayList?

```java
Arrays.asList(words)
```

[к оглавлению](#Collections-Lite)

## 42. Как отсортировать список в обратном порядке?

```java
List reversedList = Collections.reverse(list)
```

[к оглавлению](#Collections-Lite)

## 43. Какие реализации SortedSet вы знаете и в чем их особенность?

`TreeSet` - в основе лежит красно-черное дерево, которое умеет само себя балансировать.

`TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[к оглавлению](#Collections-Lite)

## 44. В каких случаях разумно использовать массив, а не ArrayList?

Рекомендация от Oracle: используйте `ArrayList` вместо массивов. 

Если ответить на этот вопрос нужно по-другому, то можно сказать следующее: 
Массивы могут быть быстрее и кушать меньше памяти. 
Списки теряют в производительности из-за возможности автоматического увеличения размера и сопутствующих проверок.

[к оглавлению](#Collections-Lite)

## 45. Какие коллекции синхронизированы?

Для этого используется пакет `Concurrent`. А также `@Deprecated` `HashTable`, `Vector`.

Получение синхронизированной коллекции из не синхронизированной:
```java
Collections.synchronizedList(list);
Collections.synchronizedSet(set);
Collections.synchronizedMap(map);
```

Получение коллекции только для чтения:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```

[к оглавлению](#Collections-Lite)
