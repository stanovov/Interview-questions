## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс?](#3-Укажите-из-каких-элементов-состоит-класс)

[4. Что такое конструктор?](#4-Что-такое-конструктор)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое нестатический метод?](#8-Что-такое-нестатический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовым родительным классом для всех классов?](#10-Какой-класс-является-базовым-родительным-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни.](#11-Что-такое-наследование-приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта?](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительного класса?](#13-Как-вызвать-метод-из-родительного-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопрделение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое сокрытие метода?](#16-Что-такое-сокрытие-метода)

[17. Что такое виртуальная функция и используются ли они в Java?](#17-Что-такое-виртуальная-функция-и-используются-ли-они-в-java)

[18. Что такое перегрузка метода?](#18-Что-такое-перегрузка-метода)

[19. Можно ли изменить тип возвращаемых данных при перегрузке метода?](#19-Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)

[20. Что такое множественное наследование? Как его можно реализовать в Java?](#20-Что-такое-можественное-наследование-как-его-можно-реализовать-в-java)

[21. Что такое полиморфизм? Приведите примеры из реальной жизни](#21-Что-такое-полиморфизм-приведите-примеры-из-реальной-жизни)

[22. Что такое инкапсуляция?](#22-Что-такое-инкапсуляция)

[23. Как реализована инкапсуляция в Java?](#23-Как-реализована-инкапсуляция-в-java)

[24. Можно ли применить модификаторы доступа к конструкторам?](#24-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Перечислите элементы, которые может содержать интерфейс.](#26-Перечислите-элементы-которые-может-содержать-интерфейс)

[27. Можно ли создать объект интерфейса? Если да, то как?](#27-Можно-ли-создать-объект-интерфейса-Если-да-то-как)

[28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?](#28-Может-ли-интерфейс-содержать-какие-либо-методы-с-реализацией-если-да-то-какие)

[29. Что такое абстракция?](#29-Что-такое-абстракция)

[30. Что такое абстрактный класс?](#30-Что-такое-абстрактный-класс)

[31. Сколько абстрактных методов должен и может содержать абстрактный класс?](#31-Сколько-абстрактных-методов-должен-и-может-содержать-абстрактный-класс)

[32. Может ли абстрактный класс содержать обычные методы?](#32-Может-ли-абстрактный-класс-содержать-обычные-методы)

[33. Сколько объектов абстрактного класса можно создать в программе?](#33-Сколько-объектов-абстрактного-класса-можно-создать-в-программе)

[34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?](#34-Что-нужно-делать-если-наследник-абстрактного-класса-не-переопределяет-все-абстрактные-методы-родителя)

[35. Чем отличается интерфейс от абстрактного класса?](#35-Чем-отличается-интерфейс-от-абстрактного-класса)

[36. Что такое вложенные классы? Зачем они нужны?](#36-Что-такое-вложенные-классы-Зачем-они-нужны)

[37. Какие типы вложенных классов существуют в Java?](#37-Какие-типы-вложенных-классов-существуют-в-java)

[38. Что такое внутренний класс? Когда он применяется?](#38-Что-такое-внутренний-класс-Когда-он-применяется)

[39. Что такое статический вложенный класс? Когда он применяется?](#39-Что-такое-статический-вложенный-класс-Когда-он-применяется)

[40. Сколько объектов статического вложенного класса можно создать в программе?](#40-Сколько-объектов-статического-вложенного-класса-можно-создать-в-программе)

[41. Что такое локальный класс? Когда он применяется?](#41-Что-такое-локальный-класс-Когда-он-применяется)

[42. Что такое анонимный класс? Когда он применяется?](#42-Что-такое-анонимный-класс-Когда-он-применяется)

[43. Сколько объектов анонимного класса можно создать в программе?](#43-Сколько-объектов-анонимного-класса-можно-создать-в-программе)

[44. Что такое исключения? Какие типы исключительных ситуаций бывают?](#44-Что-такое-исключения-Какие-типы-исключительных-ситуаций-бывают)

[45. Назовите основные методы класса Object?](#45-Назовите-основные-методы-класса-object)

[46. Что такое шаблоны проектирования?](#46-Что-такое-шаблоны-проектирования)

[47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.](#47-Объясните-шаблон---декоратор-Придумайте-пример-не-относящийся-к-технике)

[48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.](#48-Объясните-шаблон---стратегия-Придумайте-пример-не-относящийся-к-технике)

[49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.](#49-Объясните-шаблон---синглтон-Придуматйе-пример-не-относящийся-к-технике)

[50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.](#50-Объясните-шаблон---фабричный-метод-Придумайте-пример-не-относящийся-к-технике)

[51. Объясните шаблон - абстрактная фабрика. Придумайте пример, не относящийся к технике.](#51-Объясните---шаблон-абстрактная-фабрика-Придумайте-пример-не-относящийся-к-технике)

[52. Что такое enum? Когда можно его применять?](#52-Что-такое-enum-Когда-можно-его-применять)

[53. Что такое record? Когда можно его применять?](#53-Что-такое-record-Когда-можно-его-применять)

[54. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?](#54-Зачем-нужны-stringbuilder-stringbuffer-stringjoiner-Что-они-делают)

[55. Чем отличаются StringBuffer и StringBuilder?](#55-Чем-отличаются-stringbuffer-и-stringbuilder)

[56. Каким образом производится экранирование символов и зачем это нужно?](#56-Каким-образом-производится-экранирование-символов-и-зачем-это-нужно)

[57. Что такое управляющие последовательности?](#57-Что-такое-управляющие-последовательности)

[58. Зачем нужно форматирование данных? Метод format()](#58-Зачем-нужно-форматирование-данных-Метод-format)

[59. Что такое varargs? В каких случаях стоит его применять?](#59-Что-такое-varargs-В-каких-случаях-стоит-его-применять)

[60. В каких случаях может возникнуть неоднозначность при работе с varargs?](#60-В-каких-случаях-может-возникнуть-неоднозначность-при-работе-с-varargs)

[61. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?](#61-Что-такое-форматированный-вывод-Какие-механизмы-позволяют-осуществить-форматированный-вывод)

[62. Для чего используется конструктор в абстрактном классе?](#62-Для-чего-используется-конструктор-в-абстрактном-классе)

[63. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?](#63-Можно-ли-создать-анонимный-класс-если-в-классе-нет-конструктора-по-умолчанию)

[64. Что такое композиция?](#64-Что-такое-композиция)

[65. Что такое агрегация?](#65-Что-такое-агрегация)

[66. Как обрабатываются исключительные ситуации?](#66-Как-обрабатываются-исключительные-ситуации)

## 1. Что такое ООП?

Объектно-ориентированное программирование - методология программирования, основанная на представлении программы в виде 
совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию 
наследования. Сегодня ООП - самая распространенная методология программирования. Мир, в котором мы живем, состоит из 
объектов. Если мы посмотрим вокруг, то увидим, что нас окружают дома, деревья, автомобили, мебель, посуда, компьютеры. 
Все эти предметы являются объектами, и каждый из них обладает набором определенных характеристик, поведением и 
назначением. Мы привыкли к объектам, и мы их используем всегда для вполне конкретных целей. Например, если нам 
необходимо доехать до работы, мы пользуемся автомобилем, если захотим поесть - посудой, а если отдохнуть - нам 
понадобится удобный диван. Человек привык мыслить объектно для решения задач в повседневной жизни. Это послужило одной 
из причин использования объектов в программировании, а такой подход к созданию программ назвали объектно-ориентированным.

[Принципы ООП](https://javarush.ru/groups/posts/principy-oop)

[к оглавлению](#OOP)

## 2. Базовые концепции ООП?

4 главные особенности, которые вместе образуют парадигму объектно-ориентированного программирования.

+ **Наследование** - механизм, который позволяет описать новый класс на основе существующего (родительского). Поля и 
  методы, описанные в родительских классах, можно использовать в классах-потомках. При этом механизм наследования очень 
  гибкий, и недостающую в потомках функциональность можно дописать отдельно.

+ **Абстракция** - Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот - 
  отбрасывание второстепенных, незначительных.
  
+ **Инкапсуляция** - Ещё один базовый принцип ООП, при котором атрибуты и поведение объекта объединяются в одном классе, 
  внутренняя реализация объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс. 
  Задача программиста - определить, какие атрибуты и методы будут доступны для открытого доступа, а какие являются 
  внутренней реализацией объекта и должны быть недоступны для изменений. Инкапсуляция в Java означает ограничение 
  доступа к данным и возможностям их изменения.
  
+ **Полиморфизм** - это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение 
  объектов будет разным в зависимости от типа, к которому они принадлежат.

[к оглавлению](#OOP)

## 3. Укажите из каких элементов состоит класс?

Класс определяется с помощью ключевого слова `class`. После названия класса идут фигурные скобки, между которыми 
помещается тело класса - то есть его поля и методы. Шаблоном или описанием объекта является класс, а объект представляет
экземпляр этого класса. Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные, 
которые хранит объект, и поведение - действия, которые может совершать объект. Для хранения состояния объекта в классе 
применяются поля. Для определения поведения объекта в классе применяются методы.

[к оглавлению](#OOP)

## 4. Что такое конструктор?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с
операцией `new`).

Конструктор нужен для автоматической инициализации переменных, т.е. он инициализирует объект непосредственно во время 
создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без
возвращаемого значения `void`.

Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без 
параметров.

[к оглавлению](#OOP)

## 5. Можно ли наследовать конструктор?

В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. Конструкторы не являются членами, 
поэтому они не наследуются.

Конструктор суперкласса может быть вызван из подкласса. С помощью ключевого слова `super` конструктору родителю можно 
передать аргументы. Даже больше того, если у конструктора суперкласса есть конструктор с параметрами и нет конструктора 
без параметров, то мы обязаны вызвать конструктор суперкласса с параметрами в начале конструктора дочернего класса.

[к оглавлению](#OOP)

## 6. Что такое перегрузка конструктора?

Перегрузка конструктора заключается в том, что мы можем объявить несколько конструкторов в одном классе. Однако с точки 
зрения синтаксиса языка, в некотором локальном пространстве не может быть двух одинаковых имен. В данном случае 
допускается объявление нескольких конструкторов, однако они должны отличаться набором параметров. Когда мы вызываем 
перегруженный конструктор, то из нескольких объявленных конструкторов, компилятор автоматически определяет нужный 
конструктор по его параметрам, которые указываются при вызове.

Если кратко, то - перегрузка конструктора позволяет установить различные способы начальной инициализации объектов класса.

Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то его нужно 
создать явно.

[к оглавлению](#OOP)

## 7. Что такое статический метод?

**Статический метод** - это метод, который можно вызвать без создания объекта, напрямую через имя класса. Статические 
методы отличаются от обычных тем, что они привязаны к классу, а не к объекту. 

Важно:

+ Статический метод нельзя переопределять. Он "один" для класса и его наследников.
+ Статические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего
  метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом".
+ В отличие от локальных переменных статические поля и методы не потокобезопасны в Java.

[к оглавлению](#OOP)

## 8. Что такое нестатический метод?

**Нестатический метод** - это метод, который принадлежит экземпляру класса, т.е. он принадлежит объекту класса и может 
быть вызван с помощью ссылки на данный объект.

[к оглавлению](#OOP)

## 9. Для чего используется ключевое слово this?

`this` - это неявный первый параметр любого нестатического метода класса.
У какого объекта вызывается метод, тот и будет передан в качестве параметра `this`.

соответственно, `this` используется:

1. в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса.
   Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.
```java
class Student {
    int age;
    Student (int age) {
        this.age = age;
    }
}
```
2. когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризированном).
   Вызов `this()` может находиться только в первой строке конструктора.
```java
public class Toy {
    String name;
    int cost;
    String manufacturer;
    int age;

    public Toy(String name, int cost, String manufacturer, int age) {
        this(name, cost, manufacturer);
        this.age = age;
        System.out.println("В конструкторе с четырьмя параметрами");
    }

    public Toy(String name, int cost, String manufacturer) {
        this();
        this.name = name;
        this.cost = cost;
        this.manufacturer = manufacturer;
        System.out.println("В конструкторе с тремя параметрами");
    }

    public Toy() {
        System.out.println("В конструкторе по умолчанию");
    }
}
public class ToyDemo {
    public static void main(String[] args) {
        Toy toy = new Toy("Кукла", 34, "Disney", 3);
    }
}
```
вывод:
```
В конструкторе по умолчанию
В конструкторе с тремя параметрами
В конструкторе с четырьмя параметрами
```

[к оглавлению](#OOP)

## 10. Какой класс является базовым родительным классом для всех классов?

`Object` является базовым суперклассом для всех остальных классов Java.

Все непримитивные типы, включая массивы, наследуют прямо или косвенно от него. Поэтому ссылочная переменная класса 
`Object` может ссылаться на объект любого другого класса.

[к оглавлению](#OOP)

## 11. Что такое наследование? Приведите примеры из реальной жизни.

Представим, что у нас есть класс Dog. Что есть у каждой собаки? Четыре лапы, один хвост - и ещё они умеют гавкать и 
вилять хвостом. А теперь представим, что мы хотим создать классы для разных пород - овчарок, бульдогов и такс. У всех 
этих пород тоже будут четыре лапы и хвост, они тоже будут гавкать и вилять хвостом. Конечно, мы можем просто брать и 
копировать эти методы и переменные в каждый класс. Но зачем? Мы можем использовать наследование. Если мы сделаем все 
классы пород наследниками класса Dog, они будут иметь доступ ко всем его методам и переменным автоматически.

[к оглавлению](#OOP)

## 12. Опишите процесс создания нового объекта?

Объект создается с помощью ключевого слова `new`, которое вызывает конструктор класса, который инициализирует начальное
состояние объекта.

1. Сначала для хранения объекта выделяется память.
2. Далее Java-машина создает ссылку на этот объект.
3. В завершение происходит инициализация переменных и вызов конструктора.

Подробнее рассмотрим третий пункт:
1. Сначала идет инициализация статических переменных класса-предка.
2. После, идет инициализация статических переменных класса-потомка.
3. Инициализация переменных продолжается. Третьими по счету будут инициализированы нестатические переменные класса-предка.
4. Наконец, дело дошло до конструкторов. Точнее, до конструктора базового класса.
5. Теперь пришла очередь инициализации нестатических полей класса-потомка.
6. И наконец вызывается конструктор дочернего класса.

[к оглавлению](#OOP)

## 13. Как вызвать метод из родительного класса?

Если родительский метод был переопределен в своем дочернем объекте, дочерние объекты всегда будут использовать 
переопределенную версию. Но всегда можно использовать ключевое слово `super` для вызова родительского метода.

[к оглавлению](#OOP)

## 14. Что такое переопределение метода?

**Переопределение метода** - это одна из возможностей языка программирования, позволяющая дочернему классу обеспечивать
специфическую реализацию метода, уже реализованного в одном из родительских классов.

Также есть возможность уведомить компилятор о том, что мы именно переопределяем метод с помощью аннотации `@Override`. 
Проставленная над методом аннотация сообщает компилятору (да и читающим твой код программиста тоже): "Все ок, это не 
ошибка и не моя забывчивость. Я помню, что такой метод уже есть, и хочу переопределить его".

Также у переопределения есть ряд ограничений:
1. У переопределенного метода должны быть те же аргументы, что и у метода родителя.
2. У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
3. Модификатор доступа у переопределенного метода также не может отличаться от "оригинального".

[к оглавлению](#OOP)

## 15. Можно ли переопределить статический метод?

Нет, статические методы не могут быть переопределены, поскольку они являются частью класса, а не объекта.

[к оглавлению](#OOP)

## 16. Что такое сокрытие метода?

Сокрытие метода - это когда дочерний класс определяет статический метод с такой же сигнатурой, что содержится в 
родительском классе. Статические методы можно наследовать, но переопределить их нельзя. Обычный статический метод может
быть вызван из своего класса, аналогично скрытый статический метод также вызывается из своего класса.

Если в дочернем классе требуется изменить статический метод из родительского класса, это называется "Сокрытием 
статического метода" (hiding) в отличие от "переопределения" для нестатического метода (overriding).

[к оглавлению](#OOP)

## 17. Что такое виртуальная функция и используются ли они в Java?

В Java виртуальная функция означает функцию, которая может быть переопределена в своих подклассах. Таким образом, все 
нестатические методы Java являются виртуальной функцией.

[к оглавлению](#OOP)

## 18. Что такое перегрузка метода?

**Перегрузка методов** — это приём программирования, который позволяет разработчику в одном классе для методов с разными 
параметрами использовать одно и то же имя. В этом случае мы говорим, что метод перегружен.

При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые
указываются при вызове.

[к оглавлению](#OOP)

## 19. Можно ли изменить тип возвращаемых данных при перегрузке метода?

Для того чтобы перегрузить метод, достаточно объявить его новый вариант, отличающийся от уже существующих. Нужно лишь 
соблюсти одно условие: набор параметров в каждом из перегружаемых методов должны быть разными. Одного лишь различия в 
типах возвращаемых значений для этой цели недостаточно. Перегружаемые методы могут иметь разные возвращаемые типы, но 
при вызове метода выполняется лишь тот его вариант, в котором параметры соответствуют передаваемым аргументам. Тип 
возвращаемого значения не учитывается при перегрузке методов.

[к оглавлению](#OOP)

## 20. Что такое множественное наследование? Как его можно реализовать в Java?

**Множественное наследование** - способность создавать классы с множеством классов-родителей. В отличие от других 
популярных объектно-ориентированных языков, вроде C++, язык Java не поддерживает множественное наследование классов.

В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы. 

Возникает неоднозначность: если метод класса D вызывает метод класса А (и этот метод не переопределён в классе D),
а классы B и C по своему переопределили этот метод, то от какого класса его наследовать? от B или C?

В Java множественное наследование поддерживают интерфейсы.

Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией.
Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые
обращаются к нужным методам этих объектов. И наследоваться от этого класса.

[к оглавлению](#OOP)

## 21. Что такое полиморфизм? Приведите примеры из реальной жизни

Полиморфизм описывают выражением: *Один интерфейс - множество реализаций.*

**Полиморфизм** - это возможность работать с несколькими типами, как будто это один и тот же тип,
в то же время поведение каждого типа будет уникальным в зависимости от его реализации.

**Примеры:**
+ Пульт управления один для разных моделей.
+ Монетоприемник в каком-нибудь продающем автомате.
+ Цоколь лампочки - это переменная определенного базового типа. Лампочка - созданный объект конкретного класса.
  Лампочки разные - цоколь один.
  
[к оглавлению](#OOP)

## 22. Что такое инкапсуляция?

**Инкапсуляция** - это сокрытие реализации и отделение его внутреннего представления от внешнего.

Т.е. это скрытие полей объектов, ограничение доступа к определенным методам и полям.

[к оглавлению](#OOP)

## 23. Как реализована инкапсуляция в Java?

Изначальное значение слова «инкапсуляция» в программировании — объединение данных и методов работы с этими данными в 
одной упаковке («капсуле»). В Java в роли упаковки-капсулы выступает класс. Класс содержит в себе и данные (поля 
класса), и методы для работы с этими данными.

[к оглавлению](#OOP)

## 24. Можно ли применить модификаторы доступа к конструкторам?

В конструкторе допускается применение модификаторов доступа. Пример применение модификатора доступа к конструкторам -
паттерн проектирования "Singleton". К конструктору применяется модификатор доступа `private`, что не дает возможности
создать объект класса "Singleton" вне этого класса.

[к оглавлению](#OOP)

## 25. Что такое интерфейс?

Интерфейс - это абстрактный класс, в котором не реализован ни один метод. С помощью этих методов описывается некое 
поведение, которое должно быть реализовано в классах, применяющих этот интерфейс. Цель интерфейса - абстрагировать 
интерфейс класса от его реализации. Иными словами: интерфейсы задают описание, как должен работать объект и не содержат 
реализации. 

Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.

[к оглавлению](#OOP)

## 26. Перечислите элементы, которые может содержать интерфейс.

###Поля

В интерфейсе могут быть объявлены поля, но на них накладываются некоторые ограничения - они должны быть проинициализированы 
сразу при объявлении, а также по умолчанию являются публичными (public), статическими (static) и неизменяемыми (final), 
то есть константами.  Константы, как и абстрактные методы, наследуются производными интерфейсами от базовых.

###Методы

Интерфейс должен содержать абстрактные методы (пустые, без реализации), но начиная с Java 8 мы также можем включать в 
интерфейсы методы с реализацией - статические (static) или дефолтные (default), а начиная с Java 9 еще и приватные (private).

####Статические методы

Главная их особенность - они принадлежат только интерфейсу, в котором объявлены, и не наследуются ни классами, реализующими 
интерфейс, ни интерфейсами-наследниками. Статические методы можно применять, когда вы хотите сохранить какие-то данные на 
уровне интерфейса, а уже эти данные могут быть использованы любым классом-реализацией при необходимости.

####Дефолтные методы

Так же, как и статические, они имеют реализацию, но при их объявлении используется ключевое слово default. Главное отличие 
дефолтного метода в том, что он будет унаследован классом, который реализует данный интерфейс. При этом класс может как 
переопределить данный метод, так и не переопределять и воспользоваться реализацией по умолчанию. Дефолтные методы удобно 
использовать, если в классах, имплементирующих один и тот же интерфейс, должен быть объявлен метод с одинаковой реализацией.
Также дефолтные методы наследуются производными интерфейсами от базовых.

####Приватные методы

Обозначаются ключевым словом private. Они могут быть как статическими, так и нестатическими. Эти методы используются в 
интерфейсах для того, чтобы вынести какую то логику из публичных статических или дефолтных методов, либо для предотвращения 
дублирования кода. В приватный метод можно убрать все детали реализации, чтобы уменьшить пользовательский код и упростить 
его читаемость, также в private методы нужно убирать задвоившийся код.

###Вложенные / внутренние классы и интерфейсы

Также интерфейсы могут содержать вложенные классы и интерфейсы, но такие конструкции используются очень редко. Внутренние 
классы и интерфейсы всегда public и static. Вложенные в класс интерфейсы - это еще один уровень изоляции и организации кода. 
Такая схема чаще используется, когда нужно привязать интерфейс к классу, а не к пакету, либо этот интерфейс нужен только 
внутри этого класса для определенных целей.

###Обобщенные типы

Обобщенные типы (generics) используются вместо указания конкретного типа, тем самым интерфейс может работать с разными 
типами данных, то есть отпадает необходимость писать несколько одинаковых реализаций, отличающихся только типом данных.

###Enum

Также в интерфейсе возможно объявить Enum (перечисление).

[к оглавлению](#OOP)

## 27. Можно ли создать объект интерфейса? Если да, то как?

Интерфейс не может содержать конструкторов, так как интерфейс - это абсолютная абстракция, то есть вся реализация
возложена на классы-реализации. По причине отсутствия конструкторов создать экземпляр интерфейса невозможно.

[к оглавлению](#OOP)

## 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?

Начиная с Java 8 мы также можем включать в интерфейсы методы с реализацией - статические (static) или дефолтные (default), 
а начиная с Java 9 еще и приватные (private).

[к оглавлению](#OOP)

## 29. Что такое абстракция?

Абстракция - это парадигма ООП, которая подразумевает набор важных характеристик объекта, доступных из любого места 
программы. То есть абстракция выделяет значимые свойства объекта и отбрасывает незначимые. Java - это объектно-ориентированный
язык программирования. ООП в программирование пришло из реального мира, так как говоря, например, об автомобиле, мы 
представляем себе его абстракцию - как он выглядит, как на нем передвигаться, как пользоваться его системами. Услышав 
слово "автомобиль", мы не представляем себе из какой стали изготовлены поршни в его двигателе, либо какой плотности 
тормозная жидкость в тормозной системе. Да и нам, как пользователю, не нужна эта информация. Если бы люди передавали всю 
информацию не абстракциями, то ее невозможно было было воспринимать. Объекты в мире слишком сложны. И когда мы описываем 
какой-то объект, мы выбираем самые важные свойства объекта, по которым легче всего будет составить его модель. Зачем 
подробно описывать автомобиль, состоящий из десятков тысяч деталей? Сам же автомобиль для человека выполнен по тому же 
принципу. Мы пользуемся автомобилем, а его внутренние процессы от нас абстрагированы. Мы не знаем что происходит внутри, 
но при этом мы получаем весь функционал, который хотим от него. То есть абстракция скрывает от нас всё лишнее и оставляет 
самое важное, что мы хотим от автомобиля.

То же самое и в программе. При проектировании классов и создании объектов нужно выделять только главные свойства сущности, 
а ненужные отбрасывать, либо скрывать. Например: свойство "максимальная скорость" или "ускорение". Если мы описываем 
гоночный автомобиль, то эти свойства будут одними из основных. Если же мы описываем рейсовый автобус, то эти свойства в 
контексте автобуса, перевозящего людей, имеют малое значение. Для автобуса больше подойдут свойства типа "количество 
сидячих мест" или " общая вместимость". В свою очередь, для гоночного автомобиля эти свойства будут не важны.

Также большую роль играет степень абстракции. Если объект описан очень подробно, то модель получится очень сложной, ее 
будет трудно применять. Если же объект описан недостаточно подробно, то мы получим только приблизительную модель, с которой 
тоже трудно будет работать.

[к оглавлению](#OOP)

## 30. Что такое абстрактный класс?

Абстрактные классы позволяют описать общее поведение и задать особенное поведение для классов наследников.

Абстрактный класс - это такой класс, в котором описывается общее состояние и поведение его будущих 
наследников. В нем абстрагируются (выделяются) главные свойства объекта, то есть предоставляется базовый функционал для 
классов-наследников, которые будут этот функционал реализовывать.

Абстрактный класс очень похож на обычный. Разница только в том, что абстрактный класс - это заготовка под будущую 
реализацию. В нем помимо обычных можно определить абстрактные методы - это методы, которые объявляются без реализации. 
У них нет тела и фигурных скобок. Тем самым объявляется некое поведение, но реализация перекладывается на класс-наследник.

[к оглавлению](#OOP)

## 31. Сколько абстрактных методов должен и может содержать абстрактный класс?

Согласно документации класс, объявленный как abstract, является абстрактным. Такой класс может включать, а может и не
включать абстрактные методы. Обычно класс называют абстрактным, если он имеет хотя бы один абстрактный метод. Все
абстрактные методы должны быть переопределены в классах-наследниках. Если мы объявим абстрактным класс без абстрактных 
методов, то это не будет иметь смысла и будет только путать, в том числе из-за этого нельзя будет создать экземпляр 
такого класса, поэтому объявляя класс абстрактным, нужно четко понимать, зачем вы это делаете. Абстрактные методы 
отвечают на вопрос "что делать", а "как делать" (сама реализация) уже будет прописано в каждом классе-наследнике по-своему.

[к оглавлению](#OOP)

## 32. Может ли абстрактный класс содержать обычные методы?

Методы класса необязательно должны быть все абстрактными. Если реализация какого-либо метода общая для всех наследников, 
можно определить ее в абстрактном классе.

[к оглавлению](#OOP)

## 33. Сколько объектов абстрактного класса можно создать в программе?

Так как абстрактный класс - это заготовка, то его экземпляр нельзя создать.

Суть абстрактного класса заключается в том, что он не завершён, и его нужно завершить в классах-наследниках. То есть этот 
класс не готов к использованию. В нём, например, может отсутствовать реализация каких-то методов. Раз класс не готов к 
использованию, то нельзя создавать его объект. А вот экземпляры наследников абстрактного класса создавать можно. 

[к оглавлению](#OOP)

## 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?

Если какой-то абстрактный метод остается не переопределённым в классе-наследнике, то класс-наследник тоже нужно объявить 
абстрактным.

[к оглавлению](#OOP)

## 35. Чем отличается интерфейс от абстрактного класса?

Абстрактный класс - это класс, у которого не реализован один и более методов. Нужен для реализации семейства классов 
(Отношение IS-A). Выглядит как заготовка под будущую реализацию. Также это средство для повторного использования кода.

Интерфейс - это абстрактный класс, в котором все методы не реализованы (помимо default, private, static), а также нет 
нестатических переменных. Интерфейс задаёт семантику класса. Вы всегда будете уверены, что класс, который реализует 
какой-либо интерфейс, реализует и все его методы, то есть поддерживает заданную семантику.

Наследовать `extends` можно только один абстрактный класс, а реализовать `implements` интерфейсов сколько угодно. 
Интерфейс может наследовать другой интерфейс. В интерфейсах нет конструкторов. Поэтому код, написанный на интерфейсах 
более масштабируем и его легче поддерживать. При использовании абстрактных классов, а это всегда наследование, мы связываем наш код.

Любой интерфейс - это по существу абстрактный класс, но не наоборот. Несмотря на их схожесть, реального сходства между
абстрактным классом и интерфейсом очень мало.

[к оглавлению](#OOP)

## 36. Что такое вложенные классы? Зачем они нужны?

В Java есть возможность определить класс внутри другого класса. Класс, полностью находящийся внутри другого класса, 
называется вложенным.

Все вложенные классы выглядят как обычные классы - они могут иметь свои переменные и методы. Вложенный класс считается 
членом внешнего класса. Область видимости вложенных классов ограничена внешним классом (классом, внутри которого они 
определены).  Вложенные классы не могут существовать самостоятельно (то есть их нельзя использовать отдельно от класса, 
в который они вложены). Вложенные классы имеют прямой доступ к членам внешнего класса (в том числе и private). Внешний 
класс не имеет прямого доступа к членам вложенных в него классов.

Вложенные классы применяются, когда нужно написать вспомогательный код для другого класса. Также вложенные классы
скрывают переменные и методы от остальной части программы, что является хорошим способом ограничения области их видимости.

[к оглавлению](#OOP)

## 37. Какие типы вложенных классов существуют в Java?

Вложенные классы могут быть статическими и нестатическими.

Внутренние классы могут быть:
- просто внутренними (обычный нестатический внутренний класс).
- локальными (класс, находящийся внутри некоторого блока кода другого класса (между фигурными скобками { }).
- анонимными (локальный класс без имени).

[к оглавлению](#OOP)

## 38. Что такое внутренний класс? Когда он применяется?

Внутренними (inner) называются нестатические вложенные классы.

Основные случаи применения вложенных классов (всех видов):
- Логическая группировка классов, использующихся в одном месте. Если какой-то класс создан для использования только одним 
  другим классом, то стоит вложить его в этот класс, чтобы показать связь этих классов.
- Повышение инкапсуляции. Если класс Y вынужден обращаться к членам класса X, которые иначе были бы объявлены с 
  модификатором private, то следует вложить класс Y  в класс X. В таком случае эти члены можно будет объявить с 
  модификатором private, но класс Y сможет к ним обращаться, а также класс Y будет скрыт от окружающего мира.
- Облегчение чтения и поддержки кода. Небольшие классы можно вложить во внешние классы, поближе к месту их применения.

**Рекомендации Oracle по применению вложенных классов**:

- Это способ логической группировки классов, которые используются только в одном месте: если класс полезен только для 
  одного другого класса, то логично встроить его в этот класс и сохранить их вместе. Вложение таких «вспомогательных 
  классов» делает их пакет более упорядоченным.
- Это увеличивает инкапсуляцию: рассмотрим два класса верхнего уровня, A и B, где B требуется доступ к членам A, которые 
  в противном случае были бы объявлены закрытыми. Скрывая класс B внутри класса A, члены A могут быть объявлены закрытыми, 
  и B может получить к ним доступ. Кроме того, сам B может быть скрыт от внешнего мира.
- Это может привести к более удобному для чтения и сопровождения коду: вложение небольших классов в классы верхнего 
  уровня помещает код ближе к тому месту, где он используется.

[к оглавлению](#OOP)

## 39. Что такое статический вложенный класс? Когда он применяется?

Статический вложенный класс не привязан к объекту, объект статического вложенного класса не хранит в себе ссылку на 
внешний класс. Статический вложенный класс можно использовать, когда прямая связь между вложенным и внешним классом не 
требуется. Например, мы можем скрыть во внешнем классе реализацию чего-либо или другую информацию.

То есть если вложенный класс является неотъемлемой частью внешнего класса, он должен быть внутренним, а если прямой связи 
нет, то его можно сделать статическим вложенным классом. При этом важно не забывать, что делать классы вложенными требуется
только для логической группировки классов (если одни классы являются частью других, либо инкапсулируют что-либо из внешнего 
класса), чтобы повысить читаемость кода (все связанные классы будут в одном месте), а также повысить инкапсуляцию, вложив 
одни классы в другие. Если у рассматриваемых классов нет связи между собой, то и делать вложенность не требуется.

###Основные свойства статических вложенных классов:

1) Как и другие статические члены, они принадлежат внешнему классу, а не экземпляру класса.
2) В их объявлении может быть указан любой модификатор доступа.
3) Они могут определять как статические, так и нестатические члены.
4) Они имеют доступ только к статическим членам во внешнем классе (включая private).

Объект статического внутреннего класса можно создать без ссылки на внешний класс. Статический вложенный класс 
взаимодействует с членами экземпляра своего внешнего класса (и других классов) так же, как и любой другой класс верхнего 
уровня (относительного вложенных), то есть статический вложенный класс ведет себя так же, как и любой обычный класс, 
просто он вложен в другой класс верхнего уровня.

[к оглавлению](#OOP)

## 40. Сколько объектов статического вложенного класса можно создать в программе?

Объектов статического вложенного класса можно создать сколько угодно. Не путайте со статической переменной, которая 
создаётся только одна на всю программу.

[к оглавлению](#OOP)

## 41. Что такое локальный класс? Когда он применяется?

Локальный класс - это разновидность внутреннего класса, в которой класс объявляется в другом классе внутри какого-либо 
блока кода (между фигурными скобками { }). Например, в теле оператора if, цикле for, методе, конструкторе и т.д. По своим 
свойствам локальный класс похож на обычный внутренний класс, но с некоторыми отличиями.

Локальный класс можно объявить везде, где возможно объявить локальную переменную. Область видимости локального класса 
такая же, как и у локальной переменной. У локальных классов есть имя, и их можно использовать неоднократно.

Локальные классы связаны с внешним классом (как и внутренние классы), поэтому у них есть доступ ко всем членам внешнего 
класса (даже к private). Локальные классы содержат ссылку на внешний класс только в нестатическом контексте, подобно 
обычным внутренним классам.

В объявлении локального класса допустим только один модификатор - final, который имеет обычное значение в виде запрета 
наследования этого класса. Остальные модификаторы объявить невозможно, так как локальный класс не является членом 
внешнего класса, а относится к блоку кода, в котором он объявлен.

Время жизни локального класса ограничено блоком кода, в котором он находится (метод getFullName), либо пока в программе 
остаются рабочие ссылки на этот класс.

Также локальные классы не могут содержать в себе статические объявления (классы, методы и т.д.). Допустимы только 
переменные-константы.

**Важно!** В Java 16 произошло обновление, начиная с которого все виды внутренних классов поддерживают статические объявления, 
чтобы иметь возможность объявлять в себе record, enum и локальные интерфейсы, все из которых являются неявно статическими 
при объявлении их во внутреннем классе.

Если локальный класс находится внутри статического метода, он имеет доступ только к статическим переменным внешнего класса.

Локальный класс применяется, когда нужно написать класс, который планируется использовать в пределах одного метода или
другого блока кода. Локальные классы следует писать короткими, чтобы не ухудшать читаемость кода.

Локальные классы - это просто способ инкапсуляции некоторого состояния и поведения локально. Применяется очень редко.

[к оглавлению](#OOP)

## 42. Что такое анонимный класс? Когда он применяется?

**Анонимный класс** - это локальный класс без имени, который сразу создается и реализуется (без имени класса) от суперкласса
или интерфейса. Анонимным классом следует пользоваться, если нужен локальный класс для одноразового использования.

Анонимный класс может обращаться к переменным и методам внешнего класса, в том числе static и private. Цель применения 
данного класса - это короткая запись, короткий класс для выполнения конкретной разовой задачи. При этом нам не потребуется 
создавать новые классы в программе для выполнения одной задачи, тем самым загромождая программу классами разового применения, 
раздувая код.

Анонимные классы могут не только наследовать другие классы, но и реализовывать интерфейсы. Реализация интерфейсов 
анонимными классами на практике применяется чаще и полезнее, чем наследование.

[к оглавлению](#OOP)

## 43. Сколько объектов анонимного класса можно создать в программе?

Анонимные классы следует использовать, когда уже есть тип, который описывает этот класс (либо его родителей), и задача 
будет выполняться один раз за всю работу программы (то есть нужен всего один экземпляр этого класса). Соответственно, и 
использоваться этот экземпляр будет в месте его создания, либо сразу после этого. Если подобную задачу нужно выполнять 
несколько раз, нужно создать локальный класс. Желательно применять анонимные классы к компактным задачам, чтобы не 
ухудшать чтение кода. Анонимный класс живет, пока на него существует рабочая ссылка.

[к оглавлению](#OOP)

## 44. Что такое исключения? Какие типы исключительных ситуаций бывают?

В программировании есть термин - программа завершилась с исключительной ситуацией или в программе упал Exception.  Это 
значит, что в процессе выполнения программы виртуальная машина не смогла выполнить инструкции написанные в вашей программе.

Если в программе возникают исключения, то программист должен найти причины их возникновения и устранить.

Все исключения делятся на 2 вида - проверяемые "checked" и непроверяемые "unchecked".

Все проверяемые исключения происходят от класса `Exception`. Что значит "проверяемые"? Например, компилятор знает, что
если программист в коде считывает данные из файла, может легко возникнуть ситуация, что файл не существует. И таких
ситуаций, которые он может заранее предположить, очень много. Поэтому компилятор заранее проверяет наш код на наличие
потенциальных исключений. Если он их найдет, то не скомпилирует код, пока мы не обработаем их или не пробросим наверх.

Второй вид исключений - "непроверяемые". Они происходят от класса `RuntimeException`. Чем же они отличаются от
проверяемых? Разница в том, что этих ошибок компилятор не ожидает. Непроверяемые исключения чаще всего являются
следствием ошибок программиста. А компилятор не в силах предусмотреть все возможные неправильные ситуации, которые люди
могут создать своими руками. Поэтому он не проверяет обработку таких исключений в коде. Несколько примеров
unchecked-исключений: `ArithmeticException` - возникает при делении на ноль. `ArrayIndexOutOfBoundsException` -
возникает при попытке обратиться к ячейке за пределами массива.

[к оглавлению](#OOP)

## 45. Назовите основные методы класса Object?

Основные методы:

возвращает строковое представление объекта:
```java
public String toString()
```

возвращает хэш-код, связанный с вызывающим объектом:
```java
public native int hashCode()
```

определяет, равен ли один объект другому:
```java
public boolean equals(Object obj)
```

возвращает специальный объект, который описывает текущий класс:
```java
public final native Class getClass()
```

Метод позволяет клонировать объект: создает дубликат объекта:
```java
protected Object clone()
```

вызывается перед удалением неиспользуемого объекта. Позволяет "освободить" родные не-Java ресурсы:
```java
protected void finalize()
```

Методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей:
```java
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout)
public final void wait(long timeout, int nanos)
public final void wait()
```

[к оглавлению](#OOP)

## 46. Что такое шаблоны проектирования?

**Паттерн проектирования** — это часто встречающееся решение определённой проблемы при проектировании архитектуры
программ.

В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет
собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить
под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если
алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может
отличаться в двух разных программах.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором
нарисовано решение, но не конкретные шаги его реализации.

### Из чего состоит паттерн?

Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:

+ проблема, которую решает паттерн;
+ мотивации к решению проблемы способом, который предлагает паттерн;
+ структуры классов, составляющих решение;
+ примера на одном из языков программирования;
+ особенностей реализации в различных контекстах;
+ связей с другими паттернами.

[к оглавлению](#OOP)

## 47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.

**Декоратор** — это структурный паттерн проектирования *(Структурные паттерны отвечают за построение удобных в поддержке 
иерархий классов)*, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные
«обёртки».

###Применимость:

**Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.**

Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому 
клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

**Когда нельзя расширить обязанности объекта с помощью наследования.**

Во многих языках программирования есть ключевое слово `final` , которое может заблокировать наследование класса. Расширить 
такие классы можно только с помощью Декоратора.

###Шаги реализации:

1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
2. Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.
3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы 
   базового декоратора должны делегировать действие вложенному объекту.
5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен 
   выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.
7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

###Пример из жизни:

Любая одежда — это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних 
классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода.
Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

###Преимущества и недостатки:

####Плюсы:

+ Большая гибкость, чем у наследования.
+ Позволяет добавлять обязанности на лету.
+ Можно добавлять несколько новых обязанностей сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

####Минусы:

+ Трудно конфигурировать многократно обёрнутые объекты.
+ Обилие крошечных классов

[к оглавлению](#OOP)

## 48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.

**Стратегия** — это поведенческий паттерн проектирования *(Поведенческие паттерны решают задачи эффективного и безопасного 
взаимодействия между объектами программы)*, который определяет семейство схожих алгоритмов и помещает каждый из них в 
собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

###Применимость:

**Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.**

Стратегия позволяет варьировать поведение объекта во время выполнения программы, подставляя в него различные 
объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).

**Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.**

Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов, а затем свести первоначальные классы к 
одному, сделав поведение этого класса настраиваемым.

**Когда вы не хотите обнажать детали реализации алгоритмов для других классов.**

Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов, скрыв эти детали внутри 
классов-стратегий.

**Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора 
представляет собой вариацию алгоритма.**

Стратегия помещает каждую лапу такого оператора в отдельный класс-стратегию. Затем контекст получает определённый 
объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать 
другую стратегию.

###Шаги реализации:

1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, 
   которые выбираются во время выполнения программы.
2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
3. Поместите вариации алгоритма в собственные классы, которые реализуют этот интерфейс.
4. В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию, а также метод для её изменения. 
   Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.
5. Клиенты контекста должны подавать в него соответствующий объект-стратегию, когда хотят, чтобы контекст вёл себя
   определённым образом.

###Пример из жизни:

Вам нужно добраться до аэропорта. Можно доехать на автобусе, такси или велосипеде. Здесь вид транспорта является 
стратегией. Вы выбираете конкретную стратегию в зависимости от контекста — наличия денег или времени до отлёта.

###Преимущества и недостатки:

####Плюсы:

+ Горячая замена алгоритмов на лету.
+ Изолирует код и данные алгоритмов от остальных классов.
+ Уход от наследования к делегированию.
+ Реализует принцип открытости/закрытости.

####Минусы:

+ Усложняет программу за счёт дополнительных классов.
+ Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

[к оглавлению](#OOP)

## 49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.

**Синглтон** — это порождающий паттерн проектирования *(Порождающие паттерны отвечают за удобное и безопасное создание
новых объектов или даже целых семейств объектов.)*, который гарантирует, что у класса есть только один экземпляр, и 
предоставляет к нему глобальную точку доступа.

###Применимость:

**Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ 
к базе данных из разных частей программы).**

Синглтон скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт 
объект, либо отдаёт существующий объект, если он уже был создан.

**Когда вам хочется иметь больше контроля над глобальными переменными.**

В отличие от глобальных переменных, Синглтон гарантирует, что никакой другой код не заменит созданный экземпляр класса, 
поэтому вы всегда уверены в наличии лишь одного объекта-синглтон.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-синглтонов, поменяв 
код в одном месте (метод getInstance).

###Шаги реализации:

1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет использоваться для получения синглтона.
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод синглтона.
4. Сделайте конструктор класса приватным.
5. В клиентском коде замените вызовы конструктора синглтона вызовами его создающего метода

###Пример из жизни:

Правительство государства — хороший пример одиночки. В
государстве может быть только одно официальное правительство. Вне зависимости от того, кто конкретно заседает в
правительстве, оно имеет глобальную точку доступа «Правительство страны N».

###Преимущества и недостатки:

####Плюсы:

+ Гарантирует наличие единственного экземпляра класса.
+ Предоставляет к нему глобальную точку доступа.
+ Реализует отложенную инициализацию объекта-синглтона.

####Минусы:

+ Нарушает принцип единственной ответственности класса.
+ Маскирует плохой дизайн.
+ Проблемы мультипоточности.
+ Требует постоянного создания Mock-объектов при юниттестировании.

[к оглавлению](#OOP)

## 50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.

**Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в 
суперклассе, позволяя подклассам изменять тип создаваемых объектов.

###Применимость:

**Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.**

Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.

Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, 
вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

**Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.**

Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал 
объекты из этих новых классов, а не из стандартных?

Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти 
компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.

Например, вы используете готовый UI-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо 
стандартных прямоугольных. Вы создаёте класс `RoundButton`. Но как сказать главному классу фреймворка `UIFramework`, 
чтобы он теперь создавал круглые кнопки, вместо стандартных?

Для этого вы создаёте подкласс `UIWithRoundButtons` из базового класса фреймворка, переопределяете в нём метод создания 
кнопки (а-ля `createButton`) и вписываете туда создание своего класса кнопок. Затем используете`UIWithRoundButtons` 
вместо стандартного `UIFramework`.

**Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.**

Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, 
файловой системе и т. д.

Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:
1. Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
2. При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
3. А затем вернуть его клиентскому коду.
4. Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище. 

Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, 
конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

###Шаги реализации:

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий 
   интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами 
   фабричного метода, перенося в него код создания различных продуктов. В фабричный метод, возможно, придётся добавить 
   несколько параметров, контролирующих, какой из продуктов нужно создать. На этом этапе фабричный метод, скорее всего, 
   будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не
   волнуйтесь, мы вот-вот исправим это
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания 
   соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении 
   параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
   Например, у вас есть класс `Почта` с подклассами `АвиаПочта` и `НаземнаяПочта`, а также классы продуктов
   `Самолёт`, `Грузовик` и `Поезд`. `Авиа` соответствует `Самолётам`, но для `НаземнойПочты` есть сразу два продукта. 
   Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код
   может передавать в фабричный метод `НаземнойПочты` аргумент, контролирующий тип создаваемого продукта.
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — 
   не беда, это будет его реализацией по умолчанию.

###Пример из жизни:

Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все 
вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.

Простыми словами: Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам.

###Преимущества и недостатки:

####Плюсы:

+ Избавляет класс от привязки к конкретным классам продуктов.
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов в программу.
+ Реализует принцип открытости/закрытости

####Минусы:

+ Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой 
  подкласс создателя.

[к оглавлению](#OOP)

## 51. Объясните шаблон - абстрактная фабрика. Придумайте пример, не относящийся к технике

**Абстрактная фабрика** — это порождающий паттерн проектирования, который позволяет создавать семейства связанных 
объектов, не привязываясь к конкретным классам создаваемых объектов.

###Применимость:

**Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от 
конкретных классов продуктов.**

Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при 
этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее 
определён.

**Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.**

В хорошей программе каждый класс отвечает только за одну вещь. Если класс имеет слишком много фабричных методов, они 
способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию
классов, применив абстрактную фабрику.

###Шаги реализации:

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, 
   сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

###Пример из жизни:

Допустим, вы решили полностью взять под свой контроль рынок автомобилей. Как это сделать? Вы можете создать свою марку
автомобиля, своё производство, провести масштабную рекламную компанию и т.д. Но, в этом случае вам придётся сражаться с
такими гигантами авторынка, как Toyota или Ford. Не факт, что из данной борьбы вы выйдите победителем. Гораздо лучшим 
решением будет скупить заводы всех этих компаний, продолжить выпускать автомобили под их собственными марками, а прибыль
класть себе в карман. Если я не ошибаюсь, такая структура в экономике называется – холдинг. Вот этот холдинг и будет 
Абстрактной фабрикой или «фабрикой фабрик». В нашей программе Абстрактная фабрика (холдинг) будет представлена 
интерфейсом или абстрактным классом. Предприятия, входящие в холдинг, представлены классами, реализующими данный 
интерфейс.

###Преимущества и недостатки:

####Плюсы:

+ Гарантирует сочетаемость создаваемых продуктов.
+ Избавляет клиентский код от привязки к конкретным классам продуктов.
+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
+ Упрощает добавление новых продуктов в программу.
+ Реализует принцип открытости/закрытости.

####Минусы:

+ Усложняет код программы из-за введения множества дополнительных классов.
+ Требует наличия всех типов продуктов в каждой вариации

[к оглавлению](#OOP)

## 52. Что такое enum? Когда можно его применять?

**Enum** - это класс-перечисление. Перечисление - это набор констант, связанных между собой по смыслу. Константы здесь - 
это статические объекты, создающиеся в единственном экземпляре. Обычно перечисление используют для работы со значениями, 
которые никогда не меняются. Например, дни недели, времена года, карточные масти или даже записи полей шахматной доски. 
Перечисление можно использовать и для групп констант другого вида. Например, для перечисления в программе статусов работы 
в автосервисе ("Принят на сервис", "В работе", "Ожидание запчастей", "Готов" и т.д.). Такие статусы никогда не меняются 
и имеют логическую связь между собой.

Перечисление (enum) наследуется от java.lang.Enum, поэтому он не может наследовать другие классы. Перечисление может 
реализовывать интерфейсы (интерфейсы мы будем проходить в разделе Полиморфизм, пока что просто можно запомнить, что enum 
работает с интерфейсами). Перечисление может содержать поля, методы и конструкторы. Перечисление - это список 
неизменяемых готовых объектов, которыми можно пользоваться.

### Методы enum:

- `name()` - возвращает имя константы (значения) в том же виде, в каком оно объявлено.
- `ordinal()` - возвращает порядковый номер константы (значения), по которому её экземпляр находится в перечислении 
  (нумерация с нуля).
- `values()` - возвращает массив всех элементов перечисления.

[к оглавлению](#OOP)

## 53. Что такое record? Когда можно его применять?

**Record** дает возможность записать стандартную модель данных в виде одной строки, то есть с помощью record можно избавиться 
от шаблонного кода, который приходится писать в каждой модели данных. Появился с 14 версии.

**Record** - это неизменяемая модель данных, в которой:

- Поля, переданные в параметрах, являются `private` и `final` по умолчанию.
- Код имеет канонический конструктор, параметры которого - это все поля данного класса.
- Доступ к полям осуществляется через методы типа имя_поля(). Тот же геттер, только без слова `get` в имени метода. 
  Методов типа set класс record не имеет, так как все поля объявлены как `final`, поэтому **record** является неизменяемым.
- Определены методы `equals()` и `hashcode()`, включающие все поля класса.
- Определен шаблонный метод `toString()` для вывода полей класса на печать.

### Особенности:

- В record можно добавлять только статические переменные (как константы, так и обычные статические переменные)
- В record можно добавлять свои методы, как нестатические, так и статические.
- **Record** является `final`, поэтому наследование этого класса невозможно. Сам **record** наследовать другие классы не 
  может, так он унаследован от `java.lang.Record`. Но **record** может реализовывать интерфейсы

### Конструкторы:

- По умолчанию **record** имеет канонический конструктор - это конструктор, принимающий все поля класса в качестве параметров. 
  Такой же конструктор неявно создается в **record** по умолчанию. Если его явно объявить в **record**, то будет использоваться 
  объявленный конструктор вместо канонического. Конструктор по умолчанию при объявлении явного канонического конструктора 
  создан не будет.
- Если нам нужен конструктор с какой-то логикой помимо обычной инициализации полей, можно создать компактный конструктор.
  Данный конструктор называется компактным, так как в нем поля не инициализируются явным образом. Инициализация проходит 
  неявно перед выполнением команд, находящихся внутри конструктора. Данная инициализация автоматически будет проходить в 
  любом переопределенном конструкторе. Это гарантирует, что все поля будут инициализированы. Если в **record** уже 
  объявлен компактный конструктор, то явно объявить еще и канонический конструктор в этом классе невозможно, так как при 
  объявлении компактного конструктора автоматически создается конструктор по умолчанию, чтобы провести инициализацию всех 
  полей перед выполнением команд компактного конструктора, следовательно нельзя еще раз объявить в классе такой же 
  конструктор с теми же параметрами.

[к оглавлению](#OOP)

## 54. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

### String

**String** - это неизменяемый класс. После создания объект этого класса изменить нельзя. Строка - это неизменяемая
последовательность символов. При любых операциях изменения строки типа String будет создан новый объект String с
результирующим содержимым.

### StringBuilder

**StringBuilder** - это класс, являющийся изменяемой последовательностью символов. Он дает возможность создать объект 
класса StringBuilder, и добавлять в него другие строки без создания новых объектов. (Объекты мы будем изучать дальше в 
блоке ООП, пока что можно рассматривать слово "объект" просто как элемент, который содержит наши данные, и инструкции, 
чтобы с этими данными работать).

### StringBuffer

Строки являются неизменными, поэтому частая их модификация приводит к созданию новых объектов, что в свою очередь 
расходует драгоценную память. Для решения этой проблемы был создан класс `java.lang.StringBuffer`, который позволяет более 
эффективно работать над модификацией строки. Класс является mutable, то есть изменяемым — используйте его, если Вы хотите 
изменять содержимое строки. StringBuffer может быть использован в многопоточных средах, так как все необходимые методы 
являются синхронизированными.

### StringJoiner

В Java есть удобный класс для составления строк - StringJoiner. StringJoiner базируется на StringBuilder и имеет удобную 
возможность соединять строки через разделитель, а также добавлять префикс и/или суффикс к результирующей строке.

[к оглавлению](#OOP)

## 55. Чем отличаются StringBuffer и StringBuilder?

**StringBuilder** — класс, что представляет изменяемую последовательность символов. Класс был введен в Java 5 и имеет 
полностью идентичный API с `StringBuffer`. Единственное отличие — `StringBuilder` не синхронизирован. Это означает, что его
использование в многопоточных средах есть нежелательным. Следовательно, если вы работаете с многопоточностью, Вам 
идеально подходит `StringBuffer`, иначе используйте `StringBuilder`, который работает намного быстрее в большинстве реализаций.

[к оглавлению](#OOP)

## 56. Каким образом производится экранирование символов и зачем это нужно?

Java проблему невозможности вывести символ в тексте непосредственно(как есть) решает экранирование символов. Выглядят 
экранированные символы как наш исходный символ, перед которым стоит обратный слэш "\".

[к оглавлению](#OOP)

## 57. Что такое управляющие последовательности?

Комбинация в виде обратного слэша и экранируемого им символа называется управляющей последовательностью 
(escape-последовательность). В таком же виде выводятся и спецсимволы, например, `\n` - переход на новую строку.

В Java существует 8 видов управляющих последовательностей:

1) `\'` - Добавляет одинарную кавычку
2) `\"` - Добавляет двойную кавычку
3) `\\` - Добавляет обратный слэш
4) `\r` - Возврат курсора в начало строки
5) `\n` - Перевод курсора на новую строку
6) `\f` - Прогон страницы
7) `\t` - Табуляция
8) `\b` - Возврат курсора на одну позицию назад

[к оглавлению](#OOP)

## 58. Зачем нужно форматирование данных? Метод format()

За создание форматированного текстового вывода отвечает класс `java.util.Formatter`. Метод `format()` этого класса позволяет 
выводить различные данные - строки, числа, даты, время в желаемом виде, т.е. преобразует данные в тот формат, который нам нужен.
Метод format() класса Formatter получает данные и преобразует их в определенный строковый формат. Отформатированные 
данные возвращаются в виде объекта типа Formatter, который выводится в строковом представлении в методе format() класса String.

[к оглавлению](#OOP)

## 59. Что такое varargs? В каких случаях стоит его применять?

**Varargs** (variable arguments) - аргументы переменной длины. Varargs упрощает создание методов, принимающих 
произвольное количество аргументов, облегчая написание кода и его читабельность. Метод, принимающий произвольное 
количество аргументов называется методом с аргументами произвольной длины. Методы с аргументами произвольной длины можно 
использовать, когда в метод могут передаваться, например, не все запланированные параметры или если в метод планируется 
передавать не только разное количество аргументов, но и аргументы разного типа.

В Java 5 появился удобный механизм **varargs**, позволяющий быстро и просто обрабатывать аргументы произвольной длины. 
Аргументы переменной длины объявляются в коде в виде троеточия "..." между типом данных и именем.

```java
public static String text(String... strings) {
```

Данная запись подразумевает 0 и более аргументов. Аргумент strings неявно будет преобразован в массив строк. Указать 
varargs можно только как параметр какого-либо метода. Все аргументы неявно помещаются в массив и передаются в метод. 
Если аргументов нет, то длина массива будет равна 0. Методы с аргументами произвольной длины можно перегружать.

[к оглавлению](#OOP)

## 60. В каких случаях может возникнуть неоднозначность при работе с varargs?

**Неоднозначность** - это двусмысленность кода, когда компилятор не может понять, какой из существующих вариантов ему нужно 
выбрать. Неоднозначность возникает при перегрузке методов и приводит к ошибке компиляции.

Неоднозначность возникнет, если мы перегрузим метод text() таким образом:

```java
    public static String text(String... strings) {
        StringBuilder builder = new StringBuilder();
        for (String string : strings) {
            builder.append(string);
        }
        return builder.toString();
    }

    public static String text(String name, String... strings) {
        StringBuilder builder = new StringBuilder();
        builder.append(name);
        for (String string : strings) {
            builder.append(string);
        }
        return builder.toString();
    }
```

Здесь в случае передачи в метод только одного аргумента типа String компилятор не поймёт какой из этих перегруженных 
методов ему использовать, так как оба варианта будут подходящими.

Другой вариант, когда может возникнуть неоднозначность, это перегрузка аргументов переменной длины разными типами:

```java
    public static String text(String... strings) {
        StringBuilder builder = new StringBuilder();
        for (String string : strings) {
            builder.append(string);
        }
        return builder.toString();
    }

    public static String text(int... numbers) {
        StringBuilder builder = new StringBuilder();
        for (int number : numbers) {
            builder.append(number);
        }
        return builder.toString();
    }
```

Неоднозначность можно разрешить путём отказа от перегрузки и объявления такого же метода, но с другим именем. В целом 
появление проблемы неоднозначности может говорить о неидеальном решении поставленной задачи.

Хоть varargs и является хорошим инструментом для облегчения чтения и написания кода, лучше применять его тогда, когда 
выгода от него явно очевидна, чтобы уменьшить риск столкнуться с неоднозначностью и вопросом понимания какой из 
перегруженных методов вызывается.

[к оглавлению](#OOP)

## 61. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?

В версии 5.0 в Java были добавлены гибкие и мощные средства форматирования в виде класса Formatter из пакета java.util.
Методы format() специально определены в классе String и еще, например, в классах PrintStream и PrintWriter, т.е. в классах,
которые работают с выводом строк, чтобы не нужно было отдельно работать с классом Formatter - это удобно и получается меньше
кода. А в классах PrintStream и PrintWriter определён еще и метод printf(), который результат форматирования сразу выводит
в консоль аналогично методам print() или println().

Метод format() выполняет форматирование и возвращает новую строку. Её можно сохранить и использовать в дальнейшем.
Метод printf() выполняет форматирование и выводит данные в консоль без сохранения. Для более глубокого понимания
процесса в этом уроке вывод делается через цепочку методов (println + format). Все эти методы можно переписать с помощью
printf() и получить такой же результат за исключением отсутствия у метода printf() перевода курсора на новую строку.

Форматирование производится по шаблону - в метод format() передаётся строка с указанными местами для подстановки
аргументов, а также сами значения, которые необходимо вставить.

На простейшем уровне форматирование состоит из двух главных частей:
1. Инструкции форматирования
2. Аргумент или аргументы, которые будут форматироваться. Тип аргумента не произвольный - он должен быть совместим со
   спецификаторами в инструкциях форматирования.

Знак процента в инструкции, это как некоторая переменная, которая представляет второй (третий, четвертый и т.д.)
аргумент метода. Все, что находится между знаком процента и индикатором типа включительно - это спецификатор
форматирования.

### Спецификаторы

`%s` - Данный спецификатор хоть и можно применить к любому типу, но вывод некоторых типов может быть не тем, который мы
хотим получить, так как `%s` выводит строковое представление аргумента, а наша цель - получить вывод данных именно в том
формате, который мы хотим. Поэтому под каждый тип данных лучше указывать спецификатор именно того типа, который нужно получить.

+ `%a` - Шестнадцатеричное число с плавающей точкой
+ `%b` - Булево значение
+ `%c` - Символ
+ `%d` - Десятичное целое
+ `%e` - Число в научной записи
+ `%f` - Десятичное число с плавающей точкой
+ `%h` - Хеш-код от аргумента
+ `%o` - Восьмеричное целое
+ `%n` - Символ переноса строки
+ `%t` - Время
+ `%x` - Шестнадцатеричное целое

### Специальные настройки

С помощью них можно указывать позицию аргумента в списке, устанавливать специальные флаги, минимальное количество
выводимых символов и ограничение количества символов.

Спецификатор форматирования может содержать до пяти разных частей. Порядок следования важен. Формат -
`%[номер аргумента][флаги][ширина][.разрядность]тип`. Тип обязателен, всё остальное опционально.

Данная запись называется инструкцией.

- С помощью номера аргумента можно указать позицию в списке аргументов (в виде целого числа). Например, на первый
  аргумент можно сослаться в виде 1$, а на четвертый - 4$. Если это явно не указано, то все аргументы должны быть
  переданы в метод в порядке объявления в шаблоне ссылок на них.
- Флаги - это отдельные символы для изменения результата форматирования. Например, флаг "+" добавит знак "+" к
  получившемуся результату, а флаг "," выведет результат с разделителем между разрядами (запятая или пробел, зависит от
  локализации).
- Ширина определяет количество выводимых символов. Задаётся целым положительным числом. Если перед ним поставить 0, то
  если общее количество символов строки вывода будет менее этого значения, разница будет заполнена нулями.
- Разрядность. Через указание точки и целого числа можно задать выводимое после точки количество
  символов.

[к оглавлению](#OOP)

## 62. Для чего используется конструктор в абстрактном классе

Для инициализации начальных значений общих переменных, объявленных в абстрактном классе и используемых различными реализациями.

[к оглавлению](#OOP)

## 63. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?

При создании анонимного класса в скобках можно передать аргументы для недефолтного конструктора.

[к оглавлению](#OOP)

## 64. Что такое композиция?

**Ассоциация** - это отношение, при котором объекты одного типа определенным образом связаны с объектами другого типа.
Так объект одного типа может содержать или использовать объект другого типа.

Например, когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет».
Автомобиль имеет двигатель.

Выделяют два частных случая ассоциации: композицию и агрегацию.

**Композиция** - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть
контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.

Например, когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью
управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.
```java
class Engine {
    
    int power;
    
    public Engine(int p) {
        power = p;
    }
}

class Car {
    
    string model = "Audi"; 
    Engine engine;
    
    public Car() {
        this.engine = new Engine(360);
    }
}
```

[к оглавлению](#OOP)

## 65. Что такое агрегация?

**Агрегация** - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку
на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Например, когда экземпляр двигателя создается где-то в другом месте кода,
и передается в конструктор автомобиля в качестве параметра.
```java
class Engine {
    int power;
    
    public Engine(int p) {
       power = p;
    }
}        

class Car {  
    string model = "Audi";
    Engine engine;
    
    public Car(Engine someEngine) {
         this.engine = someEngine;
    }
}

Engine goodEngine = new Engine(360);
Car audi = new Car(goodEngine);
```

[к оглавлению](#OOP)

## 66. Как обрабатываются исключительные ситуации?

В Java есть пять ключевых слов для работы с исключениями:

+ `try` — используется для отметки начала блока кода, который потенциально может привести к ошибке.

+ `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
  Последовательность блоков catch должна идти от частного к более общему. В противном случае будет ошибка компиляции.

+ `finally` — ключевое слово для отметки начала блока кода, которой является дополнительным.
  Этот блок помещается после последнего блока `catch`. Управление обычно передаётся в блок `finally` в любом случае.

+ `throw` — служит для генерации исключений.

+ `throws` — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее,
  что метод потенциально может выбросить исключение с указанным типом.

Общий вид конструкции для «поимки» исключительной ситуации выглядит следующим образом:

Для обработки исключений используется конструкция `try-catch-finally` и c 7й Java `try-with-resources`.

**`try-catch-finally`**:
```java
try { 
    //здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //здесь описываются действия, направленные на обработку исключений 
} 
finally { 
    //выполняется в любом случае (блок finally  не обязателен) 
}
```
Пример 1.
```java
try{ 
    fis = new FileInputStream(fileName); 
} catch (Exception ex) {    
    //... 
} catch (IOException e) { 
    //... 
} 
```
Пример 2. Начиная с Java 7 можно переотлавливать несколько исключений одни блоком catch.
```java
try {  
    //... 
} catch( IOException | SQLException ex ) {  
    logger.log(ex); 
    throw ex; 
} 
```

**`try-with-resources`**:
```java
try(открываем файл и т.п. здесь) {
    //здесь код, который потенциально может привести к ошибке 
}
//после блока файл закроется автоматически.
```

Пример 1.
```java
BufferedReader br = new BufferedReader(new FileReader(path));
   try {
        return br.readLine();
   } finally {
        if (br != null) {
            br.close();
        }
   }
```
Пример 2. Java 7
```java
try (BufferedReader br = new BufferedReader(new FileReader(path)) ) {
    return br.readLine();
}
```

[к оглавлению](#OOP)