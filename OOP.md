## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс?](#3-Укажите-из-каких-элементов-состоит-класс)

[4. Что такое конструктор?](#4-Что-такое-конструктор)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое нестатический метод?](#8-Что-такое-нестатический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовым родительным классом для всех классов?](#10-Какой-класс-является-базовым-родительным-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни.](#11-Что-такое-наследование-приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта?](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительного класса?](#13-Как-вызвать-метод-из-родительного-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопрделение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое виртуальная функция и используются ли они в Java?](#16-Что-такое-виртуальная-функция-и-используются-ли-они-в-java)

[17. Что такое перегрузка метода?](#17-Что-такое-перегрузка-метода)

[18. Можно ли изменить тип возвращаемых данных при перегрузке метода?](#18-Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)

[19. Что такое множественное наследование? Как его можно реализовать в Java?](#19-Что-такое-можественное-наследование-как-его-можно-реализовать-в-java)

[20. Что такое полиформизм? Приведите примеры из реальной жизни](#20-Что-такое-полиморфизм-приведите-примеры-из-реальной-жизни)

[21. Что такое инкапсуляция?](#21-Что-такое-инкапсуляция)

[22. Как реализована инкапсуляция в Java?](#22-Как-реализована-инкапсуляция-в-java)

[23. Что такое абстракция?](#23-Что-такое-абстракция)

[24. Как реализована абстрация в Java?](#24-Как-реализована-абстракция-в-java)

[25. Можно ли применить модификаторы доступа к конструкторам?](#25-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[26. Что такое интерфейс?](#26-Что-такое-интерфейс)

[27. Что такое внутренний класс? Типы внутренних классов?](#27-Что-такое-внутренний-класс-типы-внутренних-классов)

[28. Что такое анонимный класс?](#28-Что-такое-анонимный-класс)

[29. Для чего используется конструктор в абстрактном классе?](#29-Для-чего-используется-конструктор-в-абстрактном-классе)

[30. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?](#30-Можно-ли-создать-анонимный-класс-если-в-классе-нет-конструктора-по-умолчанию)

[31. Что такое композиция?](#31-Что-такое-композиция)

[32. Что такое агрегация?](#32-Что-такое-агрегация)

[33. Какие типы исключительных ситуаций бывают?](#33-Какие-типы-исключительных-ситуаций-бывают)

[34. Как обрабатываются исключительные ситуации?](#34-Как-обрабатываются-исключительные-ситуации)

[35. Назовите основные методы класса Object?](#35-Назовите-основные-методы-класса-object)

[36. Что такое шаблоны проектирования?](#36-Что-такое-шаблоны-проектирования)

[37. Объясните шаблон "декоратор".](#37-Объясните-шаблон-декоратор)

[38. Объясните шаблон "стратегия".](#38-Объясните-шаблон-стратегия)

## 1. Что такое ООП?

Объектно-ориентированное программирование - методология программирования, основанная на представлении программы в виде 
совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию 
наследования. Сегодня ООП - самая распространенная методология программирования. Мир, в котором мы живем, состоит из 
объектов. Если мы посмотрим вокруг, то увидим, что нас окружают дома, деревья, автомобили, мебель, посуда, компьютеры. 
Все эти предметы являются объектами, и каждый из них обладает набором определенных характеристик, поведением и 
назначением. Мы привыкли к объектам, и мы их используем всегда для вполне конкретных целей. Например, если нам 
необходимо доехать до работы, мы пользуемся автомобилем, если захотим поесть - посудой, а если отдохнуть - нам 
понадобится удобный диван. Человек привык мыслить объектно для решения задач в повседневной жизни. Это послужило одной 
из причин использования объектов в программировании, а такой подход к созданию программ назвали объекто-ориентированным.

[Принципы ООП](https://javarush.ru/groups/posts/principy-oop)

[к оглавлению](#OOP)

## 2. Базовые концепции ООП?

4 главные особенности, которые вместе образуют парадигму объектно-ориентированного программирования.

+ **Наследование** - механизм, который позволяет описать новый класс на основе существующего (родительского). Поля и 
  методы, описанные в родительских классах, можно использовать в классах-потомках. При этом механизм наследования очень 
  гибкий, и недостающую в потомках функциональность можно дописать отдельно.

+ **Абстракция** - Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот - 
  отбрасывание второстепенных, незначительных.
  
+ **Инкапсуляция** - Ещё один базовый принцип ООП, при котором атрибуты и поведение объекта объединяются в одном классе, 
  внутренняя реализация объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс. 
  Задача программиста - определить, какие атрибуты и методы будут доступны для открытого доступа, а какие являются 
  внутренней реализацией объекта и должны быть недоступны для изменений. Инкапсуляция в Java означает ограничение 
  доступа к данным и возможностям их изменения.
  
+ **Полиморфизм** - это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение 
  объектов будет разным в зависимости от типа, к которому они принадлежат.

[к оглавлению](#OOP)

## 3. Укажите из каких элементов состоит класс?

Класс определяется с помощью ключевого слова `class`. После названия класса идут фигурные скобки, между которыми 
помещается тело класса - то есть его поля и методы. Шаблоном или описанием объекта является класс, а объект представляет
экземпляр этого класса. Любой объект может обладать двумя основными характеристиками: состояния - некоторые данные, 
которые хранит объект, и поведение - действия, которые может совершать объект. Для хранения состояния объекта в классе 
применяются поля. Для определения поведения объекта в классе применяются методы.

[к оглавлению](#OOP)

## 4. Что такое конструктор?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с
операцией `new`).

Конструктор нужен для автоматической инициализации переменных, т.е. он инициализирует объект непосредственно во время 
создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без
возвращаемого значения `void`.

Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без 
параметров.

[к оглавлению](#OOP)

## 5. Можно ли наследовать конструктор?

В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. Конструкторы не являются членами, 
поэтому они не наследуются.

Конструктор суперкласса может быть вызван из подкласса. С помощью ключевого слова `super` конструктору родителю можно 
передать аргументы. Даже больше того, если у конструктора суперкласса есть конструктор с параметрами и нет конструктора 
без параметров, то мы обязаны вызвать конструктор суперкласса с параметрами в начале конструктора дочернего класса.

[к оглавлению](#OOP)

## 6. Что такое перегрузка конструктора?

Перегрузка конструктора заключается в том, что мы можем объявить несколько конструкторов в одном классе. Однако с точки 
зрения синтаксиса языка, в некотором локальном пространстве не может быть двух одинаковых имен. В данном случае 
допускается объявление нескольких конструкторов, однако они должны отличаться набором параметров. Когда мы вызываем 
перегруженный конструктор, то из нескольких объявленных конструкторов, компилятор автоматически определяет нужный 
конструктор по его параметрам, которые указываются при вызове.

Если кратко, то - перегрузка конструктора позволяет установить различные способы начальной инициализации объектов класса.

Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то его нужно 
создать явно.

[к оглавлению](#OOP)

## 7. Что такое статический метод?

**Статический метод** - это метод, который можно вызвать без создания объекта, напрямую через имя класса. Статические 
методы отличаются от обычных тем, что они привязаны к классу, а не к объекту. 

Важно:

+ Статичекий метод нельзя переопределять. Он "один" для класса и его наследников.
+ Статические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего
  метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом".
+ В отличие от локальных переменных статические поля и методы не потокобезопасны в Java.

[к оглавлению](#OOP)

## 8. Что такое нестатический метод?

**Нестатический метод** - это метод, который принадлежит экземпляру класса, т.е. он принадлежит объекту класса и может 
быть вызван с помощью ссылки на данный объект.

[к оглавлению](#OOP)

## 9. Для чего используется ключевое слово this?

`this` - это неявный первый параметр любого нестатического метода класса.
У какого объекта вызывается метод, тот и будет передан в качестве параметра `this`.

соответственно, `this` используется:

1. в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса.
   Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.
```java
class Student {
    int age;
    Student (int age) {
        this.age = age;
    }
}
```
2. когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризированном).
   Вызов `this()` может находиться только в первой строке конструктора.
```java
public class Toy {
    String name;
    int cost;
    String manufacturer;
    int age;

    public Toy(String name, int cost, String manufacturer, int age) {
        this(name, cost, manufacturer);
        this.age = age;
        System.out.println("В конструкторе с четырьмя параметрами");
    }

    public Toy(String name, int cost, String manufacturer) {
        this();
        this.name = name;
        this.cost = cost;
        this.manufacturer = manufacturer;
        System.out.println("В конструкторе с тремя параметрами");
    }

    public Toy() {
        System.out.println("В конструкторе по умолчанию");
    }
}
public class ToyDemo {
    public static void main(String[] args) {
        Toy toy = new Toy("Кукла", 34, "Disney", 3);
    }
}
```
вывод:
```
В конструкторе по умолчанию
В конструкторе с тремя параметрами
В конструкторе с четырьмя параметрами
```

[к оглавлению](#OOP)

## 10. Какой класс является базовым родительным классом для всех классов?

`Object` является базовым суперклассом для всех остальных классов Java.

Все непримитивный типы, включая массивы, наследуют прямо или косвенно от него. Поэтому ссылочная переменная класса 
`Object` может ссылаться на объект любого другого класса.

[к оглавлению](#OOP)

## 11. Что такое наследование? Приведите примеры из реальной жизни.

Представим, что у нас есть класс Dog. Что есть у каждой собаки? Четыре лапы, один хвост - и ещё они умеют гавкать и 
вилять хвостом. А теперь представим, что мы хотим создать классы для разных пород - овчарок, бульдогов и такс. У всех 
этих пород тоже будут четыре лапы и хвост, они тоже будут гавкать и вилять хвостом. Конечно, мы можем просто брать и 
копировать эти методы и переменные в каждый класс. Но зачем? Мы можем использовать наследование. Если мы сделаем все 
классы пород наследниками класса Dog, они будут иметь доступ ко всем его методам и переменным автоматически.

[к оглавлению](#OOP)

## 12. Опишите процесс создания нового объекта?

Объект создается с помощью ключевого слова `new`, которое вызывает конструктор класса, который инициализирует начальное
состояние объекта.

1. Сначала для хранения объекта выделяется память.
2. Далее Java-машина создает ссылку на этот объект.
3. В завершение происходит инициализация переменных и вызов конструктора.

Подробнее рассмотрим третий пункт:
1. Сначала идет инициализация статических переменных класса-предка.
2. После, идет инициализация статических переменных класса-потомка.
3. Инициализация переменных продолжается. Третьими по счету будут инициализированы нестатические переменные класса-предка.
4. Наконец, дело дошло до конструкторов. Точнее, до конструктора базового класса.
5. Теперь пришла очередь инициализации нестатических полей класса-потомка.
6. И наконец вызывается конструктор дочернего класса.

[к оглавлению](#OOP)

## 13. Как вызвать метод из родительного класса?

Если родительский метод был переопределен в своем дочернем объекте, дочерние объекты всегда будут использовать 
переопределенную версию. Но всегда можно использовать ключевое слово `super` для вызова родительского метода.

[к оглавлению](#OOP)

## 14. Что такое переопределение метода?

**Переопределение метода** - это одна из возможностей языка программирования, позволяющая дочернему классу обеспечивать
специфическую реализацию метода, уже реализованного в одном из родительских классов.

Также есть возможность уведомить компилятор о том, что мы именно переопределяем метод с помощью аннотации `@Override`. 
Проставленная над методом аннотация сообщает компилятору (да и читающим твой код программиста тоже): "Все ок, это не 
ошибка и не моя забывчивость. Я помню, что такой метод уже есть, и хочу переопределить его".

Также у переопределения есть ряд ограничений:
1. У переопределенного метода должны быть те же аргументы, что и у метода родителя.
2. У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
3. Модификатор доступа у переопределенного метода также не может отличаться от "оригинального".

[к оглавлению](#OOP)

## 15. Можно ли переопределить статический метод?

Нет, статические методы не могут быть переопределены, поскольку они являются частью класса, а не объекта.

[к оглавлению](#OOP)

## 16. Что такое виртуальная функция и используются ли они в Java?

В Java виртуальная функция означает функцию, которая может быть переопределена в своих подклассах. Таким образом, все 
нестатические методы Java являются виртуальной функцией.

[к оглавлению](#OOP)

## 17. Что такое перегрузка метода?

**Перегрузка методов** — это приём программирования, который позволяет разработчику в одном классе для методов с разными 
параметрами использовать одно и то же имя. В этом случае мы говорим, что метод перегружен.

При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые
указываются при вызове.

[к оглавлению](#OOP)

## 18. Можно ли изменить тип возвращаемых данных при перегрузке метода?

Для того чтобы перегрузить метод, достаточно объявить его новый вариант, отличающийся от уже существующих. Нужно лишь 
соблюсти одно условие: набор параметров в каждом из перегружаемых методов должны быть разными. Одного лишь различия в 
типах возвращаемых значений для этой цели недостаточно. Перегружаемые методы могут иметь разные возвращаемые типы, но 
при вызове метода выполняется лишь тот его вариант, в котором параметры соответствуют передаваемым аргументам. Тип 
возвращаемого значения не учитывается при перегрузке методов.

[к оглавлению](#OOP)

## 19. Что такое множественное наследование? Как его можно реализовать в Java?

**Множественное наследование** - способность создавать классы с множеством классов-родителей. В отличии от других 
популярных объектно-ориентированных языков, вроде C++, язык Java не поддерживает множественное наследование классов.

В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы. 

Возникает неоднозначность: если метод класса D вызывает метод класса А (и этот метод не переопределён в классе D),
а классы B и C по своему переопределили этот метод, то от какого класса его наследовать? от B или C?

В Java множественное наследование поддерживают интерфейсы.

Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией.
Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые
обращаются к нужным методам этих объектов. И наследоваться от этого класса.

[к оглавлению](#OOP)

## 20. Что такое полиформизм? Приведите примеры из реальной жизни

Полиморфизм описывают выражением: *Один интерфейс - множество реализаций.*

**Полиморфизм** - это возможность работать с несколькими типами, как будьто это один и тот же тип,
в то же время поведение каждого типа будет уникальным в зависимости от его реализации.

**Примеры:**
+ Пульт управления один для разных моделей.
+ Монетоприемник в каком-нибудь продающем автомате.
+ Цоколь лампочки - это переменная определенного базового типа. Лампочка - созданный объект конкретного класса.
  Лампочки разные - цоколь один.
  
[к оглавлению](#OOP)

## 21. Что такое инкапсуляция?

**Инкапсуляция** - это сокрытие реализации и отделение его внутреннего представления от внешнего.

Т.е. это скрытие полей объектов, ограничение доступа к определенным методам и полям.

[к оглавлению](#OOP)

## 22. Как реализована инкапсуляция в Java?

Изначальное значение слова «инкапсуляция» в программировании — объединение данных и методов работы с этими данными в 
одной упаковке («капсуле»). В Java в роли упаковки-капсулы выступает класс. Класс содержит в себе и данные (поля 
класса), и методы для работы с этими данными.

[к оглавлению](#OOP)

## 23. Что такое абстракция?

Абстракция - это выделение значимой информации и исключение из рассмотрения незначимой.

С помощью принципа абстракции программа разбивается на объекты.
Информация в программе обрабатывается в виде цепочки действий между отдельными объектами.

Главное достоинство абстракции связано с тем, что она позволяет отделить реализацию объектов от их описания.

**Пример:** описание узлов в автомобиле. Здесь название узла значимая информация,
а описание обязанностей у каждого узала это второстепенная информация.
Наример, главной характеристикой для трансмиссии будет то, что этот узел передает крутящий момент от двигателя колесам,
а как именно (механика, автомат, робот) это уже второстепенная информация (это вопрос конкретной реализации).

[к оглавлению](#OOP)

## 24. Как реализована абстракция в Java?

С помощью абстрактных классов и интерфейсов.

Абстрактные классы позволяют описать общее поведение и задать особенное поведение для классов наследников.

+ поля - содержат состояние объекта;
+ конструктор - инициализирует начальное состояние объекта;
+ абстрактные методы - не содержат реализации, а декларируют, что данный метод будет иметь реализацию в наследуемом классе;
+ методы - позволяют выполнять действия над объектом.
```java
public abstract class BaseAction {
    private final int key;
    private final String name;
    
    protected BaseAction(final int key, final String name) {
        this.key = key;
        this.name = name;
    }
    
    public abstract void execute(Input input, Tracker tracker);
    
    public String info() {
        return String.format("%s:%s", this.key, this.name);
    }
}
```

применение:
```java
public class AddItem extends BaseAction {
    public AddItem(int key, String name) {
        super(key, name);
    }
    
    @override
    public abstract void execute(Input input, Tracker tracker) {
        String name = input.ask("Enter name:");
        String desc = input.ask("Enter descriotion:");
        tracker.add(new Item(name, desc));
    }
}
```

+ Чтобы создать абстрактный класс нужно использовать ключевое слово `abstract` перед именем класса.
+ Нельзя создать объект абстрактного класса.
+ В таком классе могут быть абстрактные методы, которые обязан реализовать дочерний класс.
  Абстрактные методы могут быть только в абстрактном классе.
+ В абстрактном классе можно создавать обычные методы.
  Они наследуются также, как и для неабстрактных классов.

[к оглавлению](#OOP)

## 25. Можно ли применить модификаторы доступа к конструкторам?

В конструкторе допускается применение модификаторов доступа. Пример применение модификатора доступа к конструкторам - 
паттерн проектирования "Singleton". К конструктору применяется модификатор доступа `private`, что не дает возможности 
создать объект класса "Singleton" вне этого класса.

[к оглавлению](#OOP)

## 26. Что такое интерфейс?

Интерфейсы задают описание, как должен работать объект. Интерфейсы не содержат реализации.

+ поля - константы `public static final`;
+ абстрактные методы - задают то, как должен работать наш объект, но не определяют как конкретно;
+ статические методы - можем добавлять с Java 8 как обычные `static` методы.
```java
public interface Input {
    
    String LOG = "LOG";
    
    String ask(String question);
   
}
```

Это тип данных, который может содержать лишь константы (статические поля), абстрактные методы, а также начиная
с Java 8 неабстрактные методы `default` и `static`.

Также с Java 8 появилась возможность реализовывать методы с дефолтной реализацией, но опять же без конкретного состояния.
Используется для обращения к абстрактному методу и получению из него информации о конкретной реализации.
```java
public interface Figure {
    Cell position;
    
    Cell[] way(Cell source, Cell dest); 
    
    //можем обратиться к абстрактному методу way и из него получить данные о конкретном состоянии
    default String icon() {
        return String.format(
        "%s.png", this.getClass().getSimpleName()
        );
    }
    
    Figure copy(Cell dest);
}
```

У интерфейсов нет конструкторов.

Инерфейс позволяет создавать общий тип данных для разных объектов, т.е. использование интерфейса гарантирует
наличие определенного метода у объекта.

При реализации интерфейса класс реализовать все его методы, иначе он должен быть помечен как `abstract`.

Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.

**Абстрактный класс vs интерфейс**

1. Абстрактный класс содержит состояние объекта, что в интерфейсе невозможно,
   т.к. поля там являются константами

2. Наследовать `extends` можно только один абстрактный класс, а реализовать `implements` интерфейсов сколько угодно.
   Интерфейс может наследовать другой интерфейс.

3. В интерфейсах нет конструкторов.

Замечание:

Абстрактные классы используются, когда есть отношение `is-a`, т.е. класс наследник расширяет базовый абстрактный класс.
Интерфейс же могут быть реализованы разными классами, вовсе не связанными друг с другом.

Поэтому код, написанный на интерфейсах более масштабируем и его легче поддерживать.
При использовании абстрактных классов, а это всегда наследование, мы связываем наш код.

[к оглавлению](#OOP)

## 27. Что такое внутренний класс? Типы внутренних классов?

**Вложенный класс** - это класс, который находится внутри класса или интерфейса.

+ **Статические**, пример StaticInnerClass:
```java
public class OuterClass { 
    //определены внутри класса
    public static class StaticInnerClass{ 
    } 
} 

//создание экземпляра класса 
OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();
```

+ **Нестатические** вложенные в другой класс - это **внутренние классы**.

  + внутренние классы-члены, пример InnerClass:
    ```java
    public class OuterClass { 
         //определены внутри класса
        public class InnerClass{ } 
    } 
    
    //создание экземпляра класса 
    OuterClass outerClass = new OuterClass(); 
    OuterClass.InnerClass innerClass = outerClass.new InnerClass();
    ```

  + локальные классы, пример LocalClass:
    ```java
    public class OuterClass { 
        
        public void someMethod() { 
            
            //определены внутри метода или блока кода
            class LocalClass{}  
        }       
    }
    ```

  + анонимные классы, пример:
    ```java
    public class OuterClass { 
        
        public void someMethod() { 
            
            Callable callable = new Callable() { 
                @Override 
                public Object call() throws Exception { 
                    return null; 
                } 
            };            
        }         
    }
    ``` 

[Nested Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)    
[Внутренние и вложенные классы java](https://habr.com/ru/post/439648/)

[к оглавлению](#OOP)

## 28. Что такое анонимный класс?

**Анонимный класс** - это класс, который сразу создается и реализуется (без имени класса) от суперкласса или интерфейса.

[к оглавлению](#OOP)

## 29. Для чего используется конструктор в абстрактном классе

Для инициализации начальных значений общих переменных, объявленных в абстрактном классе и используемых различными реализациями.

[к оглавлению](#OOP)

## 30. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?

При создании анонимного класса в скобках можно передать аргументы для недефолтового конструктора.

[к оглавлению](#OOP)

## 31. Что такое композиция?

**Ассоциация** - это отношение, при котором объекты одного типа определенным образом связаны с объектами другого типа.
Так объект одного типа может содержать или использовать объект другого типа.

Например, когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет».
Автомобиль имеет двигатель.

Выделяют два частных случая ассоциации: композицию и агрегацию.

**Композиция** - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть
контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.

Например, когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью
управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.
```java
class Engine {
    
    int power;
    
    public Engine(int p) {
        power = p;
    }
}

class Car {
    
    string model = "Audi"; 
    Engine engine;
    
    public Car() {
        this.engine = new Engine(360);
    }
}
```

[к оглавлению](#OOP)

## 32. Что такое агрегация?

**Агрегация** - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку
на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Например, когда экземпляр двигателя создается где-то в другом месте кода,
и передается в конструктор автомобиля в качестве параметра.
```java
class Engine {
    int power;
    
    public Engine(int p) {
       power = p;
    }
}        

class Car {  
    string model = "Audi";
    Engine engine;
    
    public Car(Engine someEngine) {
         this.engine = someEngine;
    }
}

Engine goodEngine = new Engine(360);
Car audi = new Car(goodEngine);
```

[к оглавлению](#OOP)

## 33. Какие типы исключительных ситуаций бывают?

Все исключения делятся на 2 вида - проверяемые "checked" и непроверяемые "unchecked". 

Все проверяемые исключения происходят от класса `Exception`. Что значит "проверяемые"? Например, компилятор знает, что 
если программист в коде считывает данные из файла, может легко возникнуть ситуация, что файл не существует. И таких 
ситуаций, которые он может заранее предположить, очень много. Поэтому компилятор заранее проверяет наш код на наличие 
потенциальных исключений. Если он их найдет, то не скомпилирует код, пока мы не обработаем их или не пробросим наверх. 

Второй вид исключений - "непроверяемые". Они происходят от класса `RuntimeException`. Чем же они отличаются от 
проверяемых? Разница в том, что этих ошибок компилятор не ожидает. Непроверяемые исключения чаще всего являются 
следствием ошибок программиста. А компилятор не в силах предусмотреть все возможные неправильные ситуации, которые люди 
могут создать своими руками. Поэтому он не проверяет обработку таких исключений в коде. Несколько примеров 
unchecked-исключений: `ArithmeticException` - возникает при делении на ноль. `ArrayIndexOutOfBoundsException` - 
возникает при попытке обратиться к ячейке за пределами массива.

[к оглавлению](#OOP)

## 34. Как обрабатываются исключительные ситуации?

В Java есть пять ключевых слов для работы с исключениями:

+ `try` — используется для отметки начала блока кода, который потенциально может привести к ошибке.

+ `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
  Последовательность блоков catch должна идти от частного к более общему. В противном случае будет ошибка компиляции.

+ `finally` — ключевое слово для отметки начала блока кода, которой является дополнительным.
  Этот блок помещается после последнего блока `catch`. Управление обычно передаётся в блок `finally` в любом случае.

+ `throw` — служит для генерации исключений.

+ `throws` — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее,
  что метод потенциально может выбросить исключение с указанным типом.

Общий вид конструкции для «поимки» исключительной ситуации выглядит следующим образом:

Для обработки исключений используется конструкция `try-catch-finally` и c 7й Java `try-with-resources`.

**`try-catch-finally`**:
```java
try { 
    //здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //здесь описываются действия, направленные на обработку исключений 
} 
finally { 
    //выполняется в любом случае (блок finally  не обязателен) 
}
```
Пример 1.
```java
try{ 
    fis = new FileInputStream(fileName); 
} catch (Exception ex) {    
    //... 
} catch (IOException e) { 
    //... 
} 
```
Пример 2. Начиная с Java 7 можно переотлавливать несколько исключений одни блоком catch.
```java
try {  
    //... 
} catch( IOException | SQLException ex ) {  
    logger.log(ex); 
    throw ex; 
} 
```

**`try-with-resources`**:
```java
try(открываем файл и т.п. здесь) {
    //здесь код, который потенциально может привести к ошибке 
}
//после блока файл закроется автоматически.
```

Пример 1.
```java
BufferedReader br = new BufferedReader(new FileReader(path));
   try {
        return br.readLine();
   } finally {
        if (br != null) {
            br.close();
        }
   }
```
Пример 2. Java 7
```java
try (BufferedReader br = new BufferedReader(new FileReader(path)) ) {
    return br.readLine();
}
```

[к оглавлению](#OOP)

## 35. Назовите основные методы класса Object?

Основные методы:

возвращает строковое представление объекта:
```java
public String toString()
```

возвращает хэш-код, связанный с вызывающим объектом:
```java
public native int hashCode()
```

определяет, равен ли один объект другому:
```java
public boolean equals(Object obj)
```

возвращает специальный объект, который описывает текущий класс:
```java
public final native Class getClass()
```

Метод позволяет клонировать объект: создает дубликат объекта:
```java
protected Object clone()
```

вызывается перед удалением неиспользуемого объекта. Позволяет "освободить" родные не-Java ресурсы:
```java
protected void finalize()
```

Методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей:
```java
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout)
public final void wait(long timeout, int nanos)
public final void wait()
```

[к оглавлению](#OOP)

## 36. Что такое шаблоны проектирования?

**Паттерн проектирования** — это часто встречающееся решение определённой проблемы при проектировании архитектуры 
программ.

В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет 
собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить 
под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если 
алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может 
отличаться в двух разных программах.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором 
нарисовано решение, но не конкретные шаги его реализации.

### Из чего состоит паттерн?

Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:

+ проблема, которую решает паттерн;
+ мотивации к решению проблемы способом, который предлагает паттерн;
+ структуры классов, составляющих решение;
+ примера на одном из языков программирования;
+ особенностей реализации в различных контекстах;
+ связей с другими паттернами.

[к оглавлению](#OOP)

## 37. Объясните шаблон "декоратор".

**Декоратор** — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую 
функциональность, оборачивая их в полезные «обёртки».

[Декоратор. Также известен как: Wrapper, Обёртка, ](https://refactoring.guru/ru/design-patterns/decorator)

[к оглавлению](#OOP)

## 38. Объясните шаблон "стратегия".

**Стратегия** — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает 
каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

[Стратегия. Также известен как: Strategy](https://refactoring.guru/ru/design-patterns/strategy)

[к оглавлению](#OOP)
